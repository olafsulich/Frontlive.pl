---
title: 'Svelte - nie tylko React, Vue i Angular'
category: 'Svelte'
publishedAt: '08-07-2020'
isPublished: true
popular: false
image: '/images/main.png'
excerpt: 'Obecnie w Å›rodowisku frontendowym mamy Å›wiÄ™tÄ… trÃ³jcÄ™ jeÅ›li chodzi o frameworki/biblioteki UI. Jest to jak zapewne wiecie React, Vue i Angular. Warto jednak wyrwaÄ‡ siÄ™ na chwilÄ™ z tej baÅ„ki i poznaÄ‡ coÅ›Â innego. Pora na Svelte!'
---

CzeÅ›Ä‡ ğŸ‘‹

Obecnie w Å›rodowisku frontendowym mamy _Å›wiÄ™tÄ… trÃ³jcÄ™_ jeÅ›li chodzi o frameworki/biblioteki UI. Jest to jak zapewne wiecie React, Vue i Angular. Warto jednak wyrwaÄ‡ siÄ™ na chwilÄ™ z tej baÅ„ki i **poznaÄ‡ coÅ›Â innego**. DokÅ‚adnie tak byÅ‚o w moim przypadku, chciaÅ‚em **czegoÅ› nowego** i natrafiÅ‚em na **Svelte**. W tym wpisie chciaÅ‚bym siÄ™ podzieli **moimi przemyÅ›leniami**, wprowadzajÄ… was jednoczeÅ›nie w Å›wiat Svelte, zaczynajmy!

## Wprowadzenie

Svelte jest **frameworkiem**, trochÄ™ podobnym do Reakta, trochÄ™ do Vue, takie to dziwne, ale **przyjemne poÅ‚Ä…czenie**. GÅ‚Ã³wnÄ… rÃ³Å¼nicÄ… pomiÄ™dzy popularnymi frameworkami a Svelte, jest to, Å¼e Svelte nie korzysta z [Virtual DOM](https://svelte.dev/blog/virtual-dom-is-pure-overhead), a zamiast niego pracuje na zwykÅ‚ym [DOMie](https://developer.mozilla.org/pl/docs/DOM_i_JavaScript). TwÃ³rcy reklamujÄ… Svelte jako rozwiÄ…zanie, ktÃ³re nie posiada za duÅ¼o niepotrzebnego boilerplatu.

Czy tak jest na prawdÄ™? **SprawdÅºmy!**

> Nie traktuj tego wpisu jako poradnika/kursu Svelte, jest to luÅºne wprowadzenie, pokazujÄ…ce gÅ‚Ã³wne koncepty tego frameworka

Ten sam komponent napisany w Reakcie, Vue i Svelte:

**React:**

```jsx
import React, { useState } from "react";

export default const App = () => {
  const [a, setA] = useState(1);
  const [b, setB] = useState(2);

  function handleChangeA(event) {
    setA(+event.target.value);
  }

  function handleChangeB(event) {
    setB(+event.target.value);
  }

  return (
    <div>
      <input type="number" value={a} onChange={handleChangeA} />
      <input type="number" value={b} onChange={handleChangeB} />

      <p>
        {a} + {b} = {a + b}
      </p>
    </div>
  );
};
```

**Vue:**

```html
<template>
  <div>
    <input type="number" v-model.number="a" />
    <input type="number" v-model.number="b" />

    <p>{{a}} + {{b}} = {{a + b}}</p>
  </div>
</template>

<script>
  export default {
    data: function () {
      return {
        a: 1,
        b: 2,
      };
    },
  };
</script>
```

**Svelte:**

```html
<script>
  let a = 1;
  let b = 2;
</script>

<input type="number" bind:value="{a}" />
<input type="number" bind:value="{b}" />

<p>{a} + {b} = {a + b}</p>
```

WyglÄ…da zachÄ™cajÄ…co? **No to zaczynajmy!**

## PoczÄ…tek

Zacznijmy od poczÄ…tku, zainstalujmy Svelte:

```bash
npx degit sveltejs/template my-svelte-project

```

W Svelte nasz komponent ma koÅ„cÃ³wkÄ™ `.svelte` i skÅ‚ada siÄ™ z trzech czÄ™Å›ci: logiki, stylÃ³w i treÅ›ci.

```html
<script>
  import SomeComponent from './SomeComponent.svelte';

  const name = 'John';
</script>

<style>
  .name {
    color: #213454;
  }
</style>

<p class="name">Hello, my name is {name}</p>
<SomeComponent />
```

Nasza logika bÄ™dzie umieszczana w tagu `<script>`, style w `<style>`, a sama treÅ›Ä‡Â *luÅºno* wrzucona pod nimi. Dla kogoÅ› kto miaÅ‚ juÅ¼ do czynienia z innym frameworkiem, nie bÄ™dzie tutaj zaskoczenia. Tworzymy zmienna, a nastÄ™pnie podajemy jÄ… w tzw. **wÄ…sach**. Style dziaÅ‚ajÄ… **w zakresie pliku**.

## Logika i Propsy

Znamy juÅ¼ podstawy, teraz przyszedÅ‚ czas na wprowadzenie jakieÅ› **logiki**, **propsÃ³w**.

Zacznijmy od tych drugich, propsy przekazujemy:

**Component.svelte:**

```html
<script>
  export let name;
</script>

<p>My name is {name}</p>
```

Tak _pobieramy_ propsy od naszego rodzica, trochÄ™Â dziwne, przecieÅ¼ w zwykÅ‚ym JavaScripcie `export` dziaÅ‚a w inny sposÃ³b ğŸ¤”

Nie martw siÄ™Â to dopiero poczÄ…tek Sveltowych **dziwactw**.

A tak przekazujemy propsy:

**App.svelte:**

```html
<script>
  import Component from './Component.svelte';

  let name = 'Olaf';
</script>

<Component name="{name}" />
```

Propsy moÅ¼emy rÃ³wnieÅ¼ [spreadowaÄ‡](https://developer.mozilla.org/pl/docs/Web/JavaScript/Referencje/Operatory/Spread_operator) i podawaÄ‡ im defaultowÄ… wartoÅ›Ä‡ - `export let name = "Kuba"`.

PrzejdÅºmy do logiki i blokÃ³w `if/else`. Tutaj pojawia siÄ™Â rzecz, ktÃ³rej na prawdÄ™ **nie lubiÄ™** w Svelte. WydajÄ™ mi siÄ™Â to maÅ‚o czytelne i lepszym rozwiÄ…zaniem byÅ‚oby klasyczne podejÅ›cie, zobaczmy jak to wyglÄ…da:

```js
<script>
  let isOn = false;

  function toggle() {
    isOn = !isOn;
  }
</script>

<button on:click="{toggle}">
  Toggle me
</button>

{#if isOn}
	<span>
    ğŸ‘‹
  <span>
{:else}
	<span>
    âŒ
  <span>
{/if}
```

Blok otwieramy znakiem `#` a zamykamy `/`, moÅ¼emy w Å›rodku wyraÅ¼enia, dodaÄ‡ jakaÅ› _kontynuacjÄ™_, czyli w tym przypadku `:else` i ta _kontynuacja_ musi byÄ‡ poprzedzona `:`.

> MoÅ¼esz tutaj zauwaÅ¼yÄ‡ zdarzenie `on:click`, ale o tym za chwilÄ™!

Kolejnym elementem logiki bÄ™dzie **iterowanie** i zwracanie jakiÅ› **danych** z tablicy, coÅ› co czÄ™sto robimy chociaÅ¼by w **Reakcie**.

```js
<script>
  let animals = [
    { name: "Cat", emoji: "ğŸ±" },
    { name: "Dog", emoji: "ğŸ¶" },
    { name: "Panda", emoji: "ğŸ¼" },
  ];
</script>

<ul>
  {#each animals as animal}
  <li>
    <h2>{animal.name}</h2>
    <span>{animal.emoji}</span>
  </li>
  {/each}
</ul>
```

Tym razem zamiast `if` uÅ¼ywamy bloku `each`, ktÃ³ry **przeiteruje** po naszych zwierzÄ™tach i **zwrÃ³ci nam potrzebne dane**.

> MoÅ¼emy uÅ¼yÄ‡ tutaj **destrukturyzacji**, podaÄ‡ po przecinku `index` jak w mapie, a nawet przekazaÄ‡ klucz, dziÄ™ki ktÃ³remu bÄ™dziemy mogli wykonywaÄ‡ specjalne akcje `{#each animals as animal (animals.name)}`

## Zdarzenia

Tutaj nie ma wiÄ™kszego zaskoczenia, zdarzenia podajemy z poczÄ…tkiem `on:` i **nazwÄ… danego eventu**.

```html
<button on:click="{e => console.log(e.target)}">Hi there ğŸ‘‹</button>
```

CiekawÄ… sÄ… za to **modyfikatory**, dziÄ™ki ktÃ³rym moÅ¼emy wpÅ‚ywaÄ‡ na dziaÅ‚anie samego zdarzenia, na przykÅ‚ad wywoÅ‚aÄ‡ je tylko raz:

```html
<button on:click|once="{e => console.log(e.target)}">Hi there ğŸ‘‹</button>
```

Przydatne bÄ™dzie na pewno uÅ¼ycie **modyfikatora** `preventDefault`. W Å‚atwy sposÃ³b moÅ¼emy rÃ³wnieÅ¼ **dispachowaÄ‡** zdarzenia korzystajÄ…c ze specjalnej funkcji `createEventDispatcher()`.

**Component.svelte**

```html
<script>
  import { createEventDispatcher } from 'svelte';

  const dispatch = createEventDispatcher();

  function sayHello() {
    dispatch('say-hello', {
      message: 'Hello!',
    });
  }
</script>

<button on:click="{sayHello}">Hi there ğŸ‘‹</button>
```

**App.svelte**

```html
<script>
  import Component from './Component.svelte';

  function handleSayHello(e) {
    console.log(e.detail.message);
  }
</script>

<Component on:say-hello="{handleSayHello}" />
```

## ReaktywnoÅ›Ä‡ i Binding

DziÄ™ki reaktywnoÅ›ci w Svelte, pewne dane mogÄ… byÄ‡ zaleÅ¼ne od siebie i tworzyÄ‡ tzw. **reaktywne deklaracje**, takim przykÅ‚adem jest `doubled`, ktÃ³ry jest po prostu dwukrotnoÅ›ciÄ… `count`.

```html
<script>
  let count = 0;
  $: doubled = count * 2;

  function handleClick() {
    count += 1;
  }
</script>

<button on:click="{handleClick}">Clicked {count} {count === 1 ? 'time' : 'times'}</button>

<p>{count} doubled is {doubled}</p>
```

> ReaktywnoÅ›Ä‡ w Svelte to nie tylko deklaracje, moÅ¼emy rÃ³wnieÅ¼ korzystaÄ‡ ze statementÃ³w, przykÅ‚ad takiego wykorzystania znajdziesz [w oficjalnym poradniku Svelte](https://svelte.dev/tutorial/reactive-statements)

**Bindingi** uÅ‚atwiajÄ… nam pracÄ™, odciÄ…Å¼ajÄ…c nas trochÄ™ z **niepotrzebnego boilerplatu**.

WeÅºmy przykÅ‚adowe zdarzenie `on:input`, stwÃ³rzmy funkcjÄ™ `onChange`, ktÃ³ra bÄ™dzie uaktualniaÅ‚a naszÄ… zmiennÄ… `name`, caÅ‚oÅ›Ä‡ wyÅ›wietlimy w tagu `h1`.

```html
<script>
  let name = 'world';

  function onChange(e) {
    name = e.target.value;
  }
</script>

<input on:input="{onChange}" />

<h1>Hello {name}!</h1>
```

Nie ma tutaj za duÅ¼o tego niepotrzebnego kodu, moglibyÅ›my to trochÄ™ skrÃ³ciÄ‡, wstawiajÄ…c funkcjÄ™ inlinowo do zdarzenia, ale to trochÄ™ **psujÄ™ czytelnoÅ›Ä‡**.

Na ratunek przychodzÄ… wÅ‚aÅ›nie **bindingi**!

```html
<script>
  let name = 'world';
</script>

<input bind:value="{name}" />

<h1>Hello {name}!</h1>
```

BindowaÄ‡ moÅ¼emy rÃ³Å¼ne wartoÅ›ci, zaczynajÄ…c od zwykÅ‚ego **tekstu** po wartoÅ›ci `boolean`, `this` i koÅ„czÄ…c np. na **wymiarach elementu**(tutaj wartoÅ›ci typu `number`):

```html
<script>
  let w;
  let h;
  let size = 42;
  let text = 'edit me';
</script>

<style>
  input {
    display: block;
  }
  div {
    display: inline-block;
  }
  span {
    word-break: break-all;
  }
</style>

<input type="range" bind:value="{size}" />
<input bind:value="{text}" />

<p>size: {w}px x {h}px</p>

<div bind:clientWidth="{w}" bind:clientHeight="{h}">
  <span style="font-size: {size}px">{text}</span>
</div>
```

## Metody cyklu Å¼ycia komponentu

KaÅ¼dy komponent w Svelte, ma wÅ‚asne **metody cyklu Å¼ycia**, sÄ… to, jak moÅ¼ecie siÄ™ domyÅ›laÄ‡, **specjalne funkcjÄ™**, ktÃ³re pozwalajÄ… uruchomiÄ‡ jakiÅ› kod w danym **momencie tego cyklu**.

PierwszÄ…Â z nich jest `onMount`, dziaÅ‚a ona na podobnej zasadzie jak metoda `componentDidMount` w React. Ta metoda wywoÅ‚ywana jest wtedy, gdy komponent pierwszy raz **wyrenderuje** siÄ™ w [DOM](https://developer.mozilla.org/pl/docs/DOM_i_JavaScript). Tutaj powinny odbywaÄ‡ siÄ™ wszystkie zapytania do API:

```html
<script>
  import { onMount } from 'svelte';

  let user = [];

  onMount(async () => {
    const res = await fetch(`https://randomuser.me/api/`);
    user = await res.json();
  });
</script>
```

KolejnÄ… metodÄ… jest `onDestroy`, odpala siÄ™Â ona gdy komponent zostaje _zniszczony_, czy teÅ¼ Å‚adniej mÃ³wiÄ…c zostajÄ™ _odmontowany_. Tutaj **czyÅ›cimy** wszelkiego rodzaju subskrypcje z `onMount`, czy teÅ¼ timery:

```html
<script>
  import { onDestroy } from 'svelte';

  let seconds = 0;

  function onInterval(callback, milliseconds) {
    const interval = setInterval(callback, milliseconds);

    onDestroy(() => {
      clearInterval(interval);
    });
  }

  onInterval(() => (seconds += 1), 1000);
</script>

<p>The page has been open for {seconds} {seconds === 1 ? 'second' : 'seconds'}</p>
```

OprÃ³cz tych dwÃ³ch podstawowych mamy jeszcze metody `beforeUpdate` i `afterUpdate`. OdpalajÄ… siÄ™ one odpowiednio **przed** i **po zaktualizowaniu** [DOM](https://developer.mozilla.org/pl/docs/DOM_i_JavaScript).

## Store

W Svelte moÅ¼emy stworzyÄ‡ tzw. `store`, bÄ™dzie to taki globalny stan naszej aplikacji, z ktÃ³rego bÄ™dziemy mogli korzystaÄ‡ w **niezaleÅ¼nych** od siebie komponentach. DziÄ™ki temu moÅ¼emy **uniknÄ…Ä‡** ciÄ…gÅ‚ego przekazywania propsÃ³w w dÃ³Å‚ naszego drzewka. Tutaj dla przykÅ‚adu, stworzyliÅ›my store i wszystkie komponenty w jednym pliku, jednak dobrÄ… praktykÄ… byÅ‚o **rozdzielenie** ich na osobne komponenty, wtedy `store` stajÄ™ siÄ™ uÅ¼yteczny.

Store to po prostu obiekt, ktÃ³ry posiada metody: `set`, `update` i `subscribe`. Subscribe nie bÄ™dzie nam tutaj przydatny, poniewaÅ¼, nie musimy subskrybowaÄ‡ do danej wartoÅ›ci i pÃ³Åºniej czyÅ›ciÄ‡ tÄ… subskrypcje, wystarczy, Å¼e **przed** nazwÄ… stora dodamy `$`, dziÄ™ki temu dostaniemy jego **wartoÅ›Ä‡**.

```html
<script>
  import { writable } from 'svelte/store';

  const store = writable(0);

  function reset() {
    store.set(0);
  }

  function increment() {
    store.update((n) => n + 1);
  }

  function decrement() {
    store.update((n) => n - 1);
  }
</script>

<h1>The count is {$store}</h1>

<button on:click="{increment}">+</button>
<button on:click="{decrement}">-</button>
<button on:click="{reset}">reset</button>
```

## Slots

SÄ… to specjalne komponenty, ktÃ³re mogÄ… przyjmowaÄ‡ **dzieci**. Slota definiujemy jak normalny tag html `<slot></slot>`, moÅ¼emy mu nadaÄ‡ **nazwÄ™** i odpowiedni **defaultowy content**, w przypadku gdy nie zostanie on podany. Ten **fallback**, czyli poczÄ…tkowy kontent, podajemy w Å›rodku slota, dziÄ™ki nazwie za to, mamy **wiÄ™kszÄ… kontrolÄ™** nad `slotami` i moÅ¼emy definiowaÄ‡ to, w **jaki sposÃ³b** bÄ™dÄ… _przetwarzane_ dane z nich.

**Animal.svelte**

```html
<style>
  .box {
    width: 300px;
    border: 1px solid #aaa;
    border-radius: 2px;
    box-shadow: 2px 2px 8px rgba(0, 0, 0, 0.1);
    padding: 1em;
    margin: 0 0 1em 0;
  }
</style>

<div class="box">
  <slot name="animal-name">
    <h1>Panda</h1>
  </slot>
  <slot name="animal-emoji">
    <span>ğŸ¼</span>
  </slot>
</div>
```

**App.svelte**

```html
<script>
  import Animal from './Animal.svelte';
</script>

<Animal>
  <h2 slot="animal-name">Dog</h2>
  <p slot="animal-emoji">ğŸ¶</p>
</Animal>
```

Do `slotÃ³w` moÅ¼emy przekazywaÄ‡ rÃ³wnieÅ¼ [propsy](https://svelte.dev/tutorial/slot-props).

## Podsumowanie

To by byÅ‚o na tyle w tym krÃ³tkim wstÄ™pie do Svelte, zostaÅ‚o jeszcze **duÅ¼o rzeczy** do nauczenia, ktÃ³rych nie poruszyÅ‚em tutaj. SzczegÃ³lnie fajne wydajÄ… siÄ™ [animacjÄ™](https://svelte.dev/tutorial/transition), warto sprawdziÄ‡!

Svelte ma Å›wietny [tutorial](https://svelte.dev/tutorial/basics), z ktÃ³rego korzystaÅ‚em w tym wpisie. DostÄ™pne sÄ… rÃ³wnieÅ¼ gotowe przykÅ‚ady ktÃ³re znajdziesz [tutaj](https://svelte.dev/examples).

Svelte wydajÄ™Â siÄ™ bardzo fajnym, **szybkim** i **lekkim** rozwiÄ…zaniem, ktÃ³re na pewno **redukujÄ™** duÅ¼o niepotrzebnego boilerplatu, czÄ™Å›Ä‡ rzeczy mi siÄ™ w nim podoba, czÄ™Å›Ä‡ nie, ale **nie ma rozwiÄ…zaÅ„ idealnych**. MyÅ›lÄ™ jednak, Å¼e warto zainteresowaÄ‡ siÄ™ nim i daÄ‡ mu szansÄ™, chociaÅ¼by dla czystej zabawy!

Do usÅ‚yszenia!

## Å¹rÃ³dÅ‚a

- [Svelte Docs](https://svelte.dev/tutorial/basics)
