---
title: 'TypeScript - podstawy'
category: 'TypeScript'
publishedAt: '08-05-2020'
isPublished: true
popular: false
image: '/images/typescript-podstawy/typescript-podstawy.png'
excerpt: 'TypeScript jest statycznie typowanym jÄ™zykiem od Microsoftu, bazuje on na JS. Uwierz mi, jak juÅ¼ go poznasz, nie bÄ™dziesz chciaÅ‚ siÄ™ wracaÄ‡ do czystego JavaScriptu '
---

## Wprowadzenie

CzymÅ¼e jest **TypeScript**? TypeScript jest to **statycznie typowany** jÄ™zyk od Microsoftu, bazuje on na JavaScripcie, do ktÃ³rego jest kompilowany. Jest to nieoficjalny **superset js**, uwierz mi, jak juÅ¼ go poznasz, **nie bÄ™dziesz chciaÅ‚ siÄ™ wracaÄ‡** do _czystego_ JavaScriptu!

## O czym jest i o czym nie jest ten wpis?

Dzisiejszy materiaÅ‚ jest doÅ›Ä‡ solidnym wprowadzeniem w **czysto techniczne** aspekty TypeScripta, samo miÄ™so. Zapoznamy siÄ™ dzisiaj z **podstawowymi typami**, **funkcjami** i **interfejsami**. Czeka na Ciebie jeszcze parÄ™ niespodzianek, ale nie bÄ™dÄ™ spojlerowaÅ‚ ğŸ¤.

Nie poruszaÅ‚em tutaj **konfiguracji caÅ‚ego Å›rodowiska**. ZrobiÅ‚ juÅ¼ to Marcin z Algosmart jakiÅ› czas temu. Tutaj link do jego materiaÅ‚u wideo: [https://www.youtube.com/watch?v=3E1lu88NPWY](https://www.youtube.com/watch?v=3E1lu88NPWY). Pssst! ChÅ‚opaki z [Przeprogramowanych](https://www.youtube.com/channel/UCb2Y3vMeD6N4WDt5Acw7Arw) majÄ… rÃ³wnieÅ¼ super seriÄ™ o Pair Programmingu w TS, polecam! Nie zagÅ‚Ä™biaÅ‚em siÄ™ teÅ¼ za specjalnie w to, **jakie korzyÅ›ci** daje nam TypeScript, zrobiÅ‚ to za to, bardzo dobrze zresztÄ…, MichaÅ‚ na blogu [Typeofweb](https://typeofweb.com/typescript-na-serwerze/).

Reszta, bardziej zaawansowanych tematÃ³w, u mnie, **za tydzieÅ„!**

## Co powinieneÅ› wiedzieÄ‡?

Przed naukÄ… TS, powinieneÅ›Â **poznaÄ‡ JavaScript**. Dlatego bez podstawowej znajomoÅ›ci js i skÅ‚adni ES6+ ani rusz!

## Podstawowe typy

- string
- number
- boolean
- array
- object & Object
- enum
- any
- void
- null i undefined
- never
- tuple
- BigInt
- unknown
- symbol & unique symbol

Prawdopodobnie kojarzysz wiÄ™kszoÅ›Ä‡ z nich, obce mogÄ™ byÄ‡ Ci typy: `enum`,`any`,`void`, `tuple` i `never`. Zajmiemy siÄ™ nimi za chwilÄ™. Typami `BigInt`, `unknow` oraz `symbol` i `unique symbol` zajmniemy siÄ™ w nastÄ™pnym wpisie.

SpÃ³jrzmy na przykÅ‚adach:

```ts
const userName: string = 'Kuba';
const userAge: number = 23;
const isUserAdult: boolean = true;
const userInfo: object = {};
const userFavoriteFood: [] = [];
```

ZaÅ‚Ã³Å¼my, Å¼e nasza tablica `userFavoriteFood` zawiera ulubione jedzenie Kuby, wartoÅ›ci bÄ™dÄ… typu `string`.
Jak to otypowoaÄ‡? Wystarczy, Å¼e przed tablicÄ… dasz znaÄ‡ typescriptowi jakiego typu bÄ™dÄ… jej wartoÅ›ci.

```ts
const userFavoriteFood: string[] = ['chocolate ğŸ«', 'hamburger ğŸ”', 'chips ğŸŸ'];
```

### Enum

Z definicji sÅ‚uÅ¼Ä… do grupowania numerycznych wartoÅ›ci, jest to pewnego rodzaju zbiÃ³r. Elementy enuma(tak, wiem, jak to brzmi), numerowane sÄ… od zera. SpÃ³jrzmy na przykÅ‚adzie:

```ts
enum FirstSecond {
  1,
  2,
}
console.log(FirstSecond.1); // 0
console.log(FirstSecond.2); // 1
```

MoÅ¼emy jednak to zmieniÄ‡:

```ts
enum FirstSecond {
  First = 1,
  Second,
}
console.log(FirstSecond.First); // 1
console.log(FirstSecond.Second); // 2
```

Enumy sÄ… czÄ™sto wykorzystywane na bazie strigÃ³w.

```ts
enum FirstSecond {
  First = 'First',
  Second = 'Second',
}
console.log(FirstSecond.First); // "First"
console.log(FirstSecond.Second); // "Second"
```

### Any

Oznacza kaÅ¼dy typ, jeÅ›li to moÅ¼liwe, **unikaj** wrzucania `any` tam, gdzie nie ma ono zastosowania.

```ts
let anyValue: any = 4;
anyValue = '4';
anyValue = false;

const anyArray: any[] = ['ğŸŒ¶ï¸', 0, true, {}];
```

### Void

W pewnym sensie przeciwieÅ„stwo `any`, jest to typ **"brak typu"**. NajczÄ™Å›ciej uÅ¼ywany przy funkcjach, jako oznaczenie, Å¼e dana funkcja nic nie zwraca:

```ts
function printInfo(): void {
  console.log('Some information!');
}
```

### Tuple

Typ **tuple** pozwala zadeklarowaÄ‡ tablicÄ™ z wartoÅ›ciami o rÃ³Å¼nych typach. Nie muszÄ… byÄ‡ one takie same, jeÅ›li znamy typy wartoÅ›ci, moÅ¼emy zamiast `any`, podaÄ‡ typ `tuple`.

```ts
const tupleArray: [string, number, boolean, object] = ['ğŸŒ¶ï¸', 0, true, {}];
```

### Never

Typ never reprezentuje typ, ktÃ³ry nigdy nie przemija. MoÅ¼e byÄ‡ sub typem kaÅ¼dego typu (oprÃ³cz samego siebie).
Pewnie niewiele Ci to mÃ³wi, spÃ³jrzmy na przykÅ‚adzie. Funkcja, ktÃ³ra zwraca never, musi mieÄ‡ tzw [unreachable end point](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Stmt_after_return).

```ts
function error(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}
```

### Asercja TypÃ³w

Powiedzmy, Å¼e zadeklarowaÅ‚eÅ› w pewnym momencie zmienÄ… typu `any`. Po jakimÅ› czasie wiesz, Å¼e ta zmienna powinna byÄ‡ typu string. Za pomocÄ… asercji typÃ³w moÅ¼esz oznajmiÄ‡ TypeScriptowi, Å¼e wiesz, co robisz. Nie wpÅ‚ywa ona na runtime, jest uÅ¼ywana tylko w procesie kompilacji. AsercjÄ™ moÅ¼emy zapisaÄ‡ na dwa sposoby.

### Opcja nr. 1

Tej opcji nie moÅ¼emy uÅ¼yÄ‡ w Reactcie. Dozwolona jest jedynie ta druga.

```ts
let someValue: any = 'this is a string';

let strLength: number = (<string>someValue).length;
```

### Opcja nr. 2

```ts
let someValue: any = 'this is a string';

let strLength: number = (someValue as string).length;
```

PowyÅ¼sze stwierdzenia dziaÅ‚ajÄ… w ten sam sposÃ³b, kwestia preferencji... No chyba, Å¼e piszesz w Reactcie.

## Tablice

ZagÅ‚Ä™bmy siÄ™ na chwile w wÄ…tku tablic. W TS dzielÄ… siÄ™ one na dwa rodzaje.

- lista - wszystkie elementy majÄ…Â ten sam typ.
- tuple - elementy niekoniecznie muszÄ… mieÄ‡ ten sam typ.

### Lista

I tutaj znowu mamy dwa podejÅ›cia - uÅ¼ycie **Type literals** lub globalnych **InterfejsÃ³w**, a dokÅ‚adniej **Generics**. Na obecnÄ… chwilÄ™, nie przejmuj siÄ™ terminologiÄ…, to wszystko, o czym teraz wspominam, poznasz w dalszej czÄ™Å›ci tej serii.

```ts
// Type literals
const myClassMates: string[] = ['Kuba', 'Wiktor', 'Kamil'];

// Globalne Interfejsy(Generics)
const myClassMates: Array<string> = ['Kuba', 'Wiktor', 'Kamil'];
```

> PowyÅ¼sze przykÅ‚ady dziaÅ‚ajÄ… na tej samej zasadzie.

### Tuple array

JeÅ¼eli zapoznaÅ‚eÅ› siÄ™Â z podstawowymi typami, to nie bÄ™dzie to dla Ciebie zaskoczenie.

```ts
const tupleArray: [string, number, boolean, object] = ['ğŸŒ¶ï¸', 0, true, {}];
```

## Funkcje

Okej, pora na funckjÄ™, jak wyglÄ…dajÄ… one w przypadku TypeScripta?

```ts
function addNumbers (a: number, b: number): number {
    return a + b;
}
```

WyjaÅ›nijmy sobie powyÅ¼szy przykÅ‚ad. KaÅ¼dy parametr funkcji ma wÅ‚asny typ, definiujemy go **dwukropkiem**.
Po nawiasach `()`, podajemy typ, jaki bÄ™dzie miaÅ‚a zwracana wartoÅ›Ä‡ z funkcji.
Taka sama konstrukcja tyczy siÄ™ **funkcji strzaÅ‚kowych**.

```ts
const addNumbers = (a: number, b: number): number => a + b;
```

### Parametry

Jak juÅ¼ wiesz parametry funkcji typujemy po dwukropku.

```ts
const getUserName = (userName: string) => {...}
```

#### Opcjonalne parametry

Defaultowo wszystkie parametry sÄ… wymagane, moÅ¼emy to jednak zmieniÄ‡ stawiajÄ…c znak zapytania przed dwukropkiem.

```ts
function makeUserMoreCool(userName?: string): string {
  if (userName === undefined) {
    return '';
  }
  return userName.concat(' is cool');
}
```

#### Defaultowe parametry

MoÅ¼emy podaÄ‡ domyÅ›lnÄ… wartoÅ›Ä‡ dla parametru funkcji, gdy to zrobimy, typescript domyÅ›li siÄ™ jaki jest typ naszej wartoÅ›ci.

```ts
function makeUserMoreCool(userName = ""): string {...}
```

JeÅ›li chcesz, moÅ¼esz nadal otypowoaÄ‡ dany parametr:

```ts
function makeUserMoreCool(userName: string = ""): string {...}
```

#### Parametry rest

`Rest`, jak pewnie wiesz z JavaScriptu, _zbiera_ pozostaÅ‚e parametry z tablicy. Jak to otypowaÄ‡?
SprawdÅºmy!

```ts
function getUserInfo(userName: string, ...remainingInfo: string[]) {...}
```

W przypadku `rest` fajnie sprawdza siÄ™ `tuple`:

```ts
function getUserInfo(...[userName, age]: [string, number]): string {...}
```

#### Named parameters + destrukturyzacja

Jak pewnie wiesz, w JavaScripcie moÅ¼esz destrukturyzowaÄ‡ parametry funkcji, dziÄ™ki temu mamy dostÄ™p do symulowanych, ale jednak Named parameters. MoÅ¼emy otypowaÄ‡ takÄ… konstrukcjÄ™ w nastÄ™pujÄ…cy sposÃ³b:

```ts
function getUserInfo({userName,favouriteFood,age = 22}: {userName:string, favouriteFood: string[], age: number}): string {...}

```

## Interface

Napiszmy funkcjÄ™, ktÃ³ra przyjmuje zdestrukturyzowanÄ… wartoÅ›Ä‡ `userName` z obiektu user jako parametr.

```ts
const getUserName = (user:{userName: string}) => {...}
```

Taka konstrukcja jest zrozumiaÅ‚a, ale gdy byÅ›my chcieli zdestrukturyzowaÄ‡ jeszcze 2 lub 3 wartoÅ›ci caÅ‚oÅ›Ä‡ staje siÄ™ maÅ‚o czytelna i powstaje baÅ‚agan.

A co gdybyÅ›my chcieli stworzyÄ‡ nastÄ™pnÄ… funkcjÄ™ z dokÅ‚adnie takimi samymi typami?

Wtedy pojawiajÄ… siÄ™ one - **Interfejsy**.

DziÄ™ki nim moÅ¼emy definiowaÄ‡ **strukturÄ™** objektu. SÄ… one niezmiernie przydatne w klasach, ale o tym w kolejnym wpisie.

StwÃ³rzmy nasz pierwszy **Interface**:

```ts
interface User {
  userName: string;
}

const getUserName = (user: User) => {...}
```

### Opcjonalne typy

Defaultowo, podobnie jak w funkcjach, wszystkie wartoÅ›ci w interfejsach sÄ… wymagane, moÅ¼emy jednak to zmieniÄ‡, dodajÄ…c znak zapytania przed dwukropkiem. Wtedy dany parametr stanie siÄ™ opcjonalny.

```ts
interface User {
  age?: number;
  userName: string;
}

const getUserName = (user: User): string => {...}
```

### Interfejsy i funkcjeÂ 

UÅ¼yjmy interfejsa do otypowania funkcji:

```ts
interface GetUserNameFunc {
  (userName: string): string;
}

let getUserName: GetUserNameFunc;
getUserName = function(name: string){...};
```

### Readonly

JeÅ›li chcesz, aby dana wartoÅ›Ä‡ byÅ‚a tylko do odczytu i Å¼ebyÅ› nie mÃ³gÅ‚ jej modyfikowaÄ‡, powinieneÅ› skorzystaÄ‡ z `readonly`.

```ts
interface User {
  age?: number;
  readonly userName: string;
}
let user: User = {
  userName: 'Mateusz',
};

user.userName = 'PaweÅ‚'; // error
```

### Rozszerzanie interfejsÃ³w

MoÅ¼emy rozszerzaÄ‡ interfejsy uÅ¼ywajÄ…c sÅ‚owa `extends`. StwÃ³rzmy dwa interfejsy - Dog i Animal.

```ts
interface Animal {
  readonly name: string;
  age: number;
}

interface Dog {
  breed: string;
}
```

Chcemy, aby interface Dog posiadaÅ‚ rÃ³wnieÅ¼ name i age, dokÅ‚adnie tak jak ma Animal.

```ts
interface Animal {
  readonly name: string;
  age: number;
}

interface Dog extends Animal {
  breed: string;
}
```

### Indeksowalne typy

Tak samo jak moÅ¼emy typowaÄ‡ funkcjÄ™, moÅ¼emy rÃ³wnieÅ¼ uÅ¼yc interfejsÃ³w z tzw. indeksowalnymi typami.

```ts
interface Animal {
  [index: number]: string;
}
const animalsArray: Animal = ['Zebra', 'Dog'];
const zebra = animalsArray[0]; // Zebra - string
```

W powyÅ¼szym przykÅ‚adzie stworzymliÅ›my **interface Animal**, ktÃ³ry bierze `index` typu number i zwraca string.

## Const assertions

Jest to coÅ› podobnego do asercji typÃ³w, tylko, Å¼e w tym wypadku uÅ¼ywamy `const`. Co daje taka asercja?

- LiteraÅ‚y objektÃ³w dostajÄ… wÅ‚aÅ›ciwoÅ›Ä‡ `readonly`
- Tablice zamieniajÄ…Â siÄ™Â w **tuplesy** `readonly`

```ts
// Typ 'readonly [1, 2, 3, 4]'
let values = [1, 2, 3, 4] as const;

// Typ '{readonly userName: "Piotr" }'
let user = { userName: 'Piotr' } as const;
```

## Type Casting

ZaÅ‚Ã³Å¼my, Å¼e chcemy pobraÄ‡ inupta z naszego html. SprÃ³bujmy dwÃ³ch sposobÃ³w. Pierwszy, za pomocÄ… getElementById, drugi przy pomocy querySelectora.

```ts
const input1 = document.getElementById('my-input');
const input2 = document.querySelector('input');
```

Co dostaniemy w odpowiedzi? Input1 jest typu `HTMLElement | null`, input2 za to ma typ `HTMLInputElement | null`. I co to nam daje? JeÅ›li bÄ™dziemy chcieli wyÅ›wietliÄ‡ wartoÅ›Ä‡ z pierwszego inputa to dostaniemy informacjÄ™, Å¼e value nie wystÄ™puje w typie `HTMLElement | null`.

```ts
const printInputValue = () => input?.value; // error
```

> Zapis ze znakiem zapytania, to optional chaining, wystÄ™puje on rÃ³wnieÅ¼ w JavaScripcie. JeÅ›li chcesz siÄ™ dowiedzieÄ‡ wiÄ™cej, zerknij do poprzedniego posta.

Jak moÅ¼emy to zmieniÄ‡? Zastosujmy asercjÄ™ typÃ³w.

```ts
const input1 = document.getElementById('input') as HTMLInputElement;
const printInputValue = () => console.log(input.value);
```

W przypadku querySelectora, typescript sam wie jakiego typu powinien uÅ¼yÄ‡, wiÄ™c wszystko bÄ™dzie dziaÅ‚aÅ‚o, jak naleÅ¼y.

## Podsumowanie

Uff... To by byÅ‚o wszystko na dzisiaj. PoczÄ…tki sÄ… **najtrudniejsze**!
PamiÄ™taj, najlepiej przeÄ‡wiczysz zdobytÄ…Â dziÅ› wiedzÄ™ **w praktyce**.

Do usÅ‚yszenia w nastÄ™pnym wpisie o **TypeScripcie** ğŸ’™!

### Å¹rÃ³dÅ‚a

- [TypeScriptLang](https://www.typescriptlang.org/docs/home.html)
- [2ality](https://2ality.com/index.html)
