---
title: 'React Children & TypeScript - jak to ogarnÄ…Ä‡?'
category: 'React'
publishedAt: '13-09-2021'
isPublished: true
popular: false
image: '/images/react-children-i-typescript/thumbnail.png'
excerpt: 'Koncepcja dzieci w Reakcie pojawia siÄ™Â nam juÅ¼ w bardzo wczesnych etapach nauki. Ich sposÃ³b dziaÅ‚ania po chwili okazuje siÄ™Â bardzo prosty, ale w praktyce children oferujÄ… znacznie wiÄ™cej, sÄ… trochÄ™ tricky i potrafiÄ…Â zaskoczyÄ‡ ğŸ¤” Jak wiÄ™c sobie z nimi radziÄ‡ i na co uwaÅ¼aÄ‡ podczas ich wykorzystania?'
---

Koncepcja dzieci w Reakcie pojawia siÄ™Â nam juÅ¼ w bardzo wczesnych etapach nauki. Ich sposÃ³b dziaÅ‚ania po chwili okazuje siÄ™Â bardzo prosty, ale w praktyce `children` oferujÄ… znacznie wiÄ™cej, sÄ… trochÄ™ _tricky_ i potrafiÄ…Â zaskoczyÄ‡ ğŸ¤” Jak wiÄ™c sobie z nimi radziÄ‡ i na co uwaÅ¼aÄ‡ podczas ich wykorzystania? Jedziemy z tematem!

## Podstawy

JeÅ›li do tej pory nie sÅ‚yszaÅ‚eÅ› o dzieciach w React, to polecam na starcie odwiedziÄ‡ [oficjalnÄ… dokumentacjÄ™](https://pl.reactjs.org/docs/composition-vs-inheritance.html). A my jedziemy z powtÃ³rkÄ…! Dzieci sÄ… specjalnymi propsami, ktÃ³re pomagajÄ… nam w komponowaniu komponentÃ³w. SpÃ³jrz na przykÅ‚ad:

```tsx
type ListProps = {
  children: '?';
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    <li>Banana ğŸŒ</li>
    <li>Strawberry ğŸ“</li>
  </List>
);
```

Tworzymy dwa komponenty, pierwszy `<List>`, ktÃ³ry bÄ™dzie przyjmowaÅ‚ dzieci, oraz komponent `<App>`, ktÃ³ry bÄ™dzie wywoÅ‚ywaÅ‚ ten pierwszy. Podczas wywoÅ‚ania komponentu `<List>` do jego **Å›rodka** przekazujemy np. elementy HTML, ot caÅ‚a filozofia... Tylko, Å¼e nie do koÅ„ca!

## Typy

I tutaj zaczyna siÄ™ prawdziwa zabawa. W teorii `children` mogÄ… byÄ‡ wszystkim, jednak czÄ™sto chcemy, aby byÅ‚y czymÅ›Â bardziej konkretnym, spÃ³jrzmy na dostÄ™pne opcje:

### ReactNode

Typ `React.ReactNode` to najpopularniejsza z opcji. Korzysta z niej np. niepolecany przeze mnie typ `React.FC`. WracajÄ…c, `React.ReactNode` jest bardzo giÄ™tkim typem i przepuszcza przez nasze dzieci dosÅ‚ownie wszystko: portal, tekst, liczby, boolean, elementy, komponenty...

```tsx
type ListProps = {
  children: React.ReactNode;
};

const List = ({ children }: ListProps) => <div>{children}</div>;

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    Banana ğŸŒ
    {['Strawberry ğŸ“']}
    {false}
  </List>
);
```

> Z typem `React.ReactNode` wiÄ…Å¼e siÄ™Â pewien problem, ale to bardzo rzadki case - dla ciekawskich zostawiam <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/37596" target="_blank" rel="noopener noreferrer">issue na GitHubie</a>.

### ReactElement

DziÄ™ki `React.ReactElement` nasze _children_ bÄ™dÄ… mogÅ‚y byÄ‡ tylko komponentem/elementem HTML:


```tsx
type ListProps = {
  children: Array<React.ReactElement>;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const ListItem = () => <span>Apple ğŸ</span>;

const App = () => (
  <List>
    <ListItem />
    <p>Banana ğŸŒ</p>
    <h2>Strawberry ğŸ“</h2>
  </List>
);
```

### ReactText

Typ `React.ReactText` akceptuje tylko ciÄ…g znakÃ³w/liczb. Zdecydowanie lepsza opcja jeÅ›li chcemy wprowadziÄ‡ takie ograniczenia:

```tsx
type ListProps = {
  children: React.ReactText;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => <List>Apple ğŸ Banana ğŸŒ Strawberry ğŸ“</List>;
```

### ReactChild

Ten typ jest poÅ‚Ä…czeniem (a taka naprawdÄ™ uniÄ…) typÃ³w `ReactElement` i `ReactText`:

```tsx
type ListProps = {
  children: React.ReactChild;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    Apple ğŸ <li>Banana ğŸŒ</li> Strawberry ğŸ“
  </List>
);
```

### Funkcje

DzieÄ‡mi mogÄ… byÄ‡ oczywiÅ›cie rÃ³wnieÅ¼ funkcje, szczegÃ³lnie przydatne przy patternie _render props_:

```tsx
type ListProps = {
  children: () => React.ReactElement;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => <List>{() => <li>Apple ğŸ</li>}</List>;
```

### JSX.Element

CzÄ™sto moÅ¼emy siÄ™ spotkaÄ‡ z typem `JSX.Element`, jest to typ zwracany z metody `React.createElement()`. To tak naprawdÄ™ *tylkoÂ nakÅ‚adka*Â na `React.ReactElement` i pod spodem wyglÄ…da tak:

```tsx
interface Element extends React.ReactElement<any, any> {}
```

Czy warto wiÄ™c go stosowaÄ‡ do typowania `children`? Ja osobiÅ›cie wolÄ™Â korzystaÄ‡ z wspomnianych wczeÅ›niej typÃ³w z prefixem _React_, ale jak to juÅ¼ bywa w Reakcie - peÅ‚na dowolnoÅ›Ä‡.

> _More technical explanation is that a valid React node is not the same thing as what is returned by React.createElement. Regardless of what a component ends up rendering, React.createElement always returns an object, which is the JSX.Element interface, but React.ReactNode is the set of all possible return values of a component._ ~ <a href="https://github.com/typescript-cheatsheets/react/issues/57" target="_blank" rel="noopener noreferrer">Feraber</a>

### React.FC

PrzyszÅ‚a pora na gwiazdÄ™ wieczoru - typ `React.FC`. OsobiÅ›cie odradzam jego stowanie, poniewaÅ¼ wiÄ…Å¼Ä…Â siÄ™Â z nim [pewne problemy](https://github.com/facebook/create-react-app/pull/8177)... NajwaÅ¼niejszym z nich jest to, Å¼e ten typ **z automatu** typuje `children` jako **niewymagane** `ReactNode`. MoÅ¼e to rodziÄ‡ podobne sytuacje:

```tsx
const List: React.FC = () => <ul></ul>;

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    <li>Banana ğŸŒ</li>
    <li>Strawberry ğŸ“</li>
  </List>
);
```

Co wiÄ™c zamiast `React.FC`? Wystarczy normalne typowanie, tak jak w przypadku funkcji.

## ZawÄ™Å¼enie typu

ZaÅ‚Ã³Å¼my, Å¼e w naszym kodzie chcemy zadeklarowaÄ‡, tak jak wyÅ¼ej, komponent `<List>`, ktÃ³ry bÄ™dzie nieoznaczonÄ…Â listÄ…. Z racji tego, Å¼e dzieÄ‡mi `<ul>` mogÄ… byÄ‡ **tylko** `<li>`, chcieli byÅ›my naÅ‚oÅ¼yÄ‡ ograniczenie dla `children` na ten konkretny tag, czy to moÅ¼liwe?

Na pierwszy strzaÅ‚ niech poleci `React.ReactElement`, jest on typem generycznym do ktÃ³rego moÅ¼emy podaÄ‡ konkretny element, czy to wystarczy?

```tsx
type ListProps = {
  children: React.ReactElement<'li'>;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    Banana ğŸŒ Strawberry ğŸ“
  </List>
);
```

OkazujÄ™Â siÄ™, Å¼e nie âŒ SprÃ³bujmy jeszcze inaczej:

```tsx
const ListItem = ({ name }: { name: string }) => <li>{name}</li>;

type ListProps = {
  children: React.ReactElement<'li'>; // âŒ
  children: JSX.InstrictElements['li']; // âŒ
  children: typeof ListItem; // âŒ
  ... //  âŒ
};

```

Te i inne opcje po prostu nie zadziaÅ‚ajÄ… tak jakbyÅ›my tego oczekiwali... Dzieje siÄ™ to z tego wzglÄ™du, Å¼e komponenty/elementy zamieniane sÄ… w locie na typ `JSX.Element`, a szkoda.

## Nie jakoÅ›Ä‡, a iloÅ›Ä‡

Co pozostaje nam, biednym Reaktowcom, jeÅ›li nie moÅ¼emy wskazaÄ‡ dokÅ‚adnego typu? Wskazanie **dokÅ‚adnej iloÅ›ci!** W naszym typie moÅ¼emy wskazaÄ‡ czy `children` bÄ™dÄ… np.Â pojedynczym elementem, tablicÄ… elementÃ³w lub tuplÄ… (tablica o okreÅ›lonej dÅ‚ugoÅ›ci i okreÅ›lonych typach):

```tsx
import { ReactElement, ReactText, ReactFragment } from 'react';

type ListProps = {
  children: ReactElement;
  children: Array<ReactElement>;
  children: [ReactElement, ReactElement, ReactElement];
  children: [ReactElement, ReactText, ReactFragment];
};
```

## Metody iteracyjne

React oprÃ³cz samego mechanizmu komponentÃ³w rodzicÃ³w i dzieci udostÄ™pnia nam rÃ³wnieÅ¼ szereg metod dla API `React.Children`. Nie bÄ™dÄ™ Ci tutaj przytaczaÅ‚ wszystkich, sÄ… one bardzo dobrze opisane w [dokumentacji](https://pl.reactjs.org/docs/react-api.html#reactchildren). ChciaÅ‚bym jednak wrÃ³ciÄ‡ do naszego problemu, wiemy juÅ¼, Å¼e nie moÅ¼emy w peÅ‚ni bezpiecznie otypowaÄ‡ dzieci, jak wiÄ™c obejÅ›Ä‡ ten problem?

1. Deklarujemy typ dla `children`, ustawiamy go jako tablicÄ™Â `React.ReactElement`
2. Korzystamy z metody `toArray` obiektu `Children`, ktÃ³ra zwraca dzieci jako pÅ‚askÄ… strukturÄ™
3. Sprawdzamy, czy aby na pewno nasz `child` jest elementem Reaktowym. Dlaczego tak, skoro w propsach mamy juÅ¼ pewnoÅ›Ä‡? W wyniku metody `toArray` kaÅ¼de z naszych dzieci bÄ™dzie miaÅ‚o typ `ReactChild | ReactFragment | ReactPortal`, my chcemy mieÄ‡ pewnoÅ›Ä‡, Å¼e jest to `ReactElement`. MoglibyÅ›my do tego celu stworzyÄ‡ dedykowanego _type guarda_, ale React nas wyrÄ™cza i udostÄ™pnia funkcjÄ™ `isValidElement`
4. Sprawdzamy, czy typ dziecka jest rÃ³wny typowi jaki posiada `<li>`
5. JeÅ›li tak, klonujemy i zwracamy `child`
6. JeÅ›li nie, wrzucamy `child` w tag `<li>`
7. CaÅ‚oÅ›Ä‡Â opakowujemy w zmiennÄ…Â i przekazujemy do `<ul>`

```tsx
import { Children, ReactElement, isValidElement, cloneElement } from 'react';

type ListProps = {
  // #1
  children: Array<ReactElement>;
};

const List = ({ children }: ListProps) => {
  // #2
  const newChildren = Children.toArray(children).map((child) => {
    // #3
    if (isValidElement(child)) {
      // #4
      if (child.type === 'li') {
        // #5
        return cloneElement(child);
      }
      // #6
      return <li key={child.key}>{child}</li>;
    }
  });
  // #7
  return <ul>{newChildren}</ul>;
};

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    <a href="banana.html">Banana ğŸŒ</a>
    <p>Strawberry ğŸ“</p>
  </List>
);
```

<Newsletter />

### Problemy z React.Fragment

Wszystko byÅ‚oby piÄ™knie, gdyby nie `React.Fragment`. DomyÅ›lnie metoda `React.Children.toArray()` spÅ‚aszcza nam strukturÄ™ `children`, ale... No wÅ‚aÅ›nie, pozostawia fragmenty. Problem pojawia siÄ™ gdy do naszej listy podamy dzieci w takiej formie:

```tsx
<List>
  <li>Apple ğŸ</li>
  <>
    <a href="banana.html">Banana ğŸŒ</a>
    <p>Strawberry ğŸ“</p>
  </>
</List>
```

Zamiast trzech `<li>` zostanÄ… wyrenderowane dwa. Jak temu zaradziÄ‡? PowstaÅ‚a [biblioteka](https://github.com/grrowl/react-keyed-flatten-children) specjalnie pod ten problem, ktÃ³ra udostÄ™pnia funkcje `flattenChildren`. Zobaczmy na caÅ‚y, poprawiony przykÅ‚ad:

```tsx
import { Children, ReactElement, isValidElement, cloneElement } from 'react';
import flattenChildren from 'react-keyed-flatten-children';

type ListProps = {
  children: Array<ReactElement>;
};

const List = ({ children }: ListProps) => {
  const newChildren = flattenChildren(children).map((child) => {
    if (isValidElement(child)) {
      if (child.type === 'li') {
        return cloneElement(child);
      }
      return <li key={child.key}>{child}</li>;
    }
  });

  return <ul>{newChildren}</ul>;
};

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    <>
      <a href="banana.html">Banana ğŸŒ</a>
      <p>Strawberry ğŸ“</p>
    </>
    <span>Blueberry ğŸ«</span>
  </List>
);
```

### Komponenty jako dzieci

PrzyszÅ‚a pora na to, co nas najbardziej interesuje, czyli faktyczny komponent jako dziecko `List`. Tym razem zamiast sprawdzaÄ‡, czy `child.type` jest rÃ³wny typowi `li`, sprawdzamy, czy jest on taki sam jak komponent.

A co z propsami? Nasz komponent bÄ™dzieÂ przyjmowaÅ‚ wszystkie atrybuty `li` + `ref` (typ `JSX.IntrinsicElements['li']`), a jego dzieci bÄ™dÄ… miaÅ‚y typ `ReactText`:

```tsx
import { ReactElement, isValidElement, ReactText } from 'react';
import flattenChildren from 'react-keyed-flatten-children';

type ListItemProps = {
  children: ReactText;
} & JSX.IntrinsicElements['li'];

const ListItem = (props: ListItemProps) => {
  return <li {...props}></li>;
};

type ListProps = {
  children: Array<ReactElement>;
};

export const List = ({ children }: ListProps) => {
  const newChildren = flattenChildren(children).map((child) => {
    if (isValidElement(child)) {
      if (child.type === ListItem) {
        return <ListItem key={child.key} {...(child.props as ListItemProps)} />;
      } else {
        throw new Error('Tylko ListItem moÅ¼e byÄ‡ dzieckiem List');
      }
    }
  });

  return <ul>{newChildren}</ul>;
};
```

To co tutaj jest nowe, to wyjÄ…tek, rzucamy go, gdy typ **nie jest** zgodny z `ListItem` - w ten sposÃ³b obchodzimy ograniczenia typowania.

```tsx
const App = () => (
  <List>
    <ListItem>Apple ğŸ</ListItem>
    <>
      <ListItem>Banana ğŸŒ</ListItem>
      <ListItem>Strawberry ğŸ“</ListItem>
    </>
    <span>Blueberry ğŸ«</span> // âŒ Error: Tylko ListItem moÅ¼e byÄ‡ dzieckiem List
  </List>
);
```

### Prywatne children

Ostatni z naszych _case'Ã³w_ - naszymi dzieÄ‡mi bÄ™dÄ… komponenty + nie bÄ™dziemy mogli ich uÅ¼yÄ‡ poza komponentem rodzica. Zaciekawieni? Jedziemy!

Zanim przejdziemy do typÃ³w, stwÃ³rzymy dwa komponenty - `ListItem` i `PrivateListItem`. Nie przeraÅº siÄ™Â tym pierwszym, rzuca on wyjÄ…tkiem z konkretnego powodu, zaraz do tego wrÃ³cimy! `PrivateListItem` za to, tak jak poprzednio, jest po prostu normalnym komponentem, ktÃ³ry zwraca `li` razem z propsami:

```tsx
type ListItemProps = {
  children: ReactText;
} & JSX.IntrinsicElements['li'];

const ListItem = (_props: ListItemProps) => {
  throw new Error('ListItem musi byÄ‡ dzieckiem List');
};

const PrivateListItem = (props: ListItemProps) => {
  return <li {...props}></li>;
};
```

PozostaÅ‚o nam tylko, tak jak poprzednio, w odpowiedni sposÃ³b spÅ‚aszczyÄ‡ iÂ przeiterowaÄ‡ przez nasze `children` w komponencie `<List>`, z maÅ‚Ä… rÃ³Å¼nicÄ…...Tym razem sprawdzamy czy dziecko jest typu `ListItem`, jeÅ›li tak, to zwracamy `PrivateListItem`:

```tsx
import { ReactElement, isValidElement, ReactText } from 'react';
import flattenChildren from 'react-keyed-flatten-children';

type ListItemProps = {
  children: ReactText;
} & JSX.IntrinsicElements['li'];

export const ListItem = (_props: ListItemProps) => {
  throw new Error('ListItem musi byÄ‡ dzieckiem List');
};

const PrivateListItem = (props: ListItemProps) => {
  return <li {...props}></li>;
};

type ListProps = {
  children: Array<ReactElement>;
};

export const List = ({ children }: ListProps) => {
  const newChildren = flattenChildren(children).map((child) => {
    if (isValidElement(child)) {
      if (child.type === ListItem) {
        return <PrivateListItem key={child.key} {...(child.props as ListItemProps)} />;
      } else {
        throw new Error('Tylko ListItem moÅ¼e byÄ‡ dzieckiem List');
      }
    }
  });

  return <ul>{newChildren}</ul>;
};
```

Ten kod na pierwszy rzut oka wydaje siÄ™Â maÅ‚o intuicyjny, ale zobaczmy jak wyglÄ…da wywoÅ‚anie:

```tsx
const App = () => (
  <>
    <List>
      <ListItem>Apple ğŸ</ListItem>
      <>
        <ListItem>Banana ğŸŒ</ListItem>
        <ListItem>Strawberry ğŸ“</ListItem>
      </>
    </List>
    <ListItem>Blueberry ğŸ«</ListItem> // âŒ Error: ListItem musi byÄ‡ dzieckiem List
  </>
);
```

Co prawda do komponentu `List` moÅ¼emy przekazaÄ‡ wszystko co jest zgodne z typem `Array<ReactElement>`, ale zostanÄ…Â wyrenderowane **tylko** komponenty `PrivateListItem`! Hmm...wiÄ™c po co ta sztuczka z `ListItem`? ğŸ¤” DziÄ™ki niej nie moÅ¼emy wywoÅ‚aÄ‡Â `ListItem` nigdzie indziej niÅ¼ w komponencie `List` i to sÄ… wÅ‚aÅ›nie te "prywatne children"!

#### Problemy z kompozycjÄ…

PodwyÅ¼sze rozwiÄ…zania majÄ… jeden powaÅ¼ny problem - brak moÅ¼liwoÅ›ci opakowania komponentu `<ListItem>` w inny komponent. MoÅ¼emy go niejako rozwiÄ…zaÄ‡ deklarujÄ…c komponent rodzica:

```tsx
type ListItemProps = {
  children: ReactText;
} & JSX.IntrinsicElements['li'];

type ChildWithParent = ReactElement & {
  type: { parent: ReactElement };
  props: ListItemProps;
};

const ListItem = (_props: ListItemProps) => {
  throw new Error('ListItem musi byÄ‡ dzieckiem List');
};

ListItem.parent = List;

export const List = ({ children }: ListProps) => {
  const newChildren = flattenChildren(children).map((child: unknown) => {
    const child = child as ChildWithParent;
    if (isValidElement(child)) {
      if (child.type === ListItem && child.type.parent === List) {
        return <PrivateListItem key={child.key} {...(child.props as ListItemProps)} />;
      } else {
        throw new Error('Tylko ListItem moÅ¼e byÄ‡ dzieckiem List');
      }
    }
  });

  return <ul>{newChildren}</ul>;
};

const ListItemWrapper = (props: ListItemProps) => <ListItem {...props} />;

ListItemWrapper.parent = List;
```

Przy takim zaÅ‚oÅ¼eniu, kaÅ¼dy _wrapper_ na komponent `<ListItem>`, taki jak np. `<ListItemWrapper>` bÄ™dzie musiaÅ‚ posiadaÄ‡Â sztywno zadeklarowanego rodzica - `ListItemWrapper.parent = List`.

## Podsumowanie

Uff, to by byÅ‚o na tyle jeÅ›li chodzi o `children` w React & TypeScript. Dzisiejszy wpis potraktuj jako taki pakiet wiedzy o typach dla `children` oraz zbiÃ³r ciekawostek. WiÄ™kszoÅ›Ä‡Â reaktowych codebasÃ³w (i komponentÃ³w) nie bÄ™dzie potrzebowaÅ‚a tego typu restrykcji. Polecam Ci szczegÃ³lnie zapoznaÄ‡ siÄ™ z innymi metodami dla `React.Children`, chociaÅ¼ ich rÃ³wnieÅ¼ nie stosuje siÄ™ na co dzieÅ„, to jak widaÄ‡, potrafiÄ…Â siÄ™ przydaÄ‡ :)

JeÅ›li ten artykuÅ‚ okazaÅ‚ siÄ™ dla Ciebie przydatny, podziel siÄ™Â nim z innymi!

Do usÅ‚yszenia!

### Å¹rÃ³dÅ‚a

- [Fake Child Pattern](https://twitter.com/markdalgleish/status/1370951759284162565)
- [React TS Cheatsheet](https://github.com/typescript-cheatsheets/react)
- [ReactNode Date object issue](https://github.com/DefinitelyTyped/DefinitelyTyped/issues/37596)
- [ReactNode object issue](https://github.com/typescript-cheatsheets/react/issues/357)
