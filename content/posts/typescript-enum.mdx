---
title: 'TypeScript - nie potrzebujesz enumÃ³w'
category: 'TypeScript'
publishedAt: '23-05-2022'
isPublished: true
popular: false
image: '/images/typescript-enum/thumbnail.png'
excerpt: 'Korzystasz z enumÃ³w w TypeScript? Enumy mogÄ… spowodowaÄ‡ wiÄ™cej kÅ‚opotÃ³w niÅ¼ uÅ¼ytku... Dlaczego sÄ… takieg zÅ‚e i jakie sÄ… alternatywy?'
---

Korzystasz z enumÃ³w w TypeScript? Enumy mogÄ… spowodowaÄ‡ wiÄ™cej kÅ‚opotÃ³w niÅ¼ uÅ¼ytku... Dlaczego sÄ… takieg zÅ‚e i jakie sÄ… alternatywy?

## Typy, a moÅ¼e jednak wartoÅ›ci?

Enumy Å‚amiÄ…Â podstawowe zaÅ‚oÅ¼enie typÃ³w w TypeScripcie - nie znikajÄ…Â po kompilacji!

```ts
enum Role {
  Admin,
  User,
  Guest,
}
```

Za przykÅ‚ad weÅºmy numerycznego enuma `Role`, po skompilowaniu ten enum zamieni siÄ™Â w takiego potworka:

```js
var Role;
(function (Role) {
  Role[(Role['Admin'] = 0)] = 'Admin';
  Role[(Role['User'] = 1)] = 'User';
  Role[(Role['Guest'] = 2)] = 'Guest';
})(Role || (Role = {}));
```

Wynika to z faktu, Å¼e enumÃ³w moÅ¼emu uÅ¼ywaÄ‡ zarÃ³wno jako typÃ³w, jak i wartoÅ›ci. PoniÅ¼szy kod jest w 100% poprawny:

```ts
const userRole = Role.Admin;

type UserRole = Role.Admin;
```

Czy to dobrze, czy to Åºle? ZaleÅ¼y jak na to spojrzeÄ‡Â :) Ze strony samego jÄ™zyka jest to dziwne posuniÄ™cie, odbiegajÄ…ce od tego jak dziaÅ‚ajÄ… `type`, czy `interface`. Z perspektywy programisty moÅ¼e byÄ‡ to faktycznie miejscami wygodne, jednak korzystajÄ…c z enumÃ³w miejmy na uwadze, Å¼e tworzymy nadmiarowy kod.

## NiebezpieczeÅ„stwo numerycznych enumÃ³w

Enumy dzielÄ… siÄ™ na dwa rodzaje - enumy numeryczne i te z ciÄ…gami znakÃ³w. Te pierwsze sÄ…Â kompletnÄ… pomyÅ‚kÄ… i powodujÄ… niebezpieczeÅ„stwo w typowaniu!

Numeryczne enumy majÄ… to do siebie, Å¼e domyÅ›lnie indeksowane sÄ… tak jak obiekty, od zera - widzimy to w skompilowanym przykÅ‚adzie powyÅ¼ej. MoÅ¼emy jednak zmieniÄ‡ to zachowanie napisujÄ…c indeks dla konkretnego typu.

```ts
enum Role {
  Admin = 5,
  User = 14,
  Guest,
}
```

JeÅ›li adminowi nadamy indeks `5`, a zwykÅ‚emu uÅ¼ytkownikowi `14`, to TypeScript patrzÄ…c na trzeci element w enumie, sprÃ³buje nadaÄ‡ mu o jeden wiÄ™kszy indeks niÅ¼ poprzednio nadpisany. Kod po skompilowaniu:

```ts
var Role;
(function (Role) {
  Role[(Role['Admin'] = 5)] = 'Admin';
  Role[(Role['User'] = 14)] = 'User';
  Role[(Role['Guest'] = 15)] = 'Guest';
})(Role || (Role = {}));
```

SprÃ³bujmy wykorzystaÄ‡ tego enuma w praktyce. Tworzymy funkcjÄ™Â `getUserRole`, ktÃ³ra przyjmuje rolÄ™Â o wczeÅ›niej stworzonym typie `Role`:

```ts
declare function getUserRole(role: Role): void;

getUserRole(Role.Admin); // âœ…
getUserRole(5); // âœ…  ğŸ¤”
getUserRole(200); // âœ…  ğŸ¤”
```

OczekiwalibyÅ›my, Å¼e funkcja przyjmie tylko wczeÅ›niej zdefiniowanego enuma, jednak tak siÄ™ nie dzieje... MoÅ¼emy podaÄ‡Â w niej rÃ³wnieÅ¼ **jakÄ…kolwiek** liczbÄ™ ğŸ¤¯

## Enumy z ciÄ…gami znakÃ³w

PrzejdÅºmy do opcji nr. 2 - _string enum_. To z niego najczÄ™Å›ciej korzystamy w TypeScripcie:

```ts
enum Role {
  Admin = 'admin',
  User = 'user',
  Guest = 'guest',
}
```

Tutaj do danego pola w enumie przypisujemy odpowiadajÄ…cego mu stringa. SprawdÅºmy jak wyglÄ…da wykorzystanie w funkcjach:

```ts
declare function getUserRole(role: Role): void;

getUserRole(Role.Admin); // âœ…
getUserRole(5); // âŒ
getUserRole(200); // âŒ

getUserRole('admin'); // âŒ ğŸ¤¯
```

Super, `Role.Admin` dziaÅ‚a, nie mamy moÅ¼liwoÅ›ci przekazania dowolnej liczby, wszystko jest jak naleÅ¼y. Z jednym maÅ‚ym szczegÃ³Å‚em. Nie moÅ¼emy rÃ³wnieÅ¼ przekazaÄ‡ stringa, ktÃ³ry odpowiada temu, zdefiniowanemu w enumie. Z doÅ›wiadczenia wiem, Å¼e coÅ›Â takiego jest mega wkurzajÄ…ce, bo za kaÅ¼dym razem musimy skorzystaÄ‡ zÂ zdeklarowanego enuma.

<Newsletter />

## Typowanie nominalne

To, co jednoczeÅ›nie jest wkurzajÄ…ce, ma rÃ³wnieÅ¼ swoje zalety. Enumy sÄ… bowiem typowane nominalnie.

```ts
enum Role {
  Admin = 'admin',
  User = 'user',
  Guest = 'guest',
}

enum Role2 {
  Admin = 'admin',
  User = 'user',
  Guest = 'guest',
}

const admin: Role = Role.Admin; // âœ…

const admin2: Role2 = Role.Admin; // âŒ
```

Jednego enuma, nie moÅ¼emy przypisaÄ‡Â do drugiego, nawet jeÅ›li oba sÄ… identyczne, fajna sprawa :)

## const enum

TwÃ³rcy TypeScripta prÃ³bujÄ… obaliÄ‡ jeden z moich argumentÃ³w przeciw wykorzystaniu enumÃ³w i w swojej kolekcji typÃ³w posiadajÄ…Â rÃ³wnieÅ¼ takiego potworka jak `const enum`.

```ts
const enum Role1 {
  Admin,
  User,
  Guest,
}

const users1 = [Role1.Admin, Role1.User, Role1.Guest];

/*
Po kompilacji:

const users1 = [0, 1, 2];
*/

const enum Role2 {
  Admin = 'admin',
  User = 'user',
  Guest = 'guest',
}

const users2 = [Role2.Admin, Role2.User, Role2.Guest];

/*
Po kompilacji:

const users = ['admin', 'user', 'guest'];
*/
```

DziÄ™ki niemu enumy nie zostajÄ… w kodzie po kompilacji, a miejsca w ktÃ³rych byÅ‚y uÅ¼yte zmieniajÄ… siÄ™Â w zaleÅ¼noÅ›ci od typu enuma. Dla enumÃ³w numerycznych otrzymujemy indeksy, a dla ciÄ…gÃ³w znakÃ³w odpowiadajÄ…ce im wartoÅ›ci.

Ten sposÃ³b typowania ma jednak jednÄ…Â duÅ¼Ä… wadÄ™Â - [nie zadziaÅ‚a w przypadku poÅ‚Ä…czenia Babela z TypeScriptem](https://github.com/microsoft/TypeScript/issues/37179).

## Alternatywy

Tyle zabawy, tyle tradeoffÃ³w, po co to wszystko skoro mamy prostsze rozwiÄ…zanie?

Wystarczy skorzystaÄ‡ z unii!

```ts
type Role = 'admin' | 'user' | 'guest';

declare function getUserRole(role: Role): void;

getUserRole('admin'); // âœ…

getUserRole(5); // âŒ
getUserRole(200); // âŒ
```

Nasz typ w koÅ„cu jest bezpieczny, nie musimy niczego importowaÄ‡, to **po prostu dziaÅ‚a!**

A jeÅ›li chcielibyÅ›my mÃ³c korzystaÄ‡ z typÃ³w i wartoÅ›ci, tak jak w enumie, to moÅ¼emy uÅ¼yÄ‡ zwykÅ‚ego obiektu:

```ts
const Role = {
  Admin: 'admin',
  User: 'user',
  Guest: 'guest',
} as const;

type Values<Object> = Object[keyof Object];

declare function getUserRole(role: Values<typeof Role>): void;

getUserRole('admin'); // âœ…
getUserRole(Role.Admin); // âœ…
```

## Podsumowanie

Enum to dziwne stworzenie w TypeScripcie. PeÅ‚ne zÅ‚ych decyzji projektowych i tredeoffÃ³w. W wiÄ™kszoÅ›ci zastosowaÅ„ enuma moÅ¼emy go zastÄ…piÄ‡ zwykÅ‚ymi uniami typÃ³w oraz, gdy chcemy skorzystaÄ‡ rÃ³wnieÅ¼ z wartoÅ›ci, zwykÅ‚ych obiektÃ³w.
