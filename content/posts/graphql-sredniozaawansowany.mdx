---
title: 'GraphQL - zapytania, mutacje i schema'
category: 'GraphQL'
publishedAt: '31-07-2020'
isPublished: true
popular: false
excerpt: 'Kontynuujemy przygod ze wiatem GraphQLa i zabieramy si za realne zagadnienia コ Dzi poznasz zapytania, mutacje, scheme, typy i wiele wicej, a w nastpnym wpisie, ze zdobyt dzi wiedz podbijamy Reakta!'
---

Kontynuujemy przygod ze wiatem **GraphQLa** i zabieramy si za **realne zagadnienia** コ Dzi poznasz _zapytania_, _mutacje_, _scheme_, _typy_ i wiele wicej, a za tydzie, ze zdobyt dzi wiedz **podbijamy Reakta**!

Poni偶ej, jak zawsze, may _spis treci_ 

## Spis treci

- [Zapytania](#zapytania)
  - [Argumenty](#argumenty)
  - [Aliasy](#aliasy)
  - [Imienne query](#imienne-query)
  - [Zmienne](#zmienne)
  - [Fragmenty](#fragmenty)
    - [Inlinowe fragmenty](#inlinowe-fragmenty)
  - [Meta fields](#meta-fields)
  - [Dyrektywy](#dyrektywy)
- [Mutacje](#mutacje)
- [Schema i typy](#schema-i-typy)
  - [Typy skalarne](#typy-skalarne)
  - [Object types](#object-types)
  - [Typy zapyta i mutacji](#typy-zapytan-i-mutacji)
  - [Enumy](#enumy)
  - [Interfejsy](#interfejsy)
  - [Union types](#union-types)
  - [Input types](#input-types)
- [Podsumowanie](#podsumowanie)
  - [殴r贸da](#zr贸da)

<br />

Zanim zaczniemy, bdziemy dzi korzysta z [The Rick and Morty API](https://rickandmortyapi.com/) o kt贸rym wspominaem w [poprzednim wpisie](https://www.frontlive.pl/graphql-podstawy/) oraz ze [SWAPI](https://swapi.graph.cool/), kt贸re udostpnia tam Star Warsowe API.

## Zapytania

Jeli jeszcze nie syszae o **zapytaniach** (en. _query_) zajrzyj do [poprzedniego wpisu](https://www.frontlive.pl/graphql-podstawy/). Sp贸jrzmy na podstawowe zapytanie:

```graphql
{
  characters {
    results {
      name
      id
      status
      origin {
        name
      }
    }
  }
}
```

Wycigamy tutaj poszczeg贸lne **pola** i zostajnam one zwr贸cone w formie JSONa.

```json
{
  "data": {
    "characters": {
      "results": [
        {
          "name": "Rick Sanchez",
          "id": "1",
          "status": "Alive",
          "origin": {
            "name": "Earth (C-137)"
          }
        }
        // ...
      ]
    }
  }
}
```

Dostajemy w odpowiedzi **wszystkie** postacie, kt贸re posiadaj imi, id czy pochodzenie.

### Argumenty

Tak jak wspomniaem wycigamy **wszystkie** postacie, za贸偶my, 偶e chcielibymy pobra dane tylko o konkretnej postaci, w tym przypadku o **Ricku Sanchezie**. Do tego idealnie sprawdzaj si argumenty:

```graphql
{
  character(id: 1) {
    name
  }
}
```

W odpowiedzi dostaniemy:

```json
{
  "data": {
    "character": {
      "name": "Rick Sanchez"
    }
  }
}
```

Argumenty mog by **r贸偶nych typ贸w**, mog by te偶 r贸偶ne, mo偶e by to np. _name_ czy _unit_ ale to wszystko zale偶y od Twojego API. W takim razie **jak sprawdzi** czy mo偶emy poda jakiargument do zapytania?

Wystarczy klikn w `DOCS` po prawej stronie, nastpnie wybieramy odpowiednie zapytanie i otrzymujemy informacje o **argumentach** i ich **typach**.

![Argumenty w GraphQL](/images/articlesImages/alias-gql.png)

## Aliasy

Skorzystajmy teraz z [SWAPI](https://swapi.graph.cool/), mo偶emy tutaj zapyta dan **planet**, podajemy do _query_ argument _name_, dziki temu mo偶emy zapyta o **tytu filmu**, w kt贸rym dana planeta sipojawia.

Problem pojawia si gdy chcemy pobra dwie **r贸偶nice siplanety**, wtedy pojawiaj si **aliasy**. Nadajemy im nazwy i po dwukropku wykonujemy zapytanie:

```graphql
{
  filmsWithHoth: Planet(name: "Hoth") {
    films {
      title
    }
  }
  filmsWithTatooine: Planet(name: "Tatooine") {
    films {
      title
    }
  }
}
```

W odpowiedzi dostajemy nastpujce dane:

```json
{
  "data": {
    "filmsWithHoth": {
      "films": [
        {
          "title": "A New Hope"
        }
        // ...
      ]
    },
    "filmsWithTatooine": {
      "films": [
        {
          "title": "The Phantom Menace"
        }
        // ...
      ]
    }
  }
}
```

### Imienne query

Wczeniej tworzylimy _anonimowe_ zapytania, ale **w praktyce** i w realnej aplikacji, u偶ywamy **nazw** dla zapyta i mutacji:

```graphql
query CharacterName {
  character(id: 1) {
    name
  }
}
```

S one niezbdne przy korzystaniu ze zmiennych 

### Zmienne

Do tej pory wszystkie wartoci podawalimy jako stringi / numbery, byy to **wartoci statyczne**. Najczciej jednak bdziemy chcieli **dynamicznie** zacign dane na podstawie jakie **zmiennej**.

```graphql
query StarshipClass($name: String) {
  Starship(name: $name) {
    class
  }
}
```

Podobnie jak argumenty, zmienne podajemy **w nawiasach** przy nazwie naszej operacji poprzedzajc j `$`. Nastpnie mo偶emy wykorzysta t zmienn gdzie tylko chcemy. Przy nazwie zmiennej mo偶esz jeszcze zauwa偶y `String`, jest to typ zmiennej w **schema definition language**.

Ta zmienna jest opcjonalna, jeli dodamy na kocu typu `!` stanie si ona wymagana. Do zmiennych mo偶emy r贸wnie偶 przypisywa **defaultowe** wartoci:

```graphql
query StarshipClass($name: String = "Death Star") {
  Starship(name: $name) {
    class
  }
}
```

### Fragmenty

Stw贸rzmy nowe query, jednoczenie praktykujc wykorzystanie alias贸w:

```graphql
query MainCharacters {
  rick: character(id: 1) {
    name
    id
    status
    origin {
      name
      dimension
    }
  }

  morty: character(id: 2) {
    name
    id
    status
    origin {
      name
      dimension
    }
  }
}
```

Widzicie pewn zale偶no? **Powtarzajce si pola**, takich powt贸rze mo偶e by przecie偶 znacznie wicej... Takim sposobem tworzymy brzydki, powtarzalny kod, a tego **nie chcemy**.

Fragmenty na ratunek! З

```graphql
fragment characterFields on Character {
  name
  id
  status
  origin {
    name
    dimension
  }
}
```

Zacznijmy od pocztku fragment jest **reu偶ywalnym** kawakiem kodu, definiujemy go nazwi poprzedzamy sowem `fragment`. Po `on` podajemy **typ**, w tym przypadku jest to `Character`. A co w rodku? Pola, kt贸re chcemy ponownie wykorzysta!

```graphql
query MainCharacters {
  rick: character(id: 1) {
    ...characterFields
  }

  morty: character(id: 2) {
    ...characterFields
  }
}
```

Wyglda to o wiele schludniej. Najlepsze jest to, 偶e we fragmentach mo偶emy r贸wnie偶 korzysta ze **zmiennych**! Daje nam to na prawd du偶 **elastyczno**.

#### Inlinowe fragmenty

Fragmenty maj jeszcze jedno **wietne** zastosowanie. Abstrahujc ju偶 od naszego API, za贸偶my, 偶e posiadamy pole **character**, kt贸re mo偶e by typu `Rick` lub `Morty`. Dla ka偶dego typu mamy inne _pola specjalne_. I w zale偶noci od zmiennej chcemy te pola pobra.

```graphql
query MainCharacter($character: Character) {
  character(character: $character) {
    name
    id
    ... on Rick {
      iq
    }
    ... on Morty {
      tshirtColor
    }
  }
}
```

Niezale偶nie od typu postaci pobieramy imi i `id`, jeli nasz postaci bdzie `Rick` pobieramy dodatkowo `iq`, natomiast, jeli bdzie to `Morty` pobieramy `tshirtColor`.

### Meta fields

Rozbudujmy nasz poprzedni przykad i dodajmy nowe postaci `Summer` i `Jerrego`. Tym razem nie bdziemy wybiera konkretnych p贸l w zale偶noci od typu, ale pobierzemy id danej postaci gdy to bdzie posiadao w sobie `er`.

```graphql
query searchCharacters {
  search(include: "er") {
    ... on Summer {
      id
    }
    ... on Rick {
      id
    }
    ... on Jerry {
      id
    }
    ... on Morty {
      id
    }
  }
}
```

W odpowiedzi dostaniemy nastpujce dane:

```json
{
  "data": {
    "search": [
      {
        "id": "2"
      },
      {
        "id": "3"
      }
    ]
  }
}
```

Tutaj pojawia si **problem**, skd mamy wiedzie jakie `id` przynale偶y do danej postaci? Z pomoc przychodz _meta fields_ i `__typename`.

```graphql
query searchCharacters {
  search(include: "er") {
    __typename
    ... on Summer {
      id
    }
    ... on Rick {
      id
    }
    ... on Jerry {
      id
    }
    ... on Morty {
      id
    }
  }
}
```

Gdy dodamy pole `__typename` na pocztku naszego zapytania, w odpowiedzi dostaniemy nazw z danego typu.

```json
{
  "data": {
    "search": [
      {
        "__typename": "Summer",
        "id": "2"
      },
      {
        "__typename": "Jerry",
        "id": "3"
      }
    ]
  }
}
```

### Dyrektywy

Dodawalimy zmienne, 偶eby mie wiksz kontrol nad naszym zapytaniem. Krokiem dalej jest zaimplementowanie **dyrektyw**, kt贸re pozwalaj nam **dynamicznie** zmienia zapytanie.

Dyrektyw dodajemy ze znakiem `@`, w _podstawowym_ GraphQLu mamy dwie dyrektywy:

- `@include(if: Boolean)`
- `@skip(if: Boolean)`

Ta pierwsza akceptuje pola gdy warto if jest `true`, `@skip` omija dane pola gdy warto jest `true`.

```graphql
query RickFields($desktop: Boolean!) {
  rick: character(id: 1) {
    name
    id
    status
    origin @include(if: $desktop) {
      name
      dimension
    }
  }
}
```

Mamy tutaj zapytanie `RickFields` i zmienn `$desktop`, **na podstawie tej zmiennej** bdziemy zaciga pochodzenie Ricka. Je偶eli `$desktop` bdzie `false` pochodzenie postaci nie zostanie pobrane.

## Mutacje

Dotychczas rozmawialimy tylko o pobieraniu danych, ale przecie偶 chcemy je te偶 **modyfikowa**!

Mutacjtworzymy bardzo **podobnie** jak zapytania, tak偶e nie ma siczego ba, zamiast s贸wka `query` podajemy `mutation`.

```graphql
mutation CreateCharacterForEpisode($ep: Episode!, $character: Character!) {
  createCharacter(episode: $ep, character: $character) {
    name
    id
  }
}
```

Podajemy tutaj zmienne i wykorzystujemy je przy argumentach, `character` nie jest tzw. typem skalarnym, a czym w rodzaju obiektu, ten _obiekt_ nosi nazw _input object type_, ale o tym za chwilk.

Tak wygldaj nasze **zmienne**:

```
{
  "ep": "Auto Erotic Assimilation",
  "character": {
    "name": "Pickle Rick",
    "id": 55
  }
}
```

A te **dane** zostan zmienione na serwerze:

```graphql
{
  "data": {
    "createCharacter": {
     "name": "Pickle Rick",
     "id": 55
    }
  }
}
```

Mutacji mo偶emy _na raz_ wysya **wiele**, dziaa to podobnie jak z **zapytaniami**, z jednym wyjtkiem, mutacje musz _poczeka_ na siebie, 偶eby zapobiec tzw. _race conditions_.

## Schema i typy

Jeli mielicie ju偶 do czynienia z jakim silnie typowanym jzykiem np. **TypeScriptem**, to bdzie czuli si **jak w domu**, no prawie. Jeli nie, nie martw siprzejdziemy przez wszystkie zagadnienia.

Scheme w GraphQLu kojarzymy bardziej z backendem ni偶z frontendem, jednak nauczenie si jej **mo偶e Ci si przyda**, zaufaj mi. W nastpnym wpisie bdziemy definiowa scheme **po stronie klienta**.

Wic czym jest ta magiczna schema i jak korzysta z typ贸w w GraphQLu?

Z typ贸w ju偶 korzystalimy, piszc zapytanie korzystajce ze zmiennej:

```graphql
query StarshipClass($name: String) {
  Starship(name: $name) {
    class
  }
}
```

### Typy skalarne

Zacznijmy od podstawowych typ贸w, czyli typ贸w skalarnych. W pakiecie od GraphQLa dostajemy:

- `String` - cig znak贸w np. **'Rick'**
- `Int` - liczba cakowita, np. **6**
- `Float` - liczba zmiennoprzecinkowa, np. **Math.random()**
- `Boolean` - **true/false**
- `ID` - jest to specjalny, unikalny typ, bardzo wa偶ny przy **cachowaniu** danych

### Object types

_Object types_ to typy zo偶one z typ贸w skalarnych.

```graphql
type Character {
  name: String!
  status: String
  episode: [Episode]
  origin: Location
  height(unit: Unit): Float
}
```

Typ definiujemy przy u偶yciu `type`, jednoczenie podajc jego **nazw**, w tym przypadku jest to `Character`. Jeli chodzi o `!` na kocu danego typu, dajemy zna GraphQLowi, 偶e ten tym **nie mo偶e by** `nullem`. Konstrukcja `[Episode]` opisuje **tablic** obiekt贸w o typie `Episode`.

Pamitacie **argumenty**? Trzeba je jako otypowa, tak samo jak w zapytaniach, w nawiasach podajemy **warto** i przypisujemy do niej typ, po dwukropku definiujemy jakiego typu ma by **zwracana warto**.

### Typy zapyta i mutacji

Opr贸cz standardowych _object types_ i _typ贸w skalaranych_ mamy r贸wnie偶 do wykorzystania dwa bardzo wa偶ne typy `Query` i `Mutation`. Definiuj one tzw. _entry point_ naszych zapyta. Wygldaj one dokadnie tak jak _object types_:

```graphql
type Query {
  character(id: ID): Character
}

type Mutation {
  createCharacter(name: String!): Character
}
```

### Enumy

**Enumy** w GraphQLu s specjalnymi **typami skalarnymi**, gdzie nasz typ jest **ograniczony** do konkretnych warto.

```ts
enum Planet {
  Hoth
  Dagobah
  Tatooine
}

type Episode {
    planets: Planet
}
```

Je偶eli podamy, w naszej schemie typ `Planet`, GraphQL bdzie spodziewa si `Hoth`, `Dagobah` lub `Tatooine`.

### Interfejsy

Pamitacie [Inlinowe fragmenty](#inlinowe-fragmenty)? Implementowalimy tam `Ricka` i `Mortiego`, ka偶dy z nich mia specjalne pola, jednak oboje mieli kilka wsp贸lnych. Mo偶emy stworzy, dla tych **wsp贸lnych p贸l**, interfejs, kt贸ry potem zaimplementujemy w danym typie.

Zaimplementowanie interfejsu w typie, m贸wi nam, 偶e ka偶dy typ, kt贸ry implementuje dany interfejs **musi opisywa dane pola**.

```graphql
interface Character {
  name: String!
  id: ID!
}

type Rick implements Character {
  name: String!
  id: ID!
  iq: Int
}

type Morty implements Character {
  name: String!
  id: ID!
  tshirtColor: String
}
```

### Union types

Unie oznaczaj typ _jeden z_. Mo偶emy np. utworzy typ, kt贸ry bdzie typu `Location` lub `Planet`.

```graphql
type Location {
  name: String
}

type Planet {
  name: String
}

union WhereAreYou = Location | Planet
```

### Input types

Przy tworzeniu **mutacji** podawalimy typ `$character`:

```graphql
mutation CreateCharacterForEpisode($ep: Episode!, $character: Character!) {
  createCharacter(episode: $ep, character: $character) {
    name
    id
  }
}
```

Wspominaem, 偶e do tego wr贸cimy, wic dotrzymujsowa 

Ten typ ma **tak sam**konstrukcj jak _object types_, z dwiema r贸偶nicami. Zamiast `type` podajemy `input` i nie musimy podawa typ贸w do poszczeg贸lnych p贸l, zamiast tego wrzucamy `input type object`, a GraphQL zajmie sireszt.

```graphql
input Character {
  name: String
  id: ID!
}
```

## Podsumowanie

To wszystko na dzi, dziki za obecno!

Zachcam Cido pobawienia siGraphQLem w [SWAPI](https://swapi.graph.cool/) i [The Rick and Morty API](https://rickandmortyapi.com/).

Do usyszenia!

### 殴r贸da

- [GraphQL Docs](https://graphql.org/)
- [The Rick and Morty API](https://rickandmortyapi.com/)
- [SWAPI](https://swapi.graph.cool/)
