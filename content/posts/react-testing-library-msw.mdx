---
title: 'React Testing Library - Mock Service Worker'
category: 'Testowanie'
publishedAt: '28-06-2021'
isPublished: true
popular: false
image: '/images/react-testing-library-msw/rtl-msw.png'
excerpt: 'MSW to narzdzie nowej geneneracji, kt贸re umo偶liwia atwiejsz i przyjemniejsz prac z mockami...'
---

Pogadajmy przez chwil o mockowaniu, a szczeg贸lnie o mockowaniu fetcha/axiosa przy testowaniu komponent贸w, kt贸re pobieraj nasze dane np. z zewntrznego API. Oto klasyczny przykad:

```ts
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('getAllPlayers', () => {
  it('returns list of players', async () => {
    mockedAxios.get.mockResolvedValue(allPlayers);

    const players = await match.getAllPlayers();

    expect(mockedAxios.get).toBeCalledTimes(1);
    expect(players).toEqual(allPlayers);
  });
});
```

Czy tutaj jest **藕le**? Absolutnie nie. Czy da sito zrobi lepiej? Jeszcze jak 

## Mock Service Worker

O co wic chodzi z tym caym MSW? Biblioteka pozwala nam w **atwiejszy i bardziej przejrzysty** spos贸b pracowaz mockami. Potrzebujemy ustawi odpowiednie nag贸wki, czy doda op贸藕nienie dla zapytania, nie ma problemu!

```ts
rest.get('/url', (req, res, ctx) => {
  return res(ctx.status(301), ctx.set('Content-Type', 'application/json'), ctx.delay(2000));
});
```

Co wicej, MSW mo偶emy wykorzystywa r贸wnie偶 poza samymi testami. Za贸偶my, 偶e nasz backend nie zosta jeszcze w peni przygotowany, a nam sispieszy i chcemy mie dostp do danych. Dziki MSW mo偶emy _zasymulowa_ prawdziwy serwer i kontynuowa pracnad frontem.

Ale jak nie o tym, wr贸my do test贸w i sprawd藕my, jak to narzdzie dziaa w praktyce.

## MSW w praktyce

Stw贸rzmy komponent, kt贸ry bdzie wywietla post u偶ytkownika w naszej aplikacji:

```tsx
import { useGetPost } from '../../utils/hooks/useGetPost';

type PostProps = {
  readonly id: number;
};

export const Post = ({ id }: PostProps) => {
  const { isLoading, isSuccess, isError, data, error } = useGetPost(id);
  return (
    <>
      {isLoading ? <p>Loading...</p> : null}
      {isError ? <p>Something went wrong</p> : null}
      {isSuccess ? <p>Success</p> : null}
      <h2>{data?.title}</h2>
      <p>{data?.body}</p>
    </>
  );
};
```

Pod przykrywk`useGetPost()` kryje si [React Query](https://react-query.tanstack.com/), ale implementacja nie ma tu wikszego znaczenia.

W pliku z testem komponentu, w pierwszej kolejnoci, ustawiamy nasz serwer, to tutaj dzieje sicaa magia. Do funkcji `setupServer` przekazujemy tzw. handler, w kt贸rym deklarujemy naszego mocka. W handlerze korzystamy z paczki `rest`, kt贸ra posiada w sobie metody nazwane analogicznie do metod HTTP. Przekazujemy do nich **adres url** i **callback**.

```ts
import { rest } from 'msw';
import { setupServer } from 'msw/node';
import { postData } from '../../data/post';

const server = setupServer(
  rest.get<PostType>('https://jsonplaceholder.typicode.com/posts/1', (_req, res, ctx) => {
    return res(
      ctx.json({
        ...postData,
      }),
    );
  }),
);
```

Z poziomu callbacku mamy dostp do obiektu [偶dania](https://mswjs.io/docs/api/request), [odpowiedzi](https://mswjs.io/docs/api/response) i tzw. [contextu](https://mswjs.io/docs/api/context). W rodku zwracamy odpowied藕 i korzystamy z metody `ctx.json()`, kt贸ra ustawia `body` odpowiedzi wraz z nag贸wkiem `Content-Type: application/json`.

<Newsletter />

Jed藕my dalej, naszym nastpnym krokiem bdzie stworzenie prostego _wrappera_ na funkcje `render` z React Testing Library. Dlaczego tak? To wszystko przez wczeniej wspominane React Query, jeli nie korzystasz z tej biblioteki, to mo偶esz na spokojnie pomin ten krok.

```tsx
import {
  render as rtlRender,
  screen,
  waitFor,
  waitForElementToBeRemoved,
  RenderOptions,
} from '@testing-library/react';
import { QueryClient, QueryClientProvider } from 'react-query';
import { rest } from 'msw';
import { setupServer } from 'msw/node';
import { ReactNode } from 'react';
import { postData } from '../../data/post';
import { Post } from './Post';
import type { Post as PostType } from '../../utils/types';

const server = setupServer(
  rest.get<PostType>('https://jsonplaceholder.typicode.com/posts/1', (_req, res, ctx) => {
    return res(
      ctx.json({
        ...postData,
      }),
    );
  }),
);

const queryClient = new QueryClient();

const render = (ui: ReactNode, { ...rtlOptions }: RenderOptions = {}) => {
  return rtlRender(<QueryClientProvider client={queryClient}>{ui}</QueryClientProvider>, {
    ...rtlOptions,
  });
};

describe('Post', () => {
  beforeAll(() => server.listen());
  afterEach(() => {
    server.resetHandlers();
    queryClient.clear();
  });
  afterAll(() => server.close());
});
```

Ohh, zapomniaem o najwa偶niejszym, **nie zapomnij po sobie posprzta**! W funkcjach pomocniczych otwieramy i zamykamy poczenie z serwerem oraz czycimy handlery i cache.

Uff, konfiguracja skoczona, przejd藕my do waciwego testu. Jeli czytae [poprzednie wpisy z tej serii](https://frontlive.pl/blog/react-testing-library-testy-w-praktyce), to nie powinno by tutaj dla Ciebie 偶adnego zaskoczenia. Sprawdzamy tutaj, czy tytu naszego posta zostanie wywietlony po etapie adowania:

```tsx
it('shows correct title when loading status is over', async () => {
  render(<Post id={1} />);

  const loading = screen.getByText(/loading/i);

  expect(loading).toBeInTheDocument();

  await waitForElementToBeRemoved(loading).then(() => {
    const postHeading = screen.getByRole('heading', { level: 2 });
    expect(postHeading).toHaveTextContent(postData.title);
  });
});
```

Okej Olaf, a co z edge casami? Na tym polu MSW r贸wnie偶 mnie nie zawiodo, jeli potrzebujemy zadeklarowa handler na poziomie jednego testu, to nic nie stoi nam na przeszkodzie!

```tsx
it('shows an error message when request fails', async () => {
  server.use(
    rest.get('https://jsonplaceholder.typicode.com/posts/1', (_req, res, ctx) => {
      return res(ctx.status(500));
    }),
  );

  render(<Post id={1} />);

  const loading = screen.getByText(/loading/i);

  expect(loading).toBeInTheDocument();

  await waitForElementToBeRemoved(loading).then(() => {
    const error = screen.getByText(/something went wrong/i);
    expect(error).toBeInTheDocument();
  });
});
```

## Podsumowanie

Mock Service Worker bardzo pozytywnie mnie (i [nie tylko mnie](https://kentcdodds.com/blog/stop-mocking-fetch)) zaskoczy i to, co Ci dzi pokazaem, to tylko uamek jego mo偶liwoci 

Cay kod (+1 przykad) znajdziesz w [repozytorium na GitHubie](https://github.com/olafsulich/react-testing-library-workshop).

Do usyszenia!
