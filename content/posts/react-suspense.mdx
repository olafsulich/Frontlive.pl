---
title: 'React - Suspense & Concurrent mode'
category: 'React'
publishedAt: '26-06-2020'
isPublished: true
popular: false
excerpt: 'Concurrent mode to zestaw nowych funkcjonalnoÅ›ci, obecnie w fazie eksperymentalnej. CaÅ‚Ä… filozofia concurrent mode opiera siÄ™ na nieblokowaniu renderowania elementu.'
---

CzeÅ›Ä‡ ğŸ‘‹

DziÅ› przedstawiÄ™Â wam parÄ™ nowoÅ›ci w **Reakcie**, ktÃ³re wchodzÄ… w skÅ‚ad trybu wspÃ³Å‚bieÅ¼nego (Concurrent mode).

> Miej na uwadzÄ™, Å¼e tryb wspÃ³Å‚bieÅ¼noÅ›ci jest obecnie w fazie eksperymentalnej i nie jest dostÄ™pny w wersji stabilnej

## Spis treÅ›ci

- [Wprowadzenie](#wprowadzenie)
- [Instalacja](#instalacja)
- [Suspense](#suspense)
- [SuspenseList](#suspenselist)
- [useTransition](#usetransition)
- [useDeferredValue](#usedeferredvalue)

## Wprowadzenie

MoÅ¼liwe, Å¼e sÅ‚yszeliÅ›cie juÅ¼ o **trybie wspÃ³Å‚bieÅ¼nym** lub nawet z niego korzystaliÅ›cie. Dla tych, ktÃ³rzy nie mieli jeszcze tej przyjemnoÅ›ci, jest to zestaw nowych funkcjonalnoÅ›ci, obecnie w fazie eksperymentalnej. CaÅ‚Ä… filozofia **concurrent mode** opiera siÄ™ na **nieblokowaniu renderowania** elementu. React, domyÅ›lnie, gdy zacznie renderowaÄ‡ jakiÅ› element, **nie** moÅ¼e przerwaÄ‡ tej akcji, takie dziaÅ‚anie nazywane jest _blocking renderingiem_.

W trybie wspÃ³Å‚bieÅ¼nym, w procesie renderowania, _przerywamy_ ten proces, dziÄ™ki czemu mamy nad nim **wiÄ™kszÄ… kontrole**.

To tak w skrÃ³cie, jeÅ›li chcesz poznaÄ‡ gÅ‚Ä™bszÄ… filozofiÄ™ stojÄ…cÄ… za **concurrent mode**, moÅ¼esz o niej przeczytaÄ‡ w [dokumentacji](https://pl.reactjs.org/docs/concurrent-mode-intro.html).

## Instalacja

Okej, ale jak moÅ¼emy z tego wszystkiego skorzystaÄ‡? Po pierwsze musimy zainstalowaÄ‡ **eksperymentalny build** Reakta:

```bash
npm install react@experimental react-dom@experimental
```

Drugim krokiem bÄ™dzie wykorzystanie metody `createRoot()` w naszym pliku wejÅ›ciowym **index.js**:

```jsx
// Normalnie

ReactDOM.render(<App />, document.getElementById('root'));

// Tryb wspÃ³Å‚bieÅ¼ny

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
```

## Suspense

Zacznijmy od Suspensa, pozwala nam on _poczekaÄ‡_ na dane zanim przerenderujemy nasz komponent. Jakie mogÄ… byÄ‡ to dane? MogÄ… byÄ‡ to np. **dane przychodzÄ…ce** z jakiegoÅ› API, moÅ¼e byÄ‡ to rÃ³wnieÅ¼ inny **komponent**.

### Lazy

Zacznijmy od komponentu, zaimportujemy od razu nasz komponent za pomocÄ… **specjalnej** funkcji `lazy()`.

```jsx
// Stary sposÃ³b
import MyComponent from './MyComponent';

// Import za pomocÄ… lazy

const MyComponent = React.lazy(() => import('./MyComponent'));
```

`lazy()` przyjmujÄ™ funkcjÄ™ jako argument, ktÃ³ra wywoÅ‚uje **dynamiczny** `import()` i zwraca nam _obietnicÄ™_ (Promise).

### Komponent z Suspense

PrzyjdÅºmy teraz do samego Suspensa, jest to zwykÅ‚y komponent, ktÃ³ry przyjmuje **propsa** `fallback`. Podajemy w nim **dowolny element** Reaktowy:

```jsx
import React, { Suspense } from 'react';

const MyComponent = React.lazy(() => import('./MyComponent'));

const App = () => {
  <Suspense fallback={<span>Loading...</span>}>
    <MyComponent />
  </Suspense>;
};
```

W ten sposÃ³b, **podczas Å‚adowania** komponentu zobaczmy tekst `Loading...`. MoÅ¼esz oczywiÅ›cie wstawiÄ‡ tutaj jakiÅ› **customowy loader**, na pewno bÄ™dzie to lepiej wyglÄ…daÄ‡.

> Funkcja lazy nie jest czÄ™Å›ciÄ… trybu wspÃ³Å‚bieÅ¼nego, ale Å›wietnie sprawdza siÄ™ w poÅ‚Ä…czeniu z Suspense

### Pobieranie danych

Jak juÅ¼ wczeÅ›niej wspominaÅ‚em, moÅ¼emy wykorzystaÄ‡ tryb wspÃ³Å‚bieÅ¼ny do **pobierania danych**.

```jsx
import React, { Suspense } from 'react';
import { fakeAnimalsApi } from './fakeApi';

const api = fakeAnimalsApi();

const ZooApp = () => {
  return (
    <Suspense fallback={<h1>Loading animal ğŸ¼...</h1>}>
      <AnimalProfile />
      <Suspense fallback={<h1>Loading food ğŸ€...</h1>}>
        <AnimalFood />
      </Suspense>
    </Suspense>
  );
};

const AnimalProfile = () => {
  const animal = api.animal.get();
  return <h1>{animal.name}</h1>;
};

const AnimalFood = () => {
  const food = api.food.get();
  return (
    <ul>
      {food.map(({ id, name }) => (
        <li key={id}>{name}</li>
      ))}
    </ul>
  );
};
```

Zacznijmy od doÅ‚u, mamy tutaj dwa komponenty, ktÃ³re wykorzystujÄ… **atrapÄ™ api** ze zwierzÄ™tami. PrÃ³bujemy pobraÄ‡ pewne informacjÄ™, **nie sprawdzamy** jednak czy sÄ…Â one juÅ¼ dostÄ™pne. W komponencie `ZooApp` przekazujemy `AnimalProfile` i `AnimalFood` jako dzieci. React prÃ³buje wyrenderowaÄ‡ `AnimalProfile`, jednak dane **nie sÄ… jeszcze gotowe** do wyÅ›wietlenia w UI, przeskakuje wiÄ™c do nastÄ™pnego komponentu `Animal Food` tutaj prÃ³buje pobraÄ‡ dane, ale sytuacja siÄ™Â powtarza. Wracamy do poczÄ…tku, React wyÅ›wietli nam pierwszy loader - `Loading animal ğŸ¼...`.

ZastosowaliÅ›my tutaj podwÃ³jny Suspense, gdy nasz komponent `AnimalProfile` siÄ™ zaÅ‚aduje, wtedy nastÄ…pi Å‚adowanie `AnimalFood`. MoÅ¼emy jednak wrzuciÄ‡ oba komponenty w jednego Suspensa.

CaÅ‚e to rozwiÄ…zanie, na poczÄ…tku, moÅ¼e wydawaÄ‡ Ci sieÂ skomplikowane, ale **redukuje** nam ono duÅ¼o boilerplatu.

```jsx
âŒ

if (someData) {
  return <span>Loading animal ğŸ¼...</span>;
}

âœ…

<Suspense fallback={Loading animal ğŸ¼...}>
    {...}
</Suspense>
```

## SuspenseList

Pomaga nam zarzÄ…dzaÄ‡ wieloma komponentami, ktÃ³re uÅ¼ywajÄ… Suspense, a wÅ‚aÅ›ciwie **w jakiej kolejnoÅ›ci** majÄ… byÄ‡ one wczytywane. DomyÅ›lnie, gdy opleciemy nasze komponenty w `SuspenseList`, React bÄ™dzie wyÅ›wietlaÅ‚ poszczegÃ³lne komponenty jeden po drugim.

To zachowanie moÅ¼emy jednak **zmieniaÄ‡** wykorzystujÄ…c dane **propsy**:

- **revealOrder** - definiuje w jakiej kolejnoÅ›ci dzieci SuspenseList majÄ… byÄ‡ "wyÅ›wietlane"

- **tail** - decyduje, w jaki sposÃ³b niezaÅ‚adowane jeszcze elementy majÄ… siÄ™ wyÅ›wietlaÄ‡

```jsx
<SuspenseList revealOrder="forwards" tail="collapsed">
  <Suspense fallback={'Loading panda ğŸ¼...'}>
    <AnimalProfile id={1} />
  </Suspense>
  <Suspense fallback={'Loading dog ğŸ¶...'}>
    <AnimalProfile id={2} />
  </Suspense>
  <Suspense fallback={'Loading cat ğŸ±...'}>
    <AnimalProfile id={3} />
  </Suspense>
</SuspenseList>
```

## useTransition

Wraz z tymi wszystkimi nowoÅ›ciami dostajemy rÃ³wnieÅ¼ **nowe hooki**, bo kto nie kocha hooksÃ³w ğŸ’™ ?

Gdy uÅ¼ywamy Suspensa i wykorzystujemy jakiÅ› stan, dostaniemy **nieprzyjemne przejÅ›cie**, ten urywek to po prostu zaczytywanie **kolejnych danych**. Jak temu zaradziÄ‡? UÅ¼yÄ‡ `useTransition`! Pozwala on nam poczekaÄ‡ na dane, zanim przejdziemy do nastÄ™pnego ekranu.

Zwraca on dwie wartoÅ›ci:

- **startTransition** - przyjmujÄ™ callback, wskazuje on state, ktÃ³ry ma zostaÄ‡ opÃ³Åºniony

- **isPending** - informujÄ™ o stanie naszego przejÅ›cia, zwraca boolean

```jsx
import React, { useState, useTransition, Suspense } from 'react';
import { fetchFakeAnimals } from './fakeApi';

const getNextId = (id) => (id === 3 ? 0 : id + 1);

const initialApi = fetchFakeAnimals(0);

const Main = () => {
  const [api, setApi] = useState(initialApi);
  const [startTransition, isPending] = useTransition({
    timeoutMs: 3000,
  });

  const fetchNextAnimal = () => {
    startTransition(() => {
      const nextAnimalId = getNextId(api.animalId);
      setApi(fetchFakeAnimals(nextAnimalId));
    });
  };

  return (
    <>
      <button disabled={isPending} onClick={fetchNextAnimal}>
        Next ğŸ‘‰
      </button>

      {isPending ? ' â›” ' : ' âœ… '}
      <ZooApp api={api} />
    </>
  );
};

const ZooApp = () => {
  return (
    <Suspense fallback={<h1>Loading animal ğŸ¼...</h1>}>
      <AnimalProfile api={api} />
      <Suspense fallback={<h1>Loading food ğŸ€...</h1>}>
        <AnimalFood api={api} />
      </Suspense>
    </Suspense>
  );
};

const AnimalProfile = ({ api }) => {
  const animal = api.animal.get();
  return <h1>{animal.name}</h1>;
};

const AnimalFood = ({ api }) => {
  const food = api.food.get();
  return (
    <ul>
      {food.map(({ id, name }) => (
        <li key={id}>{name}</li>
      ))}
    </ul>
  );
};
```

Tworzymy funkcjÄ™ `fetchNextAnimal()`, ktÃ³ra wykorzystuje `startTransition`. PÃ³Åºniej juÅ¼ tylko generujemy nastÄ™pne `id` dla danego zwierzaka i **ustawiamy state**. CaÅ‚Ä… funkcja odpali siÄ™ **po klikniÄ™ciu** w przycisk.

SpÃ³jrzmy jeszcze na chwilÄ™ na hooka `useTransition`, podajemy **obiekt z opcjami**. MoÅ¼emy tutaj podaÄ‡ `timeoutMs`, czyli czas (liczony w milisekundach), po ktÃ³rym pokaÅ¼emy **nastÄ™pny stan**.

## useDeferredValue

Powiedzmy, Å¼e tworzymy listÄ™ zwierzÄ…t, bÄ™dÄ… one **pobierane po wpisaniu** odpowiedniej nazwy do **inputa**. Å»eby nie _zmyliÄ‡_ uÅ¼ytkownika, chcemy stworzyÄ‡ jakiÅ› **wizualny efekt**, coÅ› co pomoÅ¼e mu zrozumieÄ‡, Å¼e dane sÄ… pobierane, a caÅ‚oÅ›Ä‡ wyÅ›wietli poprzednio wyszukane zwierzÄ™ta.

```jsx
import { useState, useDeferredValue } from 'react';

const ZooApp = ({ api }) => {
  const [name, setName] = useState('panda');

  const someFakeApiCall = () => api.filter(name);

  const deferredApi = useDeferredValue(someFakeApiCall, {
    timeoutMs: 1000,
  });

  const handleChange = (e) => setName(e.target.value);

  return (
    <>
      <label>Filter animals:</label>
      <input value={name} onChange={handleChange} />
      <Suspense fallback={<h1>Loading animal ğŸ¼...</h1>}>
        <AnimalsList api={deferredApi} isStale={deferredApi !== someFakeApiCall} />
      </Suspense>
    </>
  );
};

const AnimalsList = ({ isStale, api }) => {
  const animals = api.animals.read();
  return (
    <ul style={{ opacity: isStale ? 0.5 : 1 }}>
      {animals.map(({ id, text }) => (
        <li key={id}>{text}</li>
      ))}
    </ul>
  );
};
```

W ten sposÃ³b, gdy bÄ™dziemy filtrowaÄ‡ naszÄ… listÄ™, dostaniemy lekkiego _laga_, swoiste **opÃ³Åºnienie**, podczas ktÃ³rego nasza lista dostanie `opacity: 0.5`.
Tak samo jak w przypadku `useTransition`, mamy tutaj moÅ¼liwoÅ›Ä‡ podaÄ‡ opcjÄ™ `timeoutMs`.

> Wstawianie styli inlinowo nie jest dobrÄ… praktykÄ…, zostaÅ‚o uÅ¼yte wyÅ‚Ä…cznie w celach prezentacyjnych

## Podsumowanie

DziÄ™ki za wytrwanie do koÅ„ca! Tryb wspÃ³Å‚bieÅ¼ny jest dopiero w fazie eksperymentalnej i uÅ¼ywanie go produkcyjnie **moÅ¼e byÄ‡ ryzykowne**. UwaÅ¼am jednak, tak jak sami twÃ³rcy, Å¼e concurrent mode to **przyszÅ‚oÅ›Ä‡ Reakta**. Przynosi on wiele **ciekawych** i **przydanych** ficzerÃ³w.

Co o tym sÄ…dzicie? Dajcie znaÄ‡ w komentarzach ğŸ‘‡

Do nastÄ™pnego!

### Å¹rÃ³dÅ‚a

[React Docs](https://pl.reactjs.org/docs/concurrent-mode-intro.html).
