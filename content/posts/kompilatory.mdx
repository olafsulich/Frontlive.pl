---
title: 'Kompilator to nic strasznego, czyli jak dziaa Tw贸j kod pod spodem?'
category: 'JavaScript'
publishedAt: '18-10-2021'
isPublished: true
popular: false
image: '/images/kompilatory/thumbnail.png'
excerpt: 'Czym s, jak dziaaji jakie problemy rozwizuj wsp贸czesne kompilatory takie jak Babel?'
---

Za贸偶my, 偶e pracujesz nad now aplikacjw JavaScripcie, czytasz wymagania biznesowe, wszystko jest jasne i klarowne... A偶 do ostatniego podpunktu wymaga - kompatybilnoz Internet Explorer  Zanim rzucisz wypowiedzeniem na st贸 swojego szefa wykrzykujc, 偶e nie bdziesz pisa w prehistorycznym standardzie ES3, przeczytaj ten artyku, bo jest spos贸b na zachowanie pracy i zdrowia psychicznego w tym projekcie!

## Jak dziaaj kompilatory?

Piszesz nowy, zajebisty kodzik w JS, a wysyasz do przegldarki kod "legacy", taki, 偶eby by kompatybilny ze rodowiskiem uruchomieniownym, w naszym przypadku z przegldarkIE starszej generacji. Ten opis idealnie pasuje do najpopularniejszego kompilatora w naszym JS'owym rodowisku - [Babela](https://babeljs.io/docs/en/). Babel nie jest wyjtkiem w naszej bran偶y jeli chodzi o kompilatory. Innym przykadem mo偶e by r贸wnie偶 kompilator TSa, kt贸ry kompiluje kod z tego jzyka na penoprawny JavaScript.

Wiemy ju偶 czym s i jakie problemy rozwizuj, ale jak tak naprawddziaaj kompilatory? Proces kompilacji mo偶emy podzieli na trzy etapy:

1. **Parsowanie** - kompilator bierze surowy kod i przeksztaca go w jego abstrakcyjnreprezentacj
2. **Transformacja** - kompilator korzysta z przetworzonej, abstrakcyjnej reprezentacji kodu i modyfikuje jwedug potrzeb
3. **Generacja** - przetransformowana, abstrakcyjna reprezentacja kodu zostaje z powrotem wygenerowana w zwyky kod

<Image
  src="/images/kompilatory/trzy-kroki.png"
  alt="Trzy kroki potrzebne do kompilacji: parsowanie, transformacja i generacja"
/>

## Parsowanie

Pierwszy z proces贸w, proces parsowania. To w nim Tw贸j kod bdzie czytany przez kompilator. Po _przemieleniu_, jeli wszystko poszo okej, kod zostanie sprasowany do tzw. **Abstract Syntax Tree** (AST), czyli drzewiastej reprezentacji kodu, do kt贸rej za chwil przejdziemy.

W procesie parsowania rozr贸偶niamy jeszcze dwa podprocesy:

1. Tokenizacj
2. Analizskadni

<Image
  src="/images/kompilatory/parsowanie.png"
  alt="Diagram procesu parsowania ilustrujcy powizanie pomidzy analizami syntax i lexical"
/>

### Tokenizacja

Tokenizacja, zwana r贸wnie偶 analizleksykaln(ang. _lexical analysis_) to proces przeksztacania cigu znak贸w w odpowiednio oznaczone tokeny.

We藕my taki kawaek kodu `const message = "Hello world!"`, po przemieleniu go przez _tokenizer_ otrzymamy cztery tokeny - `const`, `message`, `=` oraz `"Hello world!"`.

<Image
  src="/images/kompilatory/lexical-analysis.png"
  alt="Diagram ilustrujcy proces analizy leksykalnej"
/>

### Analiza skadni

Tak odseparowane kawaki kodu s wysyane do tzw. analizy skadni (ang. _syntax/syntactic analysis_). Kompilator przechodzi przez ka偶dy token i tworzy z nich wczeniej wspomnian abstrakcyjnreprezentacj kodu, czyli **Abstract Syntax Tree** (AST):

<Image src="/images/kompilatory/ast.png" alt="Wizualna reprezentacja drzewa AST" />

Dla naszego skrawka kodu AST mo偶e wyglda w taki spos贸b (uproszczone, format: JSON):

```json
{
  "type": "Program",
  "start": 0,
  "end": 33,
  "sourceType": "module",
  "interpreter": null,
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 31,
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 6,
          "end": 30,
          "id": {
            "type": "Identifier",
            "start": 6,
            "end": 13,
            "name": "message"
          },
          "init": {
            "type": "StringLiteral",
            "start": 16,
            "end": 30,
            "value": "Hello world!"
          }
        }
      ],
      "kind": "const"
    }
  ]
}
```

<Newsletter />

## Transformacja

W tym etapie dostajemy wczeniej przygotowany AST i mo偶emy z nim robi co tylko chcemy! Jak moge zauwa偶y, drzewo zbudowane jest z podobnych do siebie obiekt贸w zwanymi _AST nodes_:

Node dla `VariableDeclaration`:

```json
{
  "type": "VariableDeclaration",
  "start": 0,
  "end": 31,
  "declarations": [...],
}
```

Ka偶dego takiego _noda_ mo偶emy modyfikowa w dowolny spos贸b.

Spr贸bujmy stworzy mechanizm, kt贸ry zamieni nasz wsp贸czesny kod, w polskrezprezentacjkodu sprzed ery ES6, cona wz贸r synnego `isPies` :) 呕eby odpowiednio zmodyfikowa nody, bdziemy potrzebowa obiektu `visitor`, w kt贸rym nazwy metod bd odpowiaday typom z AST:

```js
{
  visitor: {
    VariableDeclaration(path) {
      path.node.kind = "var";
    },
    Identifier(path) {
      path.node.name = "wiadomo";
    },
    StringLiteral(path) {
      path.node.value = "Witaj wiecie!";
    }
  }
}
```

Chcesz wypr贸bowa ten mechanizm transformacji? Sprawd藕 [AST Explorer](https://astexplorer.net/) 锔

## Generacja

Ostatni z proces贸w, bierzemy przetransformowane drzewo AST i z powrotem zmieniamy jest w cig znak贸w. Kompilator bdzie przechodzi przez wszystkie _AST nodes_ dop贸ki `const message = "Hello world!"` nie zamieni siw pikne `var wiadomo = "Witaj wiecie!"`.

<Image src="/images/kompilatory/generacja-kodu.png" alt="" />

## Podsumowanie

To by byo na tyle jeli chodzi o kompilatory 锔 Bez zbdnego gadania, pomijajc szczeg贸y technicznie, tak 偶eby uproci temat jak tylko si da. Jeli chcesz sitrochbardziej wgbi w sam implementacj, to polecam Ci pierwszy z link贸w w 藕r贸dach, autor tworzy w nim maleki kompilator w JavaScript 

### 殴r贸da

- [The Super Tiny Compiler](https://github.com/jamiebuilds/the-super-tiny-compiler)
- [Compilers for Humans](https://www.compilersforhumans.com/)
- [AST Explorer](https://astexplorer.net/)
