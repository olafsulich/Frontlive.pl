---
title: 'Funkcyjne modelowanie domeny i nielegalne stany w TypeScript'
category: 'TypeScript'
publishedAt: '13-06-2022'
isPublished: false
popular: false
image: '/images/typescript-modelowanie-domeny/thumbnail.png'
excerpt: 'Modelowanie domeny to proces przeÅ‚oÅ¼enia zaÅ‚oÅ¼eÅ„ nad kod. TypeScript, jeÅ›li wykorzystamy go w odpowiedni sposÃ³b, moÅ¼e dziÄ™ki swoim typom Å›wietnie odwzorowywaÄ‡Â wymagania biznesowe.'
---

TypeScript - jego gÅ‚Ã³wnym zadaniem jest gwarantowaÄ‡ nam bezpieczeÅ„stwo podczas kompilacji programu. Oferuje nam szereg narzÄ™dzi, ktÃ³re jeÅ›li odpowiednio wykorzystamy, usprawniÄ… proces tworzenia kodu. Kod to jedno, wymagania biznesowe to inna sprawa, jak to pogodziÄ‡? Modelowanie domeny to proces przeÅ‚oÅ¼enia zaÅ‚oÅ¼eÅ„ nad kod. TypeScript, jeÅ›li wykorzystamy go w odpowiedni sposÃ³b, moÅ¼e dziÄ™ki swoim typom Å›wietnie odwzorowywaÄ‡Â wymagania biznesowe.

## Nielegalne stany

Zacznijmy od poczÄ…tku, czyli od nielegalnych stanÃ³w. Czym wÅ‚aÅ›ciwie sÄ… nielegalne stany w kontekÅ›cie TypeScripta?

SpÃ³jrzmy na prosty przykÅ‚ad interfejsu, wyglÄ…da znajomo?

```tsx
interface State {
  data?: ResponseData;
  error?: Error;
  isLoading: boolean;
}
```

ZaÅ‚oÅ¼Ä™ siÄ™, Å¼e wiÄ™kszoÅ›Ä‡ React DeveloperÃ³w widziaÅ‚o podobny skrawek kodu w niejednej aplikacji.

Stan wykorzystujemy do pobierania danych API. Typ reprezentuje obiekt, ktÃ³ry zawiera potencjalne bÅ‚Ä™dy, dane i ich stan Å‚adowania. Pole `isLoading` jest **wymagane**, ten stan zawsze bÄ™dzie obecny. Danych i bÅ‚Ä™dÃ³w nie moÅ¼emy byÄ‡ pewni, pochodzÄ… one z zewnÄ…trz naszej aplikacji - oznaczamy je wiÄ™c jako opcjonalne.

```ts
const state1: State = { isLoading: false, error: new Error() }; // âœ…

const state2: State = { isLoading: false, data: {} }; // âœ…

const state3: State = { isLoading: true, error: new Error() }; // WTF? ğŸ¤¯ âœ…

const state4: State = { isLoading: true, data: {} }; // WTF? ğŸ¤¯ âœ…

const state5: State = { isLoading: false, error: new Error(), data: {} }; // WTF? ğŸ¤¯ âœ…
```

Pierwsze dwa stany sÄ… jak najbardziej poprawne, otrzymujemy wartoÅ›Ä‡ Å‚adowania `false`, oraz odpowiednio pole z bÅ‚Ä™dem lub poprawne dane. Sytuacja siÄ™Â komplikuje, gdy zaczniemy eksperymentowaÄ‡. OkaÅ¼Ä™Â siÄ™Â wtedy, Å¼e nasz kod, jest kompletnie dziurawy, jeÅ›li chodzi o typy. WkradÅ‚y nam siÄ™Â tutaj _nielegalne stany_.

Nasza aplikacja, nie powinna wskazywaÄ‡, Å¼e dane jeszcze siÄ™ Å‚adujÄ…, gdy juÅ¼ faktycznie mamy je dostÄ™pne. JeÅ›li doÅ‚oÅ¼ymy do tego sytuacjÄ™, w ktÃ³rej otrzymujemy jednoczeÅ›nie dane i bÅ‚Ä™dy, to otrzymujemy niezÅ‚y baÅ‚gan. WyobraÅº sobie teraz te wszystkie ify, ktÃ³re sprawdzajÄ… kaÅ¼dy przypadek - po prostu nie ma to sensu!

Zamiast oznaczaÄ‡ pola opcjonalnymi, powinniÅ›my wskazaÄ‡Â dokÅ‚adnie jakie stany sÄ… faktycznie **dopuszczalne**. Przekazujemy kompilatorowi, Å¼e jednoczeÅ›nie nie powinniÅ›my otrzymywaÄ‡Â np. danych i bÅ‚Ä™dÃ³w.

```ts
type State =
  | { status: 'loading' }
  | { status: 'error'; error: Error }
  | { status: 'success'; data: ResponseData };
```

Korzystamy tutaj z unii obiektÃ³w i modelujemy **dozwolone zachowania** stanu. DziÄ™ki temu nielegalne stany, nie bÄ™dÄ… moÅ¼liwe do odtworzenia:

```ts
const state1: State = { status: 'error', error: new Error() }; // âœ…

const state2: State = { status: 'success', data: {} }; // âœ…

const state3: State = { status: 'success', error: new Error() }; // âŒ

const state4: State = { status: 'loading', data: {} }; // âŒ

const state5: State = { status: 'error', error: new Error(), data: {} }; // âŒ
```

## Modelowanie domeny biznesowej

TypeScriptowe typy nie tylko Å›wietnie siÄ™Â sprawdzajÄ… do zwiÄ™kszania bezpieczeÅ„stwa naszego kodu, ale rÃ³wnieÅ¼ mogÄ…Â reprezentowaÄ‡Â Å›wietnie zaÅ‚oÅ¼enia domeny biznesowej.

Zamodelujmy obiekt uÅ¼ytkownika w naszym systemie. Aplikacja pozwala rejestrowaÄ‡ siÄ™Â uÅ¼ytkownikom indywidualnym oraz tym, ktÃ³rzy reprezentujÄ… firmy. KaÅ¼dy z nich bÄ™dzie posiadaÅ‚ pÃ³lÄ™ wspÃ³lnych informacji. Od przedstawicieli firm, oczekujemy rÃ³wnieÅ¼ dodatkowo numeru telefonu i nazwy firmy.

```ts
interface User {
  type: string;
  phoneNumber: number;
  email: string;
  name: string;
  company: string;
}
```

Czy ten typ dobrze oddaje zaÅ‚oÅ¼enia naszej domeny? Po zapoznaniu siÄ™Â z zaÅ‚oÅ¼eniami i stworzonym typem, w gÅ‚owie moÅ¼e nam siÄ™Â zrodziÄ‡ wiele pytaÅ„:

- Jaki typ moÅ¼e mieÄ‡ uÅ¼ytkownik?
- Jakie sÄ… ograniczenia danych pÃ³l?
- Czy wszysktie pola powinny byÄ‡ wymagane?
- Czy jakieÅ› pola sÄ…Â ze sobÄ…Â powiÄ…zane?

```ts
interface User {
  type: 'business' | 'individual';
  phoneNumber?: number;
  email: string;
  name: string;
  company?: string;
}
```

UsprawniliÅ›my nasz model, okreÅ›liliÅ›my `type`, oznaczyliÅ›my opcjonalne pola. Jednak jeÅ›li zamodelowalibyÅ›my w ten sposÃ³b naszego uÅ¼ytkownika, to ponownie byÅ›my mieli do czynienia z _nielegalnymi stanami..._

Indywidualny uÅ¼ytkownik nie powinien posiadaÄ‡ ani numeru telefonu, ani informacji o nazwie firmy, ktÃ³rÄ…Â repreznetuje. Poprawmy nasz przykÅ‚ad:

```ts
// 1.
interface CommonUserFields {
  email: string;
  name: string;
}

// 2.
type IndividualUser = CommonUserFields & { type: 'individual' };

// 3.
type BusinessUser = CommonUserFields & { type: 'business'; company: string; phoneNumber: number };

// 4.
type User = IndividualUser | BusinessUser;
```

1. WspÃ³lna grupa pÃ³l dla kaÅ¼dego usera
2. UÅ¼ytkownik indywidualny, posiada odpowiedni typ
3. UÅ¼ytkownik reprezentujÄ…cy firmÄ™, posiada odpowiedni typ i wÅ‚asny zestaw pÃ³l
4. OgÃ³lny model usera, zebrany w caÅ‚oÅ›Ä‡

Tak stworzone typy, bardzo dobrze odwzorowujÄ…Â wymagania modelu biznesowego naszego uÅ¼ytkownika. CzytajÄ…c taki typ, wiemy jak wyglÄ…dajÄ… zaÅ‚oÅ¼enia, moÅ¼emy powiedzieÄ‡, Å¼e w systemie mamy dwÃ³ch uÅ¼ytkownikÃ³w, kaÅ¼dy z nich posiada zestaw wspÃ³lnych i unikalnych wÅ‚aÅ›ciwoÅ›ci.

A co z wspomnianymi ograniczeniami?

SprÃ³bujmy wykorzystaÄ‡ model w praktyce:

```ts
declare function registerUser(user: User): void;

registerUser({
  type: 'individual',
  email: 'test',
  name: 'Olaf',
});
```

Rejestrujemy uÅ¼ytkownika, niby wszystko jest okej, ale jednak email nie jest poprawny. MoÅ¼emy zamiast niego wpisaÄ‡ tak naprawdÄ™Â **dowolny ciÄ…g znakÃ³w**, co z perspektywy naszej domeny nie jest dozwolone.

Tak jak wiek uÅ¼ytkownika nie bÄ™dzie iloÅ›ciÄ… nÃ³g jaszczurki, cena produktu nie bÄ™dzie jego dostÄ™pnÄ… iloÅ›ciÄ…Â w magazynie, tak samo email nie powinien byÄ‡ dowolonym ciÄ…giem znakÃ³w.

Pewne dane nie powinny byÄ‡ sprowadzane do jednego, prymitywnego mianowinka. ChociaÅ¼ wiek uÅ¼ytkownika i iloÅ›Ä‡ nÃ³g jaszczurki to ten sam typ `number`, to czy te dane moÅ¼na wykorzystaÄ‡Â w jakimÅ› jednym procesie? Czy moÅ¼emy je do siebie dodaÄ‡? No nie! Podczas modelowania domeny powinniÅ›my dokÅ‚adnie okreÅ›liÄ‡ co czym jest, naÅ‚oÅ¼yÄ‡ **ograniczenia**, ktÃ³re odwzorowywaÅ‚yby wymagania biznesowe.

## Typowanie nominalne

W takich przypadkach niezwykle przydatne okazuje siÄ™ byÄ‡Â *typowanie nominalne*. Temu sposobowi typowania moÅ¼na by poÅ›wiÄ™ciÄ‡Â caÅ‚y artykuÅ‚, ja ograczniczÄ™Â siÄ™Â do niezbÄ™dnego minimum. Typowanie nominalne pozwala nam odrÃ³Å¼niÄ‡ typy nie tylko przez ksztaÅ‚t danych, ale rÃ³wnieÅ¼ przez nazwÄ™ czy referencjÄ™. System typowania nominalnego walczy z doÅ›Ä‡ powszechnÄ…Â chorobÄ… zwanÄ…Â *primitive obssesion*. Sprawdza siÄ™Â przede wszystkim dla **kluczowych** danych w naszej domenie.

TypeScript domyÅ›lnie nie posiada moÅ¼liwoÅ›ci typowania nominalnie, jednak sÄ… pewne sposoby, Å¼eby je w TS zaimplementowaÄ‡. Jednym z nich jest skorzystanie z biblioteki [io-ts](https://gcanti.github.io/io-ts/), ktÃ³ra nie tylko pozwala okreÅ›liÄ‡ wÅ‚aÅ›ciwe typy, ale rÃ³wnieÅ¼ sprawdza wartoÅ›ci w czasie dziaÅ‚ania programu.

Do zamodelowania adresu email korzystamy z funkcji `t.brand()`, ktÃ³ra bazuje na technice brandowania typu i wykorzystuje `EmailAddressBrand`. Poza obrandowaniem typu, sprawdzamy rÃ³wnieÅ¼ poprawnoÅ›Ä‡ przekazywanej wartoÅ›ci tworzÄ…c wÅ‚asny walidator.

```ts
import * as t from 'io-ts';

interface EmailAddressBrand {
  readonly EmailAddress: unique symbol;
}

function validateEmailAddress(email: string): boolean {
  // logika sprawdzania poprawnoÅ›ci emaila
  return email.includes('@');
}

const EmailAddress = t.brand(
  t.string,
  (email: string): email is t.Branded<string, EmailAddressBrand> => validateEmailAddress(email),
  'EmailAddress',
);

type EmailAddress = t.TypeOf<typeof EmailAddress>;
```

Tak stworzony typ moÅ¼emy wykorzystaÄ‡ do zdekodowania wartoÅ›ci, a nastÄ™pnie sprawdziÄ‡ jej poprawnoÅ›Ä‡Â korzystajÄ…c z funkcji `isRight`. JeÅ›li email jest poprawny, funkcja zwrÃ³ci `true` i przepuÅ›ci warunek, co zaskutkuje zarejestrowaniem uÅ¼ytkownika.

```ts
import { isRight } from 'fp-ts/lib/Either';

interface CommonUserFields {
  email: EmailAddress;
  name: string;
}

// ...

function registerUser(user: User) {}

const decodedEmail = EmailAddress.decode('test@gmail.com');

if (isRight(decodedEmail)) {
  registerUser({
    type: 'individual',
    email: decodedEmail.right, // âœ…
    name: 'Olaf',
  });
} else {
  // obsÅ‚uga bÅ‚Ä™du
  console.log(decodedEmail.left);
}

registerUser({
  type: 'individual',
  email: 'test', // âŒ
  name: 'Olaf',
});
```

## Podsumowanie

Modelowanie domeny i ksztaÅ‚owanie poprawnego dziaÅ‚ania aplikacji to niezwykle waÅ¼ne rzeczy w kontekÅ›cie bezpieczeÅ„stwa aplikacji. Odpowiednie zamodelowanie TypeScriptowych typÃ³w pozwala nam nie tylko pozbyÄ‡ siÄ™Â niechcianych bÅ‚Ä™dÃ³w, ale rÃ³wnieÅ¼ przeÅ‚oÅ¼yÄ‡ wymagania biznesowe na kod.

## Å¹rÃ³dÅ‚a

- [F# - Making illegal states unrepresentable](https://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/)
- [F# - Domain modeling made functional](https://www.youtube.com/watch?v=Up7LcbGZFuo)
