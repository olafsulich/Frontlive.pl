---
title: 'React & TypeScript - komponenty generyczne'
category: 'React'
publishedAt: '15-11-2021'
isPublished: true
popular: false
image: '/images/react-typescript-komponenty-generyczne/thumbnail.png'
excerpt: 'Czy poczenie TypeScript & React musi siogranicza do typowania props贸w? Oczywicie, 偶e nie! W samym TS istnieje wiele bardziej zaawansowanych mechanizm贸w, kt贸re mo偶emy przeku do naszych aplikacji Reactowych...'
---

Czy poczenie TypeScript & React musi siogranicza do typowania props贸w? Oczywicie, 偶e nie! W samym TS istnieje wiele bardziej zaawansowanych mechanizm贸w, kt贸re mo偶emy przeku do naszych aplikacji Reactowych. Jednym z nich s funkcje generyczne. Jak dziki nim mo偶emy budowa w peni otypowane, dynamiczne komponenty w React?

Zanim zaczniemy, jeli jeszcze nie jeste zaznajomiony z tematem typ贸w i funkcji generycznych, to zapraszam Cido sprawdzenia [mojego osobnego artykuu na ten temat](https://frontlive.pl/blog/typescript-klasy) - ta wiedza bdzie niezbdna do zrozumienia komponent贸w generycznych w React.

## Generyczne komponenty

Skoro w TypeScripcie mamy mo偶liwo pisania funkcji generycznych, a w React komponenty to _tylko_ funkcje, to nic nie stoi nam na przeszkodzie, 偶eby stworzy generyczny komponent, zobacz jak to wyglda:

```tsx
type GenericComponentProps<T> = {
  prop1: T;
  prop2: Array<T>;
};

function GenericComponent<T>({ prop1, prop2 }: GenericComponentProps<T>) {}
```

Deklarujemy tutaj generyczny typ `GenericComponentProps<T>`, kt贸ry posu偶y nam do otypowania props贸w, a m贸wic bardziej po TypeScriptowemu, po prostu parametr贸w funkcji. Wszystko fajnie, tylko waciwie po co mielibymy to robi? Komponenty generyczne sprawdz siwietnie w takich dw贸ch podstawowych przypadkach:

1. Gdy chcemy, aby nasz **komponent by elastyczny**, jeli chodzi o typy. Nie nadajemy wtedy sztywnego typu dla np. tablicy element贸w, ale przypisujemy jej dynamiczny, generyczny typ.
2. Gdy chcemy, aby nasze **propsy byy ze sob powizane**. Dokadnie tak robimy w tym przypadku, `prop1` dostaje typ `T`, a `prop2`, jest po prostu tablic element贸wo typie `T`.

Wiemy ju偶 czym s, kiedy powinnimy z nich korzysta i w jaki spos贸b to robi, przejd藕 wic do bardziej praktycznego przykadu...

Zao偶enia: chcemy stworzykomponent tabelki, kt贸ry bdzie przyjmowa dane oraz kolumny. Propsy majbydynamiczne, chocia偶w pewien spos贸b ograniczone i zale偶ne od siebie.

Tworzymy komponent `Table`, tym razem przyjmuje on dwa typy zamiast jednego. Temu drugiemu nadajemy ograniczenia, korzystajc ze specjalnego s贸wka `extends`, parametr `Key` mo偶e by tylko kluczem `Row`. Nastpnie przekazujemy typy do tajemniczego `TableProps`, a w JSX renderujemy tabel:

```tsx
const Table = <Row, Key extends keyof Row>({ data, columns }: TableProps<Row, Key>) => (
  <table>{renderTable(data, columns)}</table>
);
```

Wewntrz `TableProps` deklarujemy typy dla `data`, `columns` i funkcji `renderTable`. Wszystkie te propsy korzystaj z generycznych parametr贸w i spowizane ze sob:

```tsx
type Column<Row, Key extends keyof Row> = {
  key: Key;
  header: string;
};

type TableProps<Row, Key extends keyof Row> = {
  data: Array<Row>;
  columns: Array<Column<Row, Key>>;
  renderTable: (row: Row, column: Column<Row, Key>) => React.ReactNode;
};

const Table = <Row, Key extends keyof Row>({ data, columns }: TableProps<Row, Key>) => (
  <table>{renderTable(data, columns)}</table>
);
```

Zostao nam tylko wywoanie komponentu, ale zanim to zrobimy, zamodelujmy dane:

```tsx
type Column<Row, Key extends keyof Row> = {
  key: Key;
  header: string;
};

type Character = Readonly<{
  id: number;
  name: string;
  status: 'Dead' | 'Alive';
  species: string;
}>;

const characters: Character[] = [
  {
    id: 1,
    name: 'Rick Sanchez',
    species: 'Human',
    status: 'Alive',
  },
  {
    id: 2,
    name: 'Morty Smith',
    species: 'Human',
    status: 'Alive',
  },
  {
    id: 4,
    name: 'Alexander',
    species: 'Human',
    status: 'Dead',
  },
];

const columns: Column<Character, keyof Character>[] = [
  {
    key: 'id',
    header: 'Id',
  },
  {
    key: 'name',
    header: 'Name',
  },
  {
    key: 'species',
    header: 'Species',
  },
  {
    key: 'status',
    header: 'Status',
  },
];
```

Nadaem typ `Column<Row,Key>` dla danych `columns`, 偶eby zaprezentowa Ci jak bdzie dziaa nasz komponent. Gdybymy teraz spr贸bowali poda `key`, kt贸ry nie jest kluczem obiektu `Character`, dostalibymy bd i dokadnie o to nam chodzio! Najlepsze jest to, 偶e podczas wywoania komponentu, nie musimy nic wicej robi ni偶 zwykle:

```tsx
const App = () => <Table data={characters} columns={columns} renderTable={...} />;
```

<Newsletter />

## Generyczne wyra偶enie funkcyjne

Kolejnym fajnym przykadem u偶ycia komponent贸w generycznych jest `Select`, tutaj podobnie jak poprzednio propsy spewien spos贸b dynamiczne i zale偶ne od siebie:

```tsx
type Option<Value> = {
  value: Value;
  name: string;
};

type SelectProps<Value> = {
  options: Array<Option<Value>>;
  value: Value;
};

const Select = <Value>({ options, value }: SelectProps<Value>) => {}; // Bd!
```

Tylko jest jeden may problem. TypeScript, przy generycznych wyra偶eniach funkcyjnych (komponenty pisane z `const`), nie rozumie, 偶e chcemy zadeklarowa tam generyka i rzuca bdami. Bd wystpuje tylko, gdy 偶aden z naszych parametr贸w nie jest ograniczany. Jak to naprawi:

1. Zamieni spos贸b zapisu z `const` na `function`
2. Ograniczy typ o `unknown` - `const Select = <Value extends unknown>() => {}`
3. Wprowadzi przecinek po parametrze - `const Select = <Value, >() => {}`

## Generyki z React.memo()/React.forwardRef()

Kolejnym problemem, kt贸ry wi偶e siz generycznymi komponentami, jest memoizacja za pomoc`React.memo()`. Memoizowane komponenty trochsi*gryz* z tymi generycznymi i **nie mo偶emy** zrobi czego takiego:

```tsx
const Select = <Value>memo(({ options, value }: SelectProps<Value>) => {}); // Bd!
```

Jak to ogarn? Wystarczy najpierw stworzy komponent, a dopiero p贸藕niej opakowa go w `React.memo()`. Pozostaje jeszcze kwestia typ贸w, tutaj z pomoc przychodzi asercja na oryginalny komponent:

Komponent:

```tsx
const _Select = <Value extends string>({ options, value }: SelectProps<Value>) => {};
```

Memoizacja:

```tsx
const Select = memo(_Select) as typeof _Select;
```

Dokadnie taki sam problem wystpuje przy korzystaniu z `React.forwardRef()`. Spor贸d [dostpnych rozwiza](https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref/58473012#58473012), ja osobicie skaniam siku temu samemu co w przypadku `memo()`:

Komponent:

```tsx
import type { Ref } from 'react';

const _Select = <Value extends string>(
  { options, value }: SelectProps<Value>,
  ref: Ref<HTMLSelectElement>,
) => <select ref={ref}></select>;
```

ForwardRef:

```tsx
const Select = forwardRef(_Select) as typeof _Select;
```

## Inferencja typ贸w

Ostatni z naszych temat贸w, czyli inferecja typ贸w. Podczas wywoywania komponentu `<Table />` nie podawalimy nic wic, TypeScript sam _domyli si_ jaki ma przekazatyp. A co jeli chcielibymy przekazatyp _na sztywno_ tak jak mo偶emy to zrobi w zwykych funkcjach?

Zobaczmy jak do tego tematu podeszli tw贸rcy Formika. Ich g贸wny komponent jest komponentem generycznym i jako pierwszy parametr przyjmuje `Values`. Przy jego wywoaniu podajemy tzw. `initialValues`, TypeScript na bazie obiektu, sam wywnioskuje jego typ:

```tsx
export function Formik<Values extends FormikValues = FormikValues, ExtraProps = {}>(
  props: FormikConfig<Values> & ExtraProps,
) {
  const formikbag = useFormik<Values>(props);
}

<Formik
  initialValues={{
    email: false, // Wszystko ok!
  }}
/>;
```

A co jeli chcielibymy powiedzie temu komponentowi, 偶e ma przyjmowa pocztkowe wartoci tylko o okrelonych typach? Wystarczy przekazado komponentu typ w taki spos贸b:

```tsx
type FormValues = {
  email: string;
};

<Formik<FormValues>
  initialValues={{
    email: false, // Bd!
  }}
/>;
```

Oczywicie moglibymy po prostu przypisa typ dla obiektu, ale ta opcja wyglda bardziej cool 

## Podsumowanie

Typy generyczne s pot偶nym mechanizmem, zar贸wno w czystym TS, jak i w tym w React. Nie b贸j sikorzystaz generycznych komponent贸w, wtedy, kiedy ma to sens. Dziki nim nasze aplikacje mog sta sio wiele bardziej type-safety.

Do usyszenia!

### 殴r贸da

- [React TypeScript Cheatsheet](https://react-typescript-cheatsheet.netlify.app/docs/advanced/patterns_by_usecase#generic-components)
- [Formik Generic Component](https://twitter.com/gustavo_pch/status/1386515073762529280)
