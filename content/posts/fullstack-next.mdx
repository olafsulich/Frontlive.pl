---
title: 'FullStack Next.js z Prisma, Stripe, React Query, Tailwind, NextAuth i TypeScript'
category: 'React'
publishedAt: '29-11-2021'
isPublished: true
popular: false
image: '/images/fullstack-next/thumbnail.png'
excerpt: 'Jak za pomocÄ…Â najszybciej rozwijajÄ…cego siÄ™Â frameworka na frontendzie Next.js, stworzyÄ‡ w peÅ‚ni funkcjonalnÄ…Â aplikacjÄ™ fullstackowÄ…Â z wykorzystaniem najnowszych technologii?'
---

## Wprowadzenie

Zanim zaczniemy, jeÅ›li wczeÅ›niej nie miaÅ‚eÅ› kontaktu z Next.js, to przed tym tutorialem zapoznaj siÄ™Â koniecznie z [oficjalnym poradnikiem](https://nextjs.org/learn/basics/create-nextjs-app?utm_source=next-site&utm_medium=nav-cta&utm_campaign=next-website). Poradnik wyjaÅ›nia wszystko czego potrzebujesz by zaczÄ…Ä‡ z Next.js do zera. WaÅ¼ne, Å¼ebyÅ› byÅ‚ zaznajomiony z podstawami, bo w tym tutorialu siÄ™ na nich nie skupiamy, za to bierzemy na tapet poszczegÃ³lne technologie i ich praktyczne wykorzystanie w projekcie.

Gotowi? Do dzieÅ‚a!

## Opis projektu

Czym bÄ™dziemy siÄ™Â dzisiaj tak wÅ‚aÅ›ciwie zajmowaÄ‡? Zbudujemy maÅ‚y sklep e-commerce z wykorzystaniem wielu bardzo fajnych technologii. PokaÅ¼Ä™ Ci jak poÅ‚Ä…czyÄ‡ narzÄ™dzia frontendowe, z tymi backendowymi i stworzyÄ‡ w peÅ‚ni dziaÅ‚ajÄ…cÄ…Â aplikacje w Next.js.

Zaimplementujemy uwierzytelnianie, pobierzemy produkty z bazy danych, ktÃ³re pÃ³Åºniej bÄ™dziemy mogli kupiÄ‡ przy pomocy Stripe - providera do obsÅ‚ugi pÅ‚atnoÅ›ci. Finalny wyglÄ…d:

<Image src="/images/fullstack-next/produkty.png" alt="Strona gÅ‚Ã³wna sklepu" />

Ten projekt moÅ¼esz rÃ³wnieÅ¼ traktowaÄ‡ jak **podstawowy budulec do rozbudowy** Twojego nastÄ™pnego _side projectu_. Ze wzglÄ™du na formÄ™ tego tutoriala (jeden artykuÅ‚), musiaÅ‚em ograniczyÄ‡ pewne funkcjonalnoÅ›ci. Ale nie martw siÄ™, na samym koÅ„cu znajdziesz sekcjÄ™ z kilkoma ficzerami wraz z opisem, o ktÃ³re moÅ¼esz rozbudowaÄ‡ ten sklep ğŸ›’

PoniÅ¼ej znajdziesz spis treÅ›ci, ktÃ³ry uÅ‚atwi Ci nawigowanie po kolejnych tematach ğŸ‘‡

## Spis treÅ›ci

- [Konfiguracja](#konfiguracja)
  - [Instalacja zaleÅ¼noÅ›ci](#instalacja-zaleznosci)
  - [Eslint & Prettier](#eslint-and-prettier)
  - [Husky & Lint staged](#husky-and-lint-staged)
  - [TailwindCSS](#tailwindcss)
  - [React Query](#react-query)
  - [Zmienne Å›rodowiskowe](#zmienne-srodowiskowe)
- [Baza danych](#baza-danych)
  - [Kontenery i Docker](#kontenery-i-docker)
- [Prisma](#prisma)
  - [Tworzenie schemy](#tworzenie-schemy)
  - [Migracje](#migracje)
- [Layout](#layout)
- [Produkty](#produkty)
  - [Karta produktu](#karta-produktu)
  - [Endpoint z Next API Routes](#endpoint-z-next-api-routes)
  - [ZaciÄ…ganie produktÃ³w z React Query](#zaciaganie-produktow-z-react-query)
- [Koszyk](#produkty)
  - [Koszyk w TailwindCSS](#koszyk-w-tailwindcss)
  - [Globany stan z React.Context](#globalny-stan-z-react.context)
- [Uwierzytelnianie](#uwierzytelnianie)
  - [Konfiguracja NextAuth](#konfiguracja-nextauth)
  - [Pomocnicze hooki i przekierowania](#pomocnicze-hooki-i-przekierowania)
- [PÅ‚atnoÅ›ci](#platnosci)
  - [Konfiguracja Stripe](#konfiguracja-stripe)
  - [Pojedynczy produkt](#pojedynczy-produkt)
  - [Koszyk i checkout](#koszyk-i-checkout)
- [ObsÅ‚uga bÅ‚Ä™dÃ³w](#obsluga-bledow)
  - [Konfiguracja Sentry](#konfiguracja-sentry)
  - [Komponent Error](#komponent-error)
- [Rozbudowa projektu](#rozbudowa-projektu)
- [Podusomowanie](#podsumowanie)
  - [Å¹rÃ³dÅ‚a](#zrodla)

## Konfiguracja

Zaczynamy od najmniej przyjemnej czÄ™Å›ci, czyli konfiguracji caÅ‚ego Å›rodowiska:

### Instalacja zaleÅ¼noÅ›ci

Lecimy z instalacjÄ… nowego projektu z wykorzystaniem Nexta:

```bash
npx create-next-app@latest --ts
```

Po wygenerowaniu projektu, zrÃ³bmy maÅ‚y porzÄ…dek. UsuÅ„my niepotrzebne pliki i style. NastÄ™pnie zainstalujmy wszystkie potrzebne paczki:

```bash
npm install @next-auth/prisma-adapter @prisma/client @sentry/nextjs @stripe/react-stripe-js @stripe/stripe-js @tailwindcss/forms react-query stripe yup && npm install --save-dev @headlessui/react @heroicons/react @tailwindcss/aspect-ratio @types/stripe tailwindcss autoprefixer postcss prettier eslint eslint-config-next eslint-plugin-jsx-a11y eslint-plugin-prettier eslint-plugin-react eslint-plugin-react-hooks husky lint-staged
```

### ESlint & Prettier

NiezbÄ™dna dla kaÅ¼dego projektu w JS/TS para narzÄ™dzi, czyli ESlint i Prettier. Tutaj sprawa dla Ciebie moÅ¼e wyglÄ…daÄ‡ inaczej, kaÅ¼dy ma swoje ulubione pluginy/zasady, u mnie wyglÄ…da to tak:

Prettier:

```json
{
  "tabWidth": 2,
  "printWidth": 100,
  "singleQuote": true,
  "trailingComma": "all",
  "semi": true
}
```

ESlint:

```json
{
  "root": true,
  "parser": "@typescript-eslint/parser",
  "extends": [
    "prettier",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "plugin:jsx-a11y/strict",
    "plugin:testing-library/recommended",
    "plugin:jest-dom/recommended",
    "next",
    "next/core-web-vitals"
  ],
  "plugins": [
    "jsx-a11y",
    "react-app",
    "react-hooks",
    "jest-dom",
    "testing-library",
    "@typescript-eslint",
    "prettier"
  ],
  "env": {
    "es6": true,
    "browser": true,
    "jest": true,
    "node": true
  },
  "rules": {},
  "parserOptions": {
    "ecmaVersion": 12,
    "sourceType": "module"
  }
}
```

### Husky & Lint-staged

O ile o poprzednich narzÄ™dziach kaÅ¼dy na pewno sÅ‚yszaÅ‚, to o tej dwÃ³jce juÅ¼ niekoniecznie. Te narzÄ™dzia w poÅ‚Ä…czeniu pozwalajÄ… nam korzystaÄ‡ z tzw. _Git hooks_ i odpalaÄ‡ konkretne skrypty przed np. zacommitowaniem zmian. A jakie mogÄ…Â byÄ‡ to skrypty i dlaczego wÅ‚aÅ›ciwie chcielibyÅ›my coÅ› takiego robiÄ‡? ğŸ¤” Idealnym przykÅ‚adem moÅ¼e byÄ‡ odpalenie ESlinta i Prettiera, po to, Å¼eby kod w zdalnym repozytorium nie miaÅ‚ jakiÅ›Â boli i Å¼eby speÅ‚niaÅ‚ okreÅ›lone reguÅ‚y.

Instalacja:

```bash
npx mrm@2 lint-staged
```

Ten skrypt wygeneruje nam folder `.husky` w katalogu gÅ‚Ã³wnym. To w nim moÅ¼emy tworzyÄ‡ poszczegÃ³lne _hooki_. W naszym przypadku ograniczymy siÄ™Â tylko do fazy _pre-commit_ i odpalimy konkretny skrypt:

```bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npm run pre-commit
```

Å»eby caÅ‚oÅ›Ä‡ zadziaÅ‚aÅ‚a tak, jak tego chcemy, musimy uzupeÅ‚niÄ‡ nasz `package.json`:

```json
 "scripts": {
    "pre-commit": "lint-staged"
  },
 "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md,yaml,yml,scss,css}": [
      "prettier --write"
    ],
    "*.js": "eslint --cache --fix"
  }
```

### TailwindCSS

Przez jednych kochany, przez drugich znienawidzony, TailwindCSS. Ja jestem gdzieÅ›Â po Å›rodku, ani nie kocham Tailwinda, ani mi on nie przeszkadza. Dlaczego wiÄ™c wÅ‚aÅ›nie go wybraÅ‚em do tego projektu? Na pewno nie moÅ¼na mu odmÃ³wiÄ‡ jednego, Å¼e bardzo szybko siÄ™ w nim prototypuje projekty i wÅ‚aÅ›nie to zadecydowaÅ‚o o jego miejscu tutaj ğŸï¸

Konfiguracja jest banalnie prosta, wystarczy jedna komenda:

```bash
npx tailwindcss init -p
```

Generuje ona dwa pliki: `tailwind.config.js` i `postcss.config.js`. My bÄ™dziemy rozbudowywaÄ‡ ten pierwszy:

```js
module.exports = {
  purge: ['./pages/**/*.{js,ts,jsx,tsx}', './components/**/*.{js,ts,jsx,tsx}'],
  darkMode: false,
  theme: {
    extend: {},
  },
  variants: {
    extend: { cursor: ['hover', 'focus'] },
  },
  plugins: [require('@tailwindcss/aspect-ratio'), require('@tailwindcss/forms')],
};
```

W pliku konfiguracyjnym dodajemy `purge`, czyli opcje, ktÃ³ra umoÅ¼liwi nam pozbycie siÄ™Â nieuÅ¼ywanych styli na produkcji. OprÃ³cz tego dodajemy dwa pluginy: `@tailwindcss/aspect-ratio` i `@tailwindcss/forms`.

Z racji tego, Å¼e bÄ™dziemy korzystaÄ‡ tylko z tego frameworka, bez innych customowych styli, wystarczy, Å¼e dodamy import w specjalnym pliku `_app.tsx`

```
import 'tailwindcss/tailwind.css';
```

VoilÃ  âœ¨

### React Query

React Query to Å›wietna biblioteka, ktÃ³ra w prosty sposÃ³b umoÅ¼liwia nam zarzÄ…dzanie tzw. Server State. Czekaj, czym? W aplikacjach frontendowych moÅ¼emy wyrÃ³Å¼niÄ‡ dwa podstawowe stany:

- Client State
- Server State

Ten pierwszy, obsÅ‚uguje rzeczy, ktÃ³re nie zmieniajÄ… siÄ™Â jakoÅ›Â czÄ™sto. Na pewno dobrze znacie globalny stan dla motywÃ³w, otwarcie/zamkniÄ™cie menu itp itd. **Server State** jest tym, co pobieramy z API, czyli w naszym przypadku bÄ™dÄ…Â to np. wszystkie produkty. Taki stan charakteryzuje siÄ™Â zupeÅ‚nie innymi wymaganiami niÅ¼ Client State. Paginacja, cache, infinite scroll, prefetching, refetching to tylko niektÃ³re z problemÃ³w, ktÃ³re rozwiÄ…zuje React Query. Ta libka dostarcza nam szereg przydatnych, w peÅ‚ni **otypowanych hookÃ³w**, ktÃ³re moÅ¼emy wykorzystaÄ‡ w projekcie.

Konfiguracja jest bardzo prosta, w `_app.tsx` dodajemy provider `QueryClientProvider`. Opakowujemy rÃ³wnieÅ¼ nasz komponent w `Hydrate`, czyli specjalny provider dla tzw. hydracji, o ktÃ³rej powiemy sobie trochÄ™ pÃ³Åºniej:

```tsx
import { useState } from 'react';
import type { AppProps } from 'next/app';
import { Hydrate, QueryClient, QueryClientProvider } from 'react-query';
import { ReactQueryDevtools } from 'react-query/devtools';
import 'tailwindcss/tailwind.css';

export default function App({ Component, pageProps }: AppProps) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <QueryClientProvider client={queryClient}>
      <Hydrate state={pageProps.dehydratedState}>
        <Component {...pageProps} />
      </Hydrate>
      <ReactQueryDevtools />
    </QueryClientProvider>
  );
}
```

### Zmienne Å›rodowiskowe

Ostatnia rzecz na naszej konfiguracyjnej liÅ›cie, czyli zmienne Å›rodowiskowe. Na razie nie bÄ™dziemy ich uzupeÅ‚niaÄ‡, za to stworzymy maÅ‚Ä… funkcje pomocniczÄ…, ktÃ³ra uÅ‚atwi nam pracÄ™ z nimi.

Na samym poczÄ…tku deklarujemy typy dla naszych zmiennych:

```ts
type NameToType = {
  readonly ENV: 'production' | 'staging' | 'development' | 'test';
  readonly NODE_ENV: 'production' | 'development';
  readonly PORT: number;
};
```

NastÄ™pnie implementujemy wÅ‚aÅ›ciwÄ… juÅ¼ funkcje `getEnv`. Korzystamy tutaj z tzw. [przeÅ‚adowania funkcji](https://www.typescriptlang.org/docs/handbook/2/functions.html#function-overloads). Ta funkcja daje nam dwie rzeczy:

- AutouzupeÅ‚nianie nazw
- WÅ‚aÅ›ciwy typ zmiennej

```ts
export function getEnv<Env extends keyof NameToType>(name: Env): NameToType[Env];
export function getEnv(name: keyof NameToType): NameToType[keyof NameToType] {
  const val = process.env[name];

  if (!val) {
    throw new Error(`Cannot find environmental variable: ${name}`);
  }

  return val;
}
```

Zobaczmy na jej wywoÅ‚anie, funkcja nie doÅ›Ä‡, Å¼e podpowiada nam nazwÄ™, to jeszcze wypluwa wczeÅ›niej okreÅ›lony typ, magia ğŸª„

<Image
  src="/images/fullstack-next/getEnv.png"
  alt="WywoÅ‚anie funkcji getEnv z argumentem NODE_ENV zwraca typ 'production' lub 'development'"
/>

## Baza danych

Do naszego projektu wybraÅ‚em PostgreSQL jako bazÄ™ danych, zarzÄ…dzaÄ‡ zapytaniami bÄ™dziemy przez PrismÄ™, ktÃ³ra jest wysokopoziomowym ORM, ale zanim to zrobimy skonfigurujmy Dockera:

## Kontenery i Docker

JeÅ›li jeszcze nie wiesz czym jest Docker, to zachÄ™cam CiÄ™ do sprawdzenia [dedykowanego filmu z wyjaÅ›nieniem](https://www.youtube.com/watch?v=P4ZC3cFN0WQ). Ja mistrzem Dockera nie jestem, dlatego korzystam z wczeÅ›niej przygotowanych setupÃ³w.

W naszym przypadku, taki _setup_ wrzucamy do specjalnego pliku `docker-compose.yml`, o ktÃ³rym wiÄ™cej przeczytasz w [dokumentacji](https://docs.docker.com/compose/). W samej konfiguracji deklarujemy dedykowany obraz dla Postgresa z konkretnÄ…Â wersjÄ…, wolumeny oraz porty.

```yml
version: '3.8'
services:
  postgres:
    image: postgres:14
    restart: always
    env_file:
      - .env
    volumes:
      - postgres:/var/lib/postgresql/data
    ports:
      - '5432:5432'
volumes:
  postgres:
```

ZwrÃ³Ä‡ uwagÄ™Â na `env_file`, to tutaj deklarujemy Å›cieÅ¼kÄ™Â do naszych zmiennych Å›rodowiskowych. Musimy je uzupeÅ‚niÄ‡ nastÄ™pujÄ…cymi danymi:

```
POSTGRES_USER=
POSTGRES_PASSWORD=
POSTGRES_DB=
DATABASE_URL="postgresql://<POSTGRES_USER>:<POSTGRES_PASSWORD>@<POSTGRES_HOST>:<POSTGRES_PORT>/<POSTGRES_DB>?schema=public&sslmode=prefer"
```

Wystarczy nam teraz odpaliÄ‡ aplikacjÄ™:

```bash
docker-compose up -d
```

JeÅ›li korzystasz z Docker Desktop, powinieneÅ› widzieÄ‡ tak dziaÅ‚ajÄ…ce kontenery:

<Image src="/images/fullstack-next/docker.png" alt="Dashboard w Docker Desktop" />

## Prisma

Jak juÅ¼ jesteÅ›my przy bazach danych, to przejdÅºmy do naszego rozwiÄ…zania ORM, czyli Prismy. Szczerze mÃ³wiÄ…c to jestem wielkim fanem tej technologii, praca z niÄ…Â to czysta przyjemnoÅ›Ä‡... Ale zacznijmy od poczÄ…tku, czym w ogÃ³le jest Prisma?

Prisma jest rozwiÄ…zaniem ORM, ktÃ³re w peÅ‚ni wspiera TypeScripta. Prisma udostÄ™pnia nam rÃ³wnieÅ¼ szereg przydatnych narzÄ™dzi do migracji, czy wizualizacji danych takich jak `prisma studio`. Oferuje nam ona w peÅ‚ni otypowany, wysokopoziomowy klient bazy danych. Bez zbÄ™dnego gadania, sprawdÅºmy jak to dziaÅ‚a!

<Image src="/images/fullstack-next/takemymoney.jpeg" alt="" />

## Tworzenie schemy

W pierwszej kolejnoÅ›ci do pracy z PrismÄ…Â niezbÄ™dna jest tzw. _schema_. To w niej bÄ™dziemy mieÄ‡ obraz tego, jak wyglÄ…dajÄ… nasze dane i relacje miÄ™dzy nimi. Mamy dwie opcje, jeÅ›li mamy zamodelowane wczeÅ›niej dane w PostgreSQL, to moÅ¼emy wygenerowaÄ‡ scheme automatycznie. JeÅ›li jednak, tak jak w naszym przypadku, startujemy od zera, to musimy stworzyÄ‡ schemat danych rÄ™cznie.

> JeÅ›li pracujesz z VSCode, przy pracy z PrismÄ… Twoim najlepszym przyjacielem bÄ™dzie [dedykowany plugin](https://marketplace.visualstudio.com/items?itemName=Prisma.prisma), ktÃ³ry koloruje skÅ‚adnie, formatuje i uzupeÅ‚nia plik ze schemÄ….

W katalogu gÅ‚Ã³wnym stwÃ³rz folder `prisma`, a w nim plik `schema.prisma`:

```
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
```

Na samym poczÄ…tku definiujemy podstawowÄ…Â konfiguracjÄ™Â i provider, czyli wczeÅ›niej wybranÄ… bazÄ™ danych. PrismÄ™Â moÅ¼emy wykorzystywaÄ‡ z rÃ³Å¼nymi narzÄ™dziami poczÄ…wszy od wÅ‚aÅ›nie Postgresa, idÄ…c przez MySQL, SQLite, a koÅ„czÄ…c na MongoDB.

Zdefiniujmy nasz pierwszy model, model uÅ¼ytkownika:

```
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
}
```

Na poczÄ…tku skÅ‚adnia moÅ¼e Ci siÄ™Â wydawaÄ‡Â dziwna, ale uwierz mi, Å¼e po krÃ³tkim zapoznaniu jest ona bardzo intuicyjna. Model zawsze deklarujemy z duÅ¼ej litery, a w nim opisujemy poszczegÃ³lne pola. KaÅ¼de pole posiada swÃ³j typ, ktÃ³ry moÅ¼e Ci przypominaÄ‡ typy chociaÅ¼by z TypeScripta oraz opcjonalnie listÄ™ atrybutÃ³w(`@`).

W tym przypadku wszystkie nasze pola sÄ… typu `String`. Identyfikator posiada dwa atrybuty, pierwszy `@id` odpowiada `PRIMARY KEY` w bazie danych. Konstrukcja `@default(cuid())` bÄ™dzie nam generowaÅ‚a automatycznie `id`. Dodajmy wiÄ™cej pÃ³l:

```
enum Role {
  USER
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  role          Role      @default(USER)
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  accounts      Account[]
  sessions      Session[]

  @@map("users")
}
```

PojawiÅ‚o nam siÄ™ tutaj sporo nowoÅ›ci. Zacznijmy od enuma, enum dziaÅ‚a podobnie jak w jÄ™zykach programowania, np. w TypeScript. MoÅ¼emy go rozumieÄ‡ tak, Å¼e rolÄ…Â uÅ¼ytkownika bÄ™dzie albo `USER` albo `ADMIN`. Atrybutu `@unique` uÅ¼ywamy do wskazania unikalnych wartoÅ›ci lub kombinacji wartoÅ›ci (`@@unique([pole1, pole2])`). A o co chodzi z tymi _mapami_?

Atrybut `@map("email_verified")` mapuje nam nazwÄ™ tego pola tak, aby w bazie danych byÅ‚a ona zapisana w innej konwencji nazewniczej. Podobnie jest z atrybutem `@@map("users")`, w tym przypadku zmieniamy nie nazwÄ™ atrybutu, a modelu i tabeli.

A o co chodzi z `Account[]` i `Session[]`? Tutaj do gry wchodzÄ…Â relacje. WeÅºmy za przykÅ‚ad sesjÄ™, mamy tutaj do czynienia z relacjÄ…Â jeden do wielu, czyli uÅ¼ytkownik moÅ¼e mieÄ‡ wiele sesji, ale sesja tylko jednego uÅ¼ytkownika, logiczne, prawda?

```
enum Role {
  USER
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  role          Role      @default(USER)
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  accounts      Account[]
  sessions      Session[]

  @@map("users")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}
```

W `Session` uÅ¼ywamy specjalnego atrybutu `@relation`, w ktÃ³rym deklarujemy `fields`, czyli pola **obecnego** modelu, `references`, czyli pola **relacyjnego** modelu oraz `onDelete`. `onDelete` jest tzw. akcjÄ…Â referencyjnÄ…, czyli "co siÄ™Â stanie, gdy uÅ¼ytkownik zostanie usuniÄ™ty"? W naszym przypadku, zostanie usuniÄ™ta rÃ³wnieÅ¼ sesja.

CaÅ‚a schema:

```
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String  @map("user_id")
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

enum Role {
  USER
  ADMIN
}

model User {
  id            String    @id @default(cuid())
  role          Role      @default(USER)
  name          String?
  email         String?   @unique
  emailVerified DateTime? @map("email_verified")
  image         String?
  accounts      Account[]
  sessions      Session[]

  @@map("users")
}

model Product {
  id          String @id
  description String
  name        String
  price       Int
  image       String
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id")
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}
```

## Migracje

Po tym, jak skoÅ„czyliÅ›my definiowaÄ‡ scheme, musimy wygenerowaÄ‡ migracjÄ™. Prisma tutaj znowu przychodzi nam z pomocÄ…Â i dzieje siÄ™ to w niej praktycznie z automatu:

```
npx prisma migrate dev
```

Po wygenerowaniu, migracje bÄ™dÄ… dostÄ™pne w katalogu `prisma`:

<Image src="/images/fullstack-next/migracje.png" alt="" />

Å»eby mieÄ‡Â najnowsze dane w kliencie Prismy, po kaÅ¼dej zmianie w schemie powinniÅ›my wykonaÄ‡Â polecenie:

```bash
npx prisma generate
```

<Newsletter />

## Layout

Uff, odpocznijmy na chwile od baz danych i przejdÅºmy do tego co frontendowcy lubiÄ…Â najbardziej, czyli _centrowania diva_.

Nasz `Header` w przyszÅ‚oÅ›ci bÄ™dzie odpowiadaÅ‚ za wyÅ›wietlenie zdjÄ™cia uÅ¼ytkownika oraz za akcje wylogowania, ale na ten moment skupmy siÄ™Â na samej strukturze:

```tsx
export const Header = () => {
  return (
    <header className="relative bg-white">
      <div className="max-w-7xl mx-auto px-4 sm:px-6">
        <nav className="flex justify-between items-center border-b-2 border-gray-100 py-6 md:justify-start md:space-x-10">
          <Logo />
          <div className="hidden md:flex items-center justify-end md:flex-1 lg:w-0">
            <img src="" className="w-16 h-16 rounded-full" alt="" />
            <button className="ml-8 whitespace-nowrap inline-flex items-center justify-center px-4 py-2 border border-transparent rounded-md shadow-sm text-base font-medium text-white bg-indigo-600 hover:bg-indigo-700">
              Wyloguj siÄ™
            </button>
          </div>
        </nav>
      </div>
    </header>
  );
};
```

Logo:

```tsx
export const Logo = () => (
  <div className="flex justify-start lg:w-0 lg:flex-1">
    <a href="#">
      <img
        className="h-8 w-auto sm:h-10"
        src="https://tailwindui.com/img/logos/workflow-mark-indigo-600.svg"
        alt=""
        width={40}
        height={44}
      />
    </a>
  </div>
);
```

Tak przygotowany komponent chcielibyÅ›my umieÅ›ciÄ‡ w komponencie `Layout`, ktÃ³ry oplecie wszystkie nasze strony:

```tsx
import type { ReactNode } from 'react';
import { Header } from './header/Header';

type LayoutProps = {
  readonly children: ReactNode;
};

export const Layout = ({ children }: LayoutProps) => (
  <>
    <Header />
    <main className="h-full w-full bg-white py-16 px-4 flex flex-col items-center justify-center">
      <h1 className="text-5xl font-extrabold tracking-tight text-gray-900 self-center">
        FullStack Next.js E-commerce
      </h1>
      {children}
    </main>
  </>
);
```

ZwrÃ³Ä‡ uwagÄ™Â na typ podawanych przeze mnie propsÃ³w i sposÃ³b typowania komponentÃ³w. Celowo nie korzystam tutaj z `React.FC`, wiÄ™cej o wadach tego typu mÃ³wiÅ‚em w artykule [React Children + TypeScript](https://frontlive.pl/blog/react-children-i-typescript). Propsy deklaruje z dodatkiem `readonly`, po prostu lubiÄ™ mieÄ‡ niemutowalne dane.

Tak przygotowany kawaÅ‚ek kodu uÅ¼ywamy na stronie gÅ‚Ã³wnej:

```tsx
export default function Home() {
  return <Layout>...</Layout>;
}
```

Dodajmy jeszcze brakujÄ…cÄ… specjalnÄ… stronÄ™ w `_document.tsx`:

```tsx
import Document, { Head, Html, NextScript, DocumentContext } from 'next/document';
import { Layout } from '../components/layout/Layout';

export default class MyDocument extends Document {
  static async getInitialProps(ctx: DocumentContext) {
    const initialProps = await Document.getInitialProps(ctx);

    return { ...initialProps };
  }
  render() {
    return (
      <Html lang="pl-PL" className="h-full">
        <Head></Head>
        <body className="h-full">
          <NextScript />
        </body>
      </Html>
    );
  }
}
```

JeÅ›li wszystko poszÅ‚o zgodnie z planem, to `Header` w naszej aplikacji powinien wyglÄ…daÄ‡ nastÄ™pujÄ…co:

<Image
  src="/images/fullstack-next/header.png"
  alt="GÅ‚Ã³wny header aplikacji. SkÅ‚ada siÄ™ on z niebieskiego, abstrakcyjnego loga, zdjÄ™cia uÅ¼ytkownika oraz przycisku 'Wyloguj siÄ™'"
/>

## Produkty

Lecimy w koÅ„cu z czymÅ›Â konkretnym, czyli utworzeniem listy produktÃ³w:

### Karta produktu

Zacznijmy od komponentu karty i stworzenia pliku `Product.tsx`:

```tsx
import type Prisma from '@prisma/client';

type ProductProps = Readonly<Prisma.Product>;

export const Product = (product: ProductProps) => {
  const { id, image, name, price } = product;

  return (
    <article className="group relative">
      <div className="w-full min-h-80 bg-gray-200 aspect-w-1 aspect-h-1 rounded-md overflow-hidden lg:h-80 lg:aspect-none">
        <img className="w-full h-full object-center object-cover lg:w-full lg:h-full" alt="" />
      </div>
      <div className="mt-4 flex justify-between">
        <h2 className="text-sm text-gray-700">
          <span aria-hidden="true" className="absolute inset-0" />
        </h2>
        <p className="text-sm font-medium text-gray-900"></p>
      </div>
      <button className="mt-6 group outline-none relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none">
        Kup
      </button>
      <button className="mt-4 group outline-none relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-black bg-gray-100 hover:bg-gray-300 focus:outline-none">
        Dodaj do koszyka
      </button>
    </article>
  );
};
```

To co na pewno przykuÅ‚o TwojÄ…Â uwagÄ™Â to typ `Prisma.Product`. Tutaj wÅ‚aÅ›nie zaczyna siÄ™Â pojawiaÄ‡ caÅ‚a magia Prismy, generuje ona z wczeÅ›niej stworzonej schemy TypeScriptowe typy. Dla kaÅ¼dego modelu mamy osobny typ:

```tsx
import type Prisma from '@prisma/client';

// type ProductProps = {
//   readonly id: string;
//   readonly description: string;
//   readonly name: string;
//   readonly price: number;
//   readonly image: string;
// }; ğŸ‘‡

type ProductProps = Readonly<Prisma.Product>;
```

### Endpoint z Next API Routes

ZaczÄ™liÅ›my mÃ³wiÄ‡ o typach, a jeszcze nie pobraliÅ›my danych! Do pobrania danych z bazy wykorzystamy oczywiÅ›cie PrismÄ™Â w poÅ‚Ä…czeniu z tzw. API Routes z Nexta. W katalogu `pages` tworzymy folder `api`, a w nim `products/index.ts`. JeÅ›li miaÅ‚eÅ› wczeÅ›niej do czynienia z Expressem, ta konstrukcja bÄ™dzie dla Ciebie znajoma. Å»eby stworzyÄ‡ API Route potrzebujemy po prostu wyeksportowaÄ‡ funkcjÄ™:

```tsx
import type { NextApiRequest, NextApiResponse } from 'next';

export default async (req: NextApiRequest, res: NextApiResponse) => {};
```

Mamy w niej dostÄ™p do specjalnych obiektÃ³w Å¼Ä…dania i odpowiedzi przygotowanych przez Nexta. Jak juÅ¼ Ci wspominaÅ‚em, Prisma oferuje nam wysokopoziomowy klient dla bazy danych, zobacz w jak prosty sposÃ³b moÅ¼emy zaciÄ…gnÄ…Ä‡ wszystkie produkty:

```tsx
import { NextApiRequest, NextApiResponse } from 'next';
import { PrismaClient } from '@prisma/client';

export default async (req: NextApiRequest, res: NextApiResponse) => {
  const prisma = new PrismaClient();

  const products = await prisma.product.findMany(); // typ: Array<Prisma.Product>
};
```

Na samym poczÄ…tku inicjalizujemy nowego klienta, z ktÃ³rego pÃ³Åºniej moÅ¼emy skorzystaÄ‡ i pobraÄ‡ produkty. Korzystamy tutaj z metody `findMany`, ktÃ³ra zwraca tablicÄ™Â produktÃ³w typu `Array<Prisma.Product>`, dokÅ‚adnie tak samo jak zadeklarowaliÅ›my w komponencie `Product`.

Co najlepsze takie zapytania moÅ¼emy w rÃ³Å¼ny sposÃ³b modyfikowaÄ‡, np. wybraÄ‡ tyle uÅ¼ytkownikÃ³w o okreÅ›lonej nazwie:

````tsx
const users = await prisma.user.findMany({
  where: {
    name: 'Olaf',
  },
})```
````

DokÅ‚adnie tak samo sprawa wyglÄ…da z [relacjami](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#relation-filters).

Nasz caÅ‚y endpoint:

```tsx
import { NextApiRequest, NextApiResponse } from 'next';
import { PrismaClient } from '@prisma/client';

export default async (req: NextApiRequest, res: NextApiResponse) => {
  const prisma = new PrismaClient();

  const products = await prisma.product.findMany();

  if (products.length) {
    res.status(200).json(products);
    res.end();
  } else {
    res.status(404);
    res.end();
  }
};
```

### ZaciÄ…ganie produktÃ³w z React Query

Naszym bazowym budulcem przy fetchowaniu produktÃ³w z API bÄ™dzie pomocnicza funkcja `fetcher`, ktÃ³rÄ… na pewno niejednokrotnie implementowaÅ‚eÅ› w swoich projektach, zobaczmy jak bÄ™dzie to wyglÄ…daÅ‚o w naszym przypadku. To co bÄ™dzie nieco niestandardowe w naszym przypadku, to wykorzystanie walidacji i biblioteki Yup, zobaczmy jak wyglÄ…dajÄ… typy:

```ts
import type { AnySchema, InferType } from 'yup';

export type HTTPMethod =
  | 'GET'
  | 'HEAD'
  | 'POST'
  | 'PUT'
  | 'DELETE'
  | 'CONNECT'
  | 'OPTIONS'
  | 'TRACE'
  | 'PATCH';

type FetcherConfig<Schema extends AnySchema | null> = {
  readonly method: HTTPMethod;
  readonly schema: Schema;
  readonly body?: object;
  readonly config?: RequestInit;
};
```

Deklarujemy generyczny typ `FetcherConfig`, ktÃ³ry bÄ™dzie przyjmowaÅ‚ dowolnÄ… schemÄ™ z Yup'a lub `null`. WewnÄ…trz okreÅ›lamy jeszcze typ metodyÂ HTTP, body i konfiguracjÄ™ funkcji `fetch()`.

W przypadku _fetchera_, tak jak przy zmiennych Å›rodowiskowych, korzystamy z przeÅ‚adowania funkcji. Pod maskÄ…Â kryje siÄ™Â zwykÅ‚y `fetch` oraz sprawdzanie poprawnoÅ›ci schemy z wykorzystaniem metody `cast()` z Yup'a:

```ts
import { ResponseError } from './responseError';

export async function fetcher<Schema extends null>(
  path: string,
  { method, body, config, schema }: FetcherConfig<Schema>,
): Promise<null>;

export async function fetcher<Schema extends AnySchema>(
  path: string,
  { method, body, config, schema }: FetcherConfig<Schema>,
): Promise<InferType<Schema>>;

export async function fetcher<Schema extends AnySchema | null>(
  path: string,
  { method, body, config, schema }: FetcherConfig<Schema>,
) {
  try {
    const response = await fetch(path, {
      ...config,
      headers: {
        'Content-Type': 'application/json',
      },
      credentials: 'include',
      method,
      ...(body && { body: JSON.stringify(body) }),
    });
    if (response.ok) {
      if (!schema) {
        return null;
      }

      const data = await response.json();

      return schema.cast(data);
    }
    throw new ResponseError(response.statusText, response.status);
  } catch (err) {
    if (err instanceof ResponseError) {
      throw err;
    }
    throw new ResponseError('Something went wrong during fetching!');
  }
}
```

W Å›rodku rzucamy wyjÄ…tkiem `ResponseError`, ktÃ³ry jest customowÄ… klasÄ…Â dziedziczÄ…cÄ…Â po `Error`:

```ts
export class ResponseError extends Error {
  constructor(message: string, public readonly status?: number) {
    super(message);
    this.name = 'ResponseError';
    Object.setPrototypeOf(this, ResponseError.prototype);
  }
}
```

Ta funkcja na pierwszy rzut oka moÅ¼e wydawaÄ‡Â Ci siÄ™Â skomplikowana, nic bardziej mylnego, trochÄ™ obraz zaciemnia to przeÅ‚adowanie funkcyjne, ale logika nie jest zawiÅ‚a. Zobaczmy jak to dziaÅ‚a w praktyce:

```ts
export const getProducts = async () => {
  return await fetcher('/api/products', {
    method: 'GET',
    schema: productsSchema,
  });
};
```

W katalogu `products/api/` definiujemy funkcje `getProducts`, ktÃ³ra oplata fetchera. Ostatnim brakujÄ…cym elementem w naszej ukÅ‚adance jest schema.

Konstruujemy w niej zarys danych. ZwrÃ³Ä‡ uwagÄ™Â na typ `y.SchemaOf<Prisma.Product>`, dziÄ™ki niemu wymuszamy na walidatorze konkretny typ, w tym przypadku typ produktu z Prismy:

```ts
import * as y from 'yup';
import type Prisma from '@prisma/client';

export const productSchema: y.SchemaOf<Prisma.Product> = y.object().shape({
  id: y.string().required(),
  description: y.string().required(),
  name: y.string().required(),
  price: y.number().required(),
  image: y.string().required(),
});

export const productsSchema = y.array(productSchema);
```

Nasze pomocnicze funkcje przygotowane, wiÄ™c moÅ¼emy przejÅ›Ä‡ do React Query. Biblioteka udostÄ™pnia nam specjalnego hooka `useQuery`, do ktÃ³rego podajemy id zapytania `products` oraz funkcjÄ™, ktÃ³ra zwraca promise:

```ts
import { useQuery } from 'react-query';
import { getProducts } from '../api/getProducts';

export const useGetProducts = () => {
  return useQuery('products', getProducts);
};
```

Ja lubiÄ™ kaÅ¼dÄ…Â takÄ…Â konstrukcjÄ™Â opakowywaÄ‡ w jeszcze osobnego hooka. Po pierwszy moÅ¼emy go wtedy dowolnie reuÅ¼ywaÄ‡, a poza tym caÅ‚oÅ›Ä‡Â wyglÄ…da nieco bardziej czytelnie.

Gdy hook jest juÅ¼ przygotowany, moÅ¼emy w koÅ„cu zabraÄ‡ siÄ™Â za wyÅ›wietlenie produktÃ³w z realnymi danymi i stworzyÄ‡ komponent `Products`:

```tsx
import { Product } from './Product';
import { useGetProducts } from './hooks/useGetProducts';

export const Products = () => {
  const { data: products } = useGetProducts();

  return (
    <div className="bg-white max-w-2xl mx-auto py-16 px-4 sm:py-24 sm:px-6 lg:max-w-7xl lg:px-8 mt-6 grid grid-cols-1 gap-y-10 gap-x-6 sm:grid-cols-2 lg:grid-cols-4 xl:gap-x-8">
      {products && products.map((product) => <Product key={product.id} {...product} />)}
    </div>
  );
};
```

<Image src="/images/fullstack-next/react-query-devtools.png" alt="" />

Ostatni temat na naszej liÅ›cie jeÅ›li chodzi o pobieranie produktÃ³w, czyli hydracja. W pliku `_app.tsx` zadeklarowaliÅ›my wrapper `Hydrate` na nasz komponent:

```tsx
<Hydrate state={pageProps.dehydratedState}>
  <Component {...pageProps} />
</Hydrate>
```

Hydracja z React Query, w poÅ‚Ä…czeniu z Nextem, pozwala nam pobraÄ‡Â potrzebne dane na serwerze, np. podczas _builda_. Tylko wÅ‚aÅ›ciwie po co to wszystko, skoro moglibyÅ›my po prostu uÅ¼yÄ‡ `useGetProducts()` w komponencie i pobraÄ‡ dane po stronie klienta? Wykorzystanie hydracji sprawia, Å¼e nie bÄ™dziemy musieli w ogÃ³lne czekaÄ‡ na dane, bÄ™dÄ… one dostÄ™pne natychmiasto. Do uzyskania takiego efektu wystarczy nam stworzenie nowego klienta `QueryClient` oraz wywoÅ‚anie metody `prefetchQuery` z odpowiednim `id` zapytania oraz funkcjÄ…, ktÃ³ra pobierze potrzebne dane:

```tsx
import type { GetStaticProps } from 'next';
import { dehydrate, QueryClient } from 'react-query';
import { Products } from '../components/products/Products';
import { getProducts } from '../components/products/api/getProducts';
import { Layout } from '../components/layout/Layout';

export default function Home() {
  return (
    <Layout>
      <Products />
    </Layout>
  );
}

export const getStaticProps: GetStaticProps = async () => {
  const queryClient = new QueryClient();

  await queryClient.prefetchQuery('products', getProducts);

  return {
    props: { dehydratedState: dehydrate(queryClient) },
  };
};
```

W tym przypadku korzystamy z podejÅ›cia _SSG_ wykorzystujÄ…c funkcjÄ™ `getStaticProps`, ale rÃ³wnie dobrze moglibyÅ›my to samo zrobiÄ‡ korzystajÄ…c z Server Side Renderingu i `getServerSideProps`. To podejÅ›cie jest doÅ›Ä‡Â niecodzienne, normalnie w `getStaticProps` zwracamy obiekt z propsami, ktÃ³ry pÃ³Åºniej moÅ¼emy wykorzystaÄ‡Â z komponencie, tutaj sprawa wyglÄ…da zupeÅ‚nie inaczej. W tym przypadku nasze propsy wykorzystujemy nie w komponencie samej strony, a w pliku `_app.tsx` w komponencie `Hydrate`. DziÄ™ki temu moÅ¼emy nie tylko mieÄ‡Â natychmiastowo pobrane dane, ale rÃ³wnieÅ¼ wykorzystywaÄ‡ je w podrzÄ™dnych komponentach bez przekazywania propsÃ³w w dÃ³Å‚.

<Image
  src="/images/fullstack-next/hydracja.png"
  alt="Diagram przedstawiajÄ…cy przepÅ‚yw produktÃ³w pomiÄ™dzy czÄ™Å›ciami aplikacji korzystajÄ…c z hydracji"
/>

## Koszyk

W naszej aplikacji bÄ™dziemy mieli dwa sposoby na zakup produktu. Numero uno, pojedyÅ„czy zakup oraz numero duo, czyli koszyk zakupowy ğŸ›’

### Koszyk w TailwindCSS

Koszyk bÄ™dzie siÄ™Â skÅ‚adaÅ‚ z trzech bazowych komponentÃ³w, na pierwszy ogieÅ„ leci `CartItem`:

```tsx
import type Prisma from '@prisma/client';

type CartItemProps = Prisma.Product;

export const CartItem = (product: CartItemProps) => {
  return (
    <li className="py-6 flex">
      <div className="flex-shrink-0 w-24 h-24 border border-gray-200 rounded-md overflow-hidden">
        <img alt="" className="w-full h-full object-center object-cover" />
      </div>
      <div className="ml-4 flex-1 flex flex-col">
        <div className="flex justify-between text-base font-medium text-gray-900">
          <h3></h3>
          <p className="ml-4"></p>
        </div>
        <div className="flex-1 flex items-end justify-between text-sm">
          <div className="flex">
            <button type="button" className="font-medium text-indigo-600 hover:text-indigo-500">
              UsuÅ„
            </button>
          </div>
        </div>
      </div>
    </li>
  );
};
```

Korzystamy tutaj ponownie z typÃ³w z Prismy, na pewno zauwaÅ¼yÅ‚eÅ›, Å¼e tworzÄ™ tutaj alias `CartItemProps` dla typu `Prisma.Product`. Nie stoi za tym Å¼adna wiÄ™ksza filozofia, a bardziej trzymanie siÄ™Â pewnej konwencji. Bardzo podobnie bÄ™dzie wyglÄ…daÅ‚ komponent `CartItems`, ktÃ³ry mapuje po `products` i wypluwa listÄ™Â produktÃ³w:

```tsx
import type Prisma from '@prisma/client';
import { CartItem } from './CartItem';

type CartItemsProps = {
  readonly products: Array<Prisma.Product>;
};

export const CartItems = ({ products }: CartItemsProps) => (
  <ul className="-my-6 divide-y divide-gray-200">
    {products.map((product) => (
      <CartItem key={product.id} {...product} />
    ))}
  </ul>
);
```

Ostatni z trÃ³jki komponentÃ³w koszyka: `Checkout`. To w nim umieÅ›cimy czÄ™Å›Ä‡ logiki odpowiadajÄ…cej za otwieranie/zamykanie menu, czy przejÅ›cie do pÅ‚atnoÅ›ci. Poza samymi stylami korzystam tutaj jeszcze z biblioteki `@headlessui`. Jest to bardzo fajna libka od twÃ³rcÃ³w Tailwinda. Oferuje ona w peÅ‚ni dostÄ™pne, nieostylowane komponenty, gotowe do szybkiego uÅ¼ycia:

```tsx
import { Dispatch, Fragment, SetStateAction } from 'react';
import { Dialog, Transition } from '@headlessui/react';
import { XIcon } from '@heroicons/react/outline';
import { CartItems } from './CartItems';

export const Checkout = () => {
  return (
    <Transition.Root as={Fragment}>
      <Dialog as="div" className="fixed inset-0 overflow-hidden">
        <div className="absolute inset-0 overflow-hidden">
          <Transition.Child
            as={Fragment}
            enter="ease-in-out duration-500"
            enterFrom="opacity-0"
            enterTo="opacity-100"
            leave="ease-in-out duration-500"
            leaveFrom="opacity-100"
            leaveTo="opacity-0"
          >
            <Dialog.Overlay className="absolute inset-0 bg-gray-500 bg-opacity-75 transition-opacity" />
          </Transition.Child>

          <div className="fixed inset-y-0 right-0 pl-10 max-w-full flex">
            <Transition.Child
              as={Fragment}
              enter="transform transition ease-in-out duration-500 sm:duration-700"
              enterFrom="translate-x-full"
              enterTo="translate-x-0"
              leave="transform transition ease-in-out duration-500 sm:duration-700"
              leaveFrom="translate-x-0"
              leaveTo="translate-x-full"
            >
              <div className="w-screen max-w-md">
                <div className="h-full flex flex-col bg-white shadow-xl overflow-y-scroll">
                  <div className="flex-1 py-6 overflow-y-auto px-4 sm:px-6">
                    <div className="flex items-start justify-between">
                      <Dialog.Title className="text-lg font-medium text-gray-900">
                        Koszyk
                      </Dialog.Title>
                      <div className="ml-3 h-7 flex items-center">
                        <button
                          type="button"
                          className="-m-2 p-2 text-gray-400 hover:text-gray-500"
                        >
                          <span className="sr-only">Zamknij</span>
                          <XIcon className="h-6 w-6" aria-hidden="true" />
                        </button>
                      </div>
                    </div>
                    <div className="mt-8 flow-root">
                      <CartItems products={products} />
                    </div>
                  </div>
                  <div className="border-t border-gray-200 py-6 px-4 sm:px-6">
                    <div className="flex justify-between text-base font-medium text-gray-900">
                      <p></p>
                      <p></p>
                    </div>

                    <div className="mt-6">
                      {products.length > 0 ? (
                        <button className="w-full flex justify-center items-center px-6 py-3 border border-transparent rounded-md shadow-sm text-base font-medium text-white bg-indigo-600 hover:bg-indigo-700">
                          Do kasy
                        </button>
                      ) : null}
                    </div>
                  </div>
                </div>
              </div>
            </Transition.Child>
          </div>
        </div>
      </Dialog>
    </Transition.Root>
  );
};
```

<Image src="/images/fullstack-next/koszyk.png" alt="" />

### Globalny stan z React.Context

UI gotowe, to pora na prawdziwe miÄ™sko, czyli logikÄ™ koszyka. W tym przypadku, zamiast wymyÅ›lnych technologii do zarzÄ…dzania stanem, postanowiÅ‚em pÃ³jÅ›Ä‡ w klasykÄ™, czyli `React.Context`.

```tsx
import { ReactNode, createContext, useReducer, useContext, useMemo, useState } from 'react';
import { cartReducer } from './reducers/cartReducer';
import type { Action, State } from './types';

type Dispatch = (action: Action) => void;
type CartProviderProps = { readonly children: React.ReactNode };

export const CartStateContext = createContext<{ state: State; dispatch: Dispatch } | undefined>(
  undefined,
);

const initialState: State = { products: [], totalPrice: 0, isOpen: false };

export const CartProvider = ({ children }: CartProviderProps) => {
  const [state, dispatch] = useReducer(cartReducer, initialState);

  const value = useMemo(() => ({ state, dispatch }), [state]);

  return <CartStateContext.Provider value={value}>{children}</CartStateContext.Provider>;
};
```

JeÅ›li pracowaÅ‚eÅ› wczeÅ›niej z contextem, to nie powinno byÄ‡ tutaj dla Ciebie Å¼adnych niespodzianek. Jeden fajny tip, ktÃ³ry mogÄ™Â Ci sprzedaÄ‡ to wykorzystanie `React.useMemo()` przy wartoÅ›ci podawanej do Providera, potrafi to zrobiÄ‡ niemaÅ‚Ä… rÃ³Å¼nicÄ™Â w wydajnoÅ›ci.

Typy wyglÄ…dajÄ… nastÄ™pujÄ…co, deklarujemy akcje, ktÃ³re sÄ…Â uniÄ…Â obiektÃ³w oraz stan, ktÃ³ry bÄ™dziemy przekazywaÄ‡ do Providera:

```tsx
import type Prisma from '@prisma/client';

export type Action =
  | { type: 'addProduct'; payload: Prisma.Product }
  | { type: 'deleteProduct'; payload: Prisma.Product }
  | { type: 'openMenu' }
  | { type: 'closeMenu' };

export type State = {
  readonly products: Array<Prisma.Product>;
  readonly totalPrice: number;
  readonly isOpen: boolean;
};
```

W `cartReducer` kryje siÄ™Â caÅ‚a logika. To tutaj deklarujemy akcje dla koszyka `addProduct` i `deleteProduct`. Kalkulujemy rÃ³wnieÅ¼ Å‚Ä…cznÄ… wartoÅ›Ä‡ koszyka oraz podajemy akcje odpowiadajÄ…ce za stan jego otwarcia:

```tsx
import type Prisma from '@prisma/client';
import type { Action, State } from '../types';

const calculateTotalPrice = (products: Array<Prisma.Product>) => {
  return products.reduce((acc, curr) => acc + curr.price, 0);
};

export const cartReducer = (state: State, action: Action) => {
  switch (action.type) {
    case 'addProduct': {
      const products = [...state.products];
      const newProduct = action.payload;
      const isTheNewProductInCart = products.find((product) => product.id === newProduct.id);

      const newProducts = [newProduct, ...products];

      const totalPrice = calculateTotalPrice(newProducts);

      if (!isTheNewProductInCart) {
        return {
          ...state,
          products: newProducts,
          totalPrice,
        };
      }
    }
    case 'deleteProduct': {
      const products = [...state.products];
      const productToDelete = action.payload;

      const newProducts = products.filter((product) => product.id !== productToDelete.id);

      const totalPrice = calculateTotalPrice(newProducts);

      return {
        ...state,
        products: newProducts,
        totalPrice,
      };
    }
    case 'openMenu': {
      return {
        ...state,
        isOpen: true,
      };
    }
    case 'closeMenu': {
      return {
        ...state,
        isOpen: false,
      };
    }

    default: {
      throw new Error(`Unhandled action type`);
    }
  }
};
```

Gdy nasz context jest juÅ¼ gotowy, moÅ¼emy dodaÄ‡ Provider do `_app.tsx`:

```tsx
<Hydrate state={pageProps.dehydratedState}>
  <CartProvider>
    <Component {...pageProps} err={err} />
  </CartProvider>
</Hydrate>
```

Bardzo czÄ™sto spotykanÄ… praktykÄ…Â podczas wykorzystania contextu, jest tworzenie specjalnego hooka zwracajÄ…cego wartoÅ›Ä‡ stanu, nie inaczej jest w naszym przypadku:

```tsx
import { useMemo, useContext } from 'react';

import { CartStateContext } from '../context/cartContext';

export const useCart = () => {
  const context = useContext(CartStateContext);
  if (context === undefined) {
    throw new Error('useCount must be used within a CountProvider');
  }
  return useMemo(() => context, [context]);
};
```

W komponencie `Checkout` wykorzystujemy dane z hooka i okreÅ›lamy akcje dla stanu menu:

```tsx
export const Checkout = () => {
  const {
    state: { totalPrice, products, isOpen },
    dispatch,
  } = useCart();

  const handleOpenMenu = () => dispatch({ type: 'openMenu' });
  const handleCloseMenu = () => dispatch({ type: 'closeMenu' });

 ...
};
```

Context przyda nam siÄ™ rÃ³wnieÅ¼ w `CartItem`, gdzie bÄ™dziemy korzystali z akcji usuwania produktu z koszyka:

```tsx
export const CartItem = (product: CartItemProps) => {
  const { id, name, price, image } = product;
  const { dispatch } = useCart();

  const handleDelete = (product: Prisma.Product) => {
    dispatch({ type: "deleteProduct", payload: product });
  };

  ...
```

Ostatnim miejscem, ktÃ³re potrzebuje danych z naszego contextu jest komponent `Product`:

```tsx
export const Product = (product: ProductProps) => {
  const { id, image, name, price } = product;
  const { dispatch } = useCart();

  const addToCart = () => {
    dispatch({ type: 'addProduct', payload: product });
    dispatch({ type: 'openMenu' });
  };

  ...
};
```

## Uwierzytelnianie

Prawie kaÅ¼da wspÃ³Å‚czesna aplikacja posiada system logowania uÅ¼ytkownikÃ³w, dlatego tej waÅ¼nej funkcjonalnoÅ›ci nie mogÅ‚o zabraknÄ…Ä‡ w naszym sklepie. Uwierzytelnianie w aplikacjach czÄ™sto wyglÄ…da w bardzo podobny sposÃ³b, dlatego spoÅ‚ecznoÅ›Ä‡ Next.js wyszÅ‚a z inicjatywÄ…Â i stworzyÅ‚a bibliotekÄ™ NextAuth, ktÃ³ra umoÅ¼liwia nam uwierzytelnianie za pomocÄ…Â rÃ³Å¼nych providerÃ³w. My bÄ™dziemy korzystaÄ‡ z GitHuba, ale w bardzo prosty sposÃ³b moÅ¼esz dodaÄ‡ do swojej aplikacji logowanie z pomocÄ… maila, Googla, Facebooka itp.

### Konfiguracja NextAuth

Konfiguracja logowania jest bardzo prosta. Zaczynamy od stworzenia specjalnego pliku w katalogu `pages/api/auth` o specyficznej nazwie `[...nextauth].tsx`. Tworzymy w nim coÅ›Â podobnego na wzÃ³r endpointa z Next API Routes. W wyeksporowanej funkcji `NextAuth` podajemy obiekt konfiguracyjny, a w nim deklarujemy rodzaj providera i adaptera. Adapter jest systemem, do ktÃ³rego NextAuth siÄ™Â *podÅ‚Ä…cza*, tworzy sesje i konta uÅ¼ytkownikÃ³w. W naszym przypadku adapterem jest Prisma. NextAuth w pewien sposÃ³b definiuje [model danych w schemie](https://next-auth.js.org/adapters/prisma), tak abyÅ›my nie musieli nic dodatkowego tworzyÄ‡.

```tsx
import { PrismaClient } from '@prisma/client';
import NextAuth from 'next-auth';
import GitHubProvider from 'next-auth/providers/github';
import { PrismaAdapter } from '@next-auth/prisma-adapter';
import { getEnv } from '../../../utils/env';

const prisma = new PrismaClient();

export default NextAuth({
  providers: [
    GitHubProvider({
      clientId: getEnv('GITHUB_ID'),
      clientSecret: getEnv('GITHUB_SECRET'),
    }),
  ],
  adapter: PrismaAdapter(prisma),
  secret: getEnv('SECRET'),
});
```

Sekret to ciÄ…g znakÃ³w, ktÃ³ry uÅ¼ywany jest do hashowania tokenÃ³w/szyfrowania ciasteczek.

JeÅ›li chodzi o stronÄ™Â serwerowÄ…, to nasza konfiguracja gotowa. Aby korzystaÄ‡Â z infromacjach o sesji, naszÄ… aplikacjÄ™Â frontendowÄ… musimy opakowaÄ‡ w specjalny provider:

```tsx
import { useState } from 'react';
import type { AppProps } from 'next/app';
import { Hydrate, QueryClient, QueryClientProvider } from 'react-query';
import { ReactQueryDevtools } from 'react-query/devtools';
import { SessionProvider } from 'next-auth/react';
import 'tailwindcss/tailwind.css';
import { CartProvider } from '../components/cart/context/cartContext';

export default function App({ Component, pageProps, err }: AppProps & { err: Error }) {
  const [queryClient] = useState(() => new QueryClient());

  return (
                                {/* any âŒ */}
    <SessionProvider session={pageProps.session}>
      <QueryClientProvider client={queryClient}>
        <Hydrate state={pageProps.dehydratedState}>
          <CartProvider>
            <Component {...pageProps} err={err} />
          </CartProvider>
        </Hydrate>
        <ReactQueryDevtools />
      </QueryClientProvider>
    </SessionProvider>
  );
}
```

To co mi siÄ™Â nie podoba w tym miejscu, to typ `any` dla sesji. JeÅ›li chcielibyÅ›my to zmieniÄ‡, to powinniÅ›my zadeklarowaÄ‡ plik `next.ds.ts`, w ktÃ³rym _poprawimy_ typy:

```ts
import type { NextComponentType, NextPageContext } from 'next';
import type { Session } from 'next-auth';
import type { Router } from 'next/router';

declare module 'next/app' {
  type AppProps<P = Record<string, unknown>> = {
    Component: NextComponentType<NextPageContext, any, P>;
    router: Router;
    __N_SSG?: boolean;
    __N_SSP?: boolean;
    pageProps: P & {
      session?: Session;
    };
  };
}
```

Identycznie robimy z typami dla sesji uÅ¼ytkownika w pliku `next-auth.d.ts`:

```ts
import { Session } from 'next-auth';
import type Prisma from '@prisma/client';

declare module 'next-auth' {
  interface Session {
    user: Prisma.User;
  }
}
```

### Pomocnicze hooki i przekierowania

Teraz, gdy nasza konfiguracja jest gotowa, moÅ¼emy przejÅ›Ä‡ do logowania i odczytywania sesji dla uÅ¼ytkownika. NextAuth udostÄ™pnia nam pomocnicze funkcje do logowania, wylogowania i odczytywania sesji. Podobnie jak w przypadku React Query, ja lubiÄ™ opakowaÄ‡ udostÄ™pnionego przez bibliotekÄ™Â hooka `useSession()` w dodatkowy wrapper `useAuth()`:

```tsx
import { useMemo } from 'react';
import { useSession, signIn, signOut } from 'next-auth/react';

export const useAuth = () => {
  const { data: session, status } = useSession();

  return useMemo(
    () =>
      ({
        session,
        status,
        signIn,
        signOut,
      } as const),
    [session, status],
  );
};
```

NextAuth poza systemem do uwierzytelniania, oferuje nam rÃ³wnieÅ¼ predefiniowane strony do logowania. W mojej opinii nie wyglÄ…dajÄ… one zbyt dobrze i nie wpasowujÄ… siÄ™Â w styl naszej apki, dlatego dostarczymy nasze customowe rozwiÄ…zanie. Tworzymy nowÄ… stronÄ™ `signin` w folderze `pages/auth`, w ktÃ³rej wykorzystujemy funkcjÄ™Â `signIn` z hooka `useAuth`:

```tsx
import { Layout } from '../../components/layout/Layout';
import { SignInButton } from '../../components/auth/SignInButton';
import { useAuth } from './hooks/useAuth';

export default function SignIn() {
  const { signIn } = useAuth();
  const handleSignIn = () => signIn('github');

  return (
    <Layout>
      <button
        onClick={handleSignIn}
        className="mt-6 group outline-none relative w-28 flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none"
      >
        Zaloguj siÄ™
      </button>
    </Layout>
  );
}
```

W pliku konfiguracyjnym biblioteki dajemy znaÄ‡, Å¼e chcemy korzystaÄ‡Â z wÅ‚asnorÄ™cznie przygotowanej strony logowania:

```tsx
export default NextAuth({
  providers: [
    GitHubProvider({
      clientId: getEnv('GITHUB_ID'),
      clientSecret: getEnv('GITHUB_SECRET'),
    }),
  ],
  pages: {
    signIn: '/auth/signin',
  },
  adapter: PrismaAdapter(prisma),
  secret: getEnv('SECRET'),
});
```

<Image src="/images/fullstack-next/niezalogowano.png" alt="" />

Miejscem, w ktÃ³rym rÃ³wnieÅ¼ korzystamy z sesji jest `Header`. Wykorzystujemy tutaj dane by wyÅ›wietliÄ‡ zdjÄ™cie bieÅ¼Ä…cego uÅ¼ytkownika oraz wykonaÄ‡ akcjÄ™Â wylogowania:

```tsx
export const Header = () => {
  const { session, signIn, signOut } = useAuth();
};
```

Z sesji moÅ¼emy korzystaÄ‡ na wiele rÃ³Å¼nych sposobÃ³w, jednym z nich jest sprawdzenie, czy uÅ¼ytkownik jest zalogowany i na bazie tego udostÄ™pniaÄ‡ mu rÃ³Å¼ne obszary aplikacji. My bÄ…dÅºmy bardzo restrykcyjni, jeÅ›li uÅ¼ytkownik nie bÄ™dzie zalogowany, to od razu przeniesiemy go na stronÄ™Â logowania:

```tsx
export default function Home() {
  const { session } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!session) {
      router.push(getEnv('NEXTAUTH_CALLBACK_URL'));
    }
  }, [session]);

  return (
    <Layout>
      <Products />
      <Checkout />
    </Layout>
  );
}
```

## PÅ‚atnoÅ›ci

Za obsÅ‚ugÄ™ pÅ‚atnoÅ›ci w naszym sklepie bÄ™dzie odpowiadaÅ‚o Stripe, czyli jeden z popularniejszych graczy na tym rynku, zobaczmy jak go poÅ‚Ä…czyÄ‡ z Next.js:

### Konfiguracja Stripe

W pierwszej kolejnoÅ›ci potrzebujemy stworzyÄ‡ specjalny endpoint, z ktÃ³rego bÄ™dziemy zaciÄ…gali sesjÄ™Â dla tzw. _checkoutu_. Po zainicjalizowaniu usÅ‚ugi, deklarujemy endpoint w ktÃ³rym tworzymy sesjÄ™Â za pomocÄ… metody ` stripe.checkout.sessions.create()`. Przekazujemy do niej obiekt konfiguracyjny, w ktÃ³rym znajdujÄ…Â siÄ™Â rÃ³wnieÅ¼ `line_items`, czyli przedmioty, ktÃ³re chcemy zakupiÄ‡:

```ts
import { NextApiRequest, NextApiResponse } from 'next';
import { Stripe } from 'stripe';
import { getEnv } from '../../../../utils/env';

const stripe = new Stripe(getEnv('STRIPE_SECRET_KEY'), {
  apiVersion: '2020-08-27',
});


export default async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    const { id } = await stripe.checkout.sessions.create({
      mode: 'payment',
      submit_type: 'donate',
      payment_method_types: ['card'],
      success_url: `${req.headers.origin}/result?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${req.headers.origin}/result?session_id={CHECKOUT_SESSION_ID}`,
      line_items: req.body,
    });

    res.status(200).json({ id });
    res.end();
  } catch {
    res.status(500);
  }
};
```

Po stronie klienta, dla uproszczenia, bÄ™dziemy korzystali z tego jednego endpointu w dwÃ³ch rÃ³Å¼nych miejscach, przy zakupie pojedynczego produktu oraz w koszyku. Zacznijmy od stworzenia funkcji, ktÃ³ra bÄ™dzie otrzymywaÅ‚a sesjÄ™Â Stripe, a nastÄ™pnie na jej bazie przekierowywaÅ‚a do strony checkout'u:

```ts
import type Stripe from 'stripe';
import { getEnv } from './env';
import { loadStripe } from '@stripe/stripe-js';

export const redirectToCheckout = async (session: Pick<Stripe.Checkout.Session, 'id'>) => {
  const stripe = await loadStripe(getEnv('NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY'));

  return stripe!.redirectToCheckout({
    sessionId: session.id,
  });
};
```

Stripe podobnie jak Prisma udostÄ™pnia nam gotowe typy, w tym przypadku korzystamy z typu `Stripe.Checkout.Session`, z ktÃ³rego _wyciÄ…gamy_ `id` sesji. NastÄ™pnie `id` lÄ…duje funkcji `redirectToCheckout()`. W zwiÄ…zku z tym, Å¼e bÄ™dziemy korzystali z fetchera do zapytania endpointu, potrzebujemy stworzyÄ‡Â scheme:

```ts
import * as y from 'yup';

export const stripeSessionSchema: y.SchemaOf<Pick<Stripe.Checkout.Session, 'id'>> = y
  .object()
  .shape({
    id: y.string().required(),
  });
```

#### Pojedynczy produkt

Z tak przygotowanymi utilsami moÅ¼emy przejÅ›Ä‡ do kupna pojedynczego produktu. Zacznijmy od stworzenia wrappera na funkcje `fetcher`:

```ts
import type Prisma from '@prisma/client';
import { fetcher } from '../../../utils/fetcher';
import { stripeSessionSchema } from '../../../utils/stripe';
import { transformProduct } from '../utils/transforms';

export const buyProduct = async (product: Prisma.Product) => {
  const stripeItem = transformProduct(product);

  return await fetcher(`/api/checkout/products/`, {
    method: 'POST',
    body: [stripeItem],
    schema: stripeSessionSchema,
  });
};
```

Funkcja `buyProduct` bÄ™dzie przyjmowaÅ‚a product, a nastÄ™pnie przekazywaÅ‚a go do kolejnej funkcji pomocniczej `transformProduct`. Ta funkcja kryje za sobÄ…Â zwykÅ‚e dopisanie/zmodyfikowanie danych potrzebnych dla samego Stripe. Zmieniamy w tym miejscu strukturÄ™ i typ naszego produktu:

```ts
export const transformProduct = ({
  name,
  description,
  price,
  image,
}: Prisma.Product): Stripe.Checkout.SessionCreateParams.LineItem => ({
  name,
  description,
  amount: price,
  currency: 'PLN',
  images: [image],
  quantity: 1,
});
```

Tak przygotowanÄ…Â funkcjÄ™Â przekazujemy do hooka `useBuyProduct`. Tutaj ponownie korzystamy z React Query, ale tym razem wykorzystujemy hooka `useMutation`. JeÅ›li korzystaÅ‚eÅ› wczeÅ›niej z GraphQL, to na pewno kojarzysz tÄ™Â nazwÄ™. UÅ¼ywamy go w sytuacjach, w ktÃ³rych potrzebujemy coÅ›Â wysÅ‚aÄ‡/zaktualizowaÄ‡/usunÄ…Ä‡ z serwera. Przekazujemy do niego funkcjÄ™, do ktÃ³rej trafi produkt, ktÃ³ry chcemy wysÅ‚aÄ‡ do Stripe. Drugim argumentem mutacji jest obiekt, w ktÃ³rym moÅ¼emy zadeklarowaÄ‡ najrÃ³Å¼niejsze _side-effects_. My chcemy zareagowaÄ‡ na zdarzenie `onSuccess`, w ktÃ³rym odpalimy funkcjÄ™Â `redirectToCheckout`:

```ts
import { useMutation } from 'react-query';
import type Prisma from '@prisma/client';
import { buyProduct } from '../api/buyProduct';
import { redirectToCheckout } from '../../../utils/stripe';

export const useBuyProduct = () => {
  return useMutation((product: Prisma.Product) => buyProduct(product), {
    onSuccess: redirectToCheckout,
  });
};
```

Tak przygotowanego hooka wykorzystujemy w komponencie `Produkt` w nastÄ™pujÄ…cy sposÃ³b:

```tsx
export const Product = (product: ProductProps) => {
  const { id, image, name, price } = product;
  const { mutate } = useBuyProduct();

  const buyProduct = () => mutate(product);

  ...
```

Hook `useMutation` zwraca funkcjÄ™Â `mutate`, do ktÃ³rej przekazujemy wczeÅ›niej zadeklarowany produkt. JeÅ›li wszystko poszÅ‚o zgodnie z planem, to po klikniÄ™ciu w przycisk powinniÅ›my zostaÄ‡ przekierowani na stronÄ™ zakupu:

<Image src="/images/fullstack-next/stripe-produkt.png" alt="Strona zakupu produktu w Stripe" />

### Koszyk i checkout

Analogicznie jak w przypadku produktu, tworzymy funkcjÄ™, ktÃ³ra bÄ™dzie przesyÅ‚aÅ‚a dane do serwera:

```ts
import { stripeSessionSchema } from '../../../utils/stripe';
import { transformProduct } from '../../products/utils/transforms';

export const checkoutCart = async (products: Array<Prisma.Product>) => {
  const stripeItems = products.map((product) => transformProduct(product));

  return await fetcher(`/api/checkout/products/`, {
    method: 'POST',
    body: stripeItems,
    schema: stripeSessionSchema,
  });
};
```

JedynÄ… rÃ³Å¼nicÄ…Â tutaj jest fakt, Å¼e w koszyku moÅ¼emy mieÄ‡ jednoczeÅ›nie wiele produktÃ³w. Tak przygotowany kawaÅ‚ek kodu przekazujemy do hooka `useCheckout()`:

```ts
import { useMutation } from 'react-query';
import type Prisma from '@prisma/client';
import { checkoutCart } from '../api/checkoutCart';
import { redirectToCheckout } from '../../../utils/stripe';

export const useCheckout = () => {
  return useMutation((products: Array<Prisma.Product>) => checkoutCart(products), {
    onSuccess: redirectToCheckout,
  });
};
```

NastÄ™pnie wykorzystujemy go w komponencie `Checkout`:

```tsx
export const Checkout = () => {
  const {
    state: { totalPrice, products, isOpen },
    dispatch,
  } = useCart();
  const { mutate } = useCheckout();

  const handleOpenMenu = () => dispatch({ type: 'openMenu' });
  const handleCloseMenu = () => dispatch({ type: 'closeMenu' });

  const handleCheckout = () => mutate(products);
};
```

JeÅ›li dodasz teraz kilka produktÃ³w do swojego koszyka i sfinalizujesz zakupy, to powinieneÅ› zostaÄ‡ przekierowany do strony pÅ‚atnoÅ›ci:

<Image src="/images/fullstack-next/stripe-koszyk.png" alt="Strona zakupu produktu w Stripe" />

## ObsÅ‚uga bÅ‚Ä™dÃ³w

Nasza aplikacja teoretycznie jest gotowa, ale... ZapomnieliÅ›my o bÅ‚Ä™dach! ZakÅ‚adam, Å¼e przypomnielibyÅ›my sobie o nich dopiero na produkcji, gdy jakiÅ› niezadowolony uÅ¼ytkownik zgÅ‚osiÅ‚by bÅ‚Ä…d w aplikacji. W apkach produkcyjnych warto przykÅ‚adaÄ‡ szczegÃ³lnie duÅ¼Ä… uwagÄ™Â do wszelakich bÅ‚Ä™dÃ³w, zarÃ³wno tych na frontendzie, ale rÃ³wnieÅ¼ tych na backendzie. Fajnie by byÅ‚o rÃ³wnieÅ¼ gdzieÅ› zbieraÄ‡ te bÅ‚Ä™dy z produkcji, Å¼eby wiedzieÄ‡ co potencjalnie moÅ¼emy naprawiaÄ‡ i w ktÃ³rym miejscu leÅ¼y bÅ‚Ä…d. Z pomocÄ… przychodzi serwis Sentry, ktÃ³ry oferuje nam zbieranie bÅ‚Ä™dÃ³w i zarzÄ…dzanie nimi z poziomu dashboardu w przeglÄ…darce.

### Konfiguracja Sentry

DziÄ™ki paczce `@sentry/nextjs` konfiguracja Sentry staÅ‚a siÄ™ banalnie prosta. Wystarczy, Å¼e stworzymy dwa pliki `sentry.client.js` i `sentry.server.js` z takÄ… samÄ… zawartoÅ›ciÄ…:

```ts
import * as Sentry from '@sentry/nextjs';
import { getConfig } from './utils/config';

Sentry.init({
  dsn: getConfig('SENTRY_DNS'),
});
```

### Komponent Error

Next.js udostÄ™pnia nam customowy komponent `Error`, ktÃ³ry umieszczamy w folderze `pages` w pliku o nazwie `_error.tsx`. Ten komponent wykorzystywany jest zarÃ³wno po stronie klienta, jak i po stronie serwera, ale tylko i wyÅ‚Ä…cznie na produkcji. Przychwycone w odpowiednich fazach bÅ‚Ä™dy przekazujemy do Sentry, jeÅ›li chcesz siÄ™Â dowiedzieÄ‡Â wiÄ™cej o dziaÅ‚aniu tego komponetu, to koniecznie zajrzyj do [oficialnego przykÅ‚adu](https://github.com/vercel/next.js/blob/canary/examples/with-sentry/pages/_error.js) przygotowanego przez Nexta, gdzie twÃ³rcy wyjaÅ›niajÄ… jego dziaÅ‚anie linijka po linijce.

```tsx
import { ReactElement } from 'react';
import { NextPageContext, NextPage } from 'next';
import NextErrorComponent, { ErrorProps as NextErrorProps } from 'next/error';
import * as Sentry from '@sentry/nextjs';

type ErrorPageProps = {
  err: Error;
  statusCode: number;
  hasGetInitialPropsRun: boolean;
  children?: ReactElement;
};

type ErrorProps = {
  hasGetInitialPropsRun: boolean;
} & NextErrorProps;

export default function ErrorPage({ statusCode, hasGetInitialPropsRun, err }: ErrorPageProps) {
  if (!hasGetInitialPropsRun && err) {
    Sentry.captureException(err);
  }

  return <NextErrorComponent statusCode={statusCode} />;
}

ErrorPage.getInitialProps = async ({ res, err, asPath }: NextPageContext) => {
  const errorInitialProps = (await NextErrorComponent.getInitialProps({
    res,
    err,
  } as NextPageContext)) as ErrorProps;

  errorInitialProps.hasGetInitialPropsRun = true;

  if (err) {
    Sentry.captureException(err);

    await Sentry.flush(2000);

    return errorInitialProps;
  }

  Sentry.captureException(new Error(`_error.js getInitialProps missing data at path: ${asPath}`));

  await Sentry.flush(2000);

  return errorInitialProps;
};
```

## Rozbudowa projektu

Tak jak wspominaÅ‚em Ci na poczÄ…tku, przez formÄ™Â tego tutoriala musiaÅ‚em ograniczyÄ‡ pewne funkcjonalnoÅ›ci, ale zachÄ™cam CiÄ™Â do sprÃ³bowania zaimplementowania niektÃ³rych _ficzerÃ³w_ na ktÃ³re ja nie miaÅ‚em miejsca, oto kilka moich pomysÅ‚Ã³w:

- Dodanie rÃ³l i autoryzacja. W schemie zadeklarowaliÅ›my nawet roleÂ uÅ¼ytkownika. MoÅ¼esz nadaÄ‡ uÅ¼ytkownikowi rolÄ™ admina i na jej bazie np. zarzÄ…dzaÄ‡ produktami. MÃ³gÅ‚byÅ› zrobiÄ‡ specjalnego dashboarda do tworzenia/aktualizowania/usuwania produktÃ³w z bazy danych.
- Implementacja prawdziwych pÅ‚atnoÅ›ci w Stripe. W naszym koszyku my tak naprawdÄ™Â tylko przekierowujemy do strony checkout'u w Stripe. Twoim zadaniem byÅ‚oby obsÅ‚uÅ¼enie pÅ‚atnoÅ›ci i na bazie tego, czy transakcja siÄ™Â powiodÅ‚a, np. dodanie kupionego produktu do tabeli uÅ¼ytkownika. PrzykÅ‚ady z bardziej zaawansowanym uÅ¼yciem Stripe znajdziesz w [oficjalnym przykÅ‚adzie na GitHubie](https://github.com/stripe-samples/nextjs-typescript-react-stripe-js). SÅ‚owo klucz: _webhook_.
- Rozbuowa sklepu, obecnie nasz e-commerce to miniaturowa wersja prawdziwych, duÅ¼ych sklepÃ³w online. MoÅ¼esz zaczÄ…Ä‡ od np. strony pojedynczego produktu, a skoÅ„czyÄ‡ na promocjach, kategoriach produktÃ³w, czy zakÅ‚adce z kupionymi produktami uÅ¼ytkownika, ogranicza CiÄ™Â tylko Twoja wyobraÅºnia :)

## Podsumowanie

To by byÅ‚o na tyle jeÅ›li chodzi o poradnik z poÅ‚Ä…czenia Next.js z rÃ³Å¼nymi fullstack'owymi technologiami. Mam nadziejÄ™, Å¼e pokazaÅ‚em Ci moÅ¼liwoÅ›ci i narzÄ™dzia, z ktÃ³rych moÅ¼esz korzystaÄ‡ by tworzyÄ‡ wÅ‚asne, bardziej rozbudowane aplikacje w Next.

CaÅ‚y kod dostÄ™pny jest w [repozytorium na GitHubie](https://github.com/olafsulich/fullstack-nextjs-ecommerce). JeÅ›li Ci siÄ™Â podobaÅ‚o, to nie zapomnij zarzuciÄ‡ â­

Do usÅ‚yszenia!

### Å¹rÃ³dÅ‚a

- [Next.js Stripe Example](https://github.com/stripe-samples/nextjs-typescript-react-stripe-js)
- [Next.js Sentry Example](https://github.com/vercel/next.js/tree/canary/examples/with-sentry)
- [Next,js Prisma Example](https://vercel.com/guides/nextjs-prisma-postgres)
- [PolskiFrontend](https://github.com/typeofweb/polskifrontend)
- [TailwindUI](https://tailwindui.com/#product-ecommerce)
