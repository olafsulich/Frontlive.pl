---
title: 'GraphQL + React - apollo, hooki i paginacja'
category: 'GraphQL'
publishedAt: '07-08-2020'
isPublished: true
popular: false
excerpt: 'Jak poczy GraphQL i React? Skorzysta z Apollo! Wybierzmy sina t misj i stawmy czoa realnej aplikacji!'
---

Kontynuujemy serio GraphQLu i zabieramy si za tworzenie **mini aplikacji**. Poznasz dzisiaj klienta **Apollo**, kt贸ry udostpnia nam midzy innymi **hooki**, mo偶liwo **zarzdzania stanem aplikacji** i **cachowanie** danych. Dzi zajmiemy si tylko czci tych zagadnie, jest tego bowiem za du偶o, 偶eby zmieci si w jednym wpisie, za tydzie **cz druga**!

A tutaj may spojler aplikacji 

<Image src="/images/graphql-apollo/Apollo-app.png" alt="Gotowa aplikacja" />

## Spis treci

- [Instalacja](#instalacja)
- [Konfiguracja](#konfiguracja)
- [Hooki](#hooki)
  - [useQuery](#usequery)
  - [useLazyQuery](#uselazyquery)
  - [useMutation](#usemutation)
  - [useSubscription](#usesubscription)
- [Budowa aplikacji - zapytania](#budowa-aplikacji---zapytania)
- [Budowa aplikacji - profil postaci](#budowa-aplikacji---profil-postaci)
- [Budowa aplikacji - paginacja](#budowa-aplikacji---paginacja)
- [Obsuga bd贸w](#obsluga-bledow)
- [Podsumowanie](#podsumowanie)
  - [殴r贸da](#藕r贸da)

## Instalacja

Zacznijmy od stworzenia nowego projektu za pomoc **Create React App**:

```bash
npx create-react-app graphql-apollo
```

Potrzebujemy zainstalowa jeszcze potrzebne paczki:

```bash
cd graphql-apollo && npm install @apollo/client graphql
```

## Konfiguracja

Bdziemy konfigurowa nasz projekt **na bie偶co** dokadajc do niego kolejne ficzery, ale potrzebujemy _bazy_, 偶eby zacz prac z **apollo**.

Zacznijmy od stworzenia pliku `apollo-client.js`:

```bash
touch apollo-client.js
```

Super, do skonfigurowania apollo potrzebujemy **trzech rzeczy**. Zainicjowa now klas `ApolloClient`, ustawi **cache** i poda **endpoint** do naszego API.

```js
import { ApolloClient, InMemoryCache } from '@apollo/client';

const client = new ApolloClient({
  cache: new InMemoryCache({}),
  uri: 'https://rickandmortyapi.com/graphql/',
});

export { client };
```

Przejd藕 teraz do pliku bazowego `index.js` i ople swoj aplikacjw `ApolloProvider`. Do providera podajemy wczeniej stworzonego **klienta apollo**.

```jsx
import React from 'react';
import ReactDOM from 'react-dom';
import { ApolloProvider } from '@apollo/client';
import { client } from './apollo-client';

ReactDOM.render(
  <React.StrictMode>
    <ApolloProvider client={client}>
      <App />
    </ApolloProvider>
  </React.StrictMode>,
  document.getElementById('root'),
);
```

Taka konstrukcja powinna nam wystarczy na pocztek.

### Hooki

Zanim przejdziemy do tworzenia aplikacji chciabym Ci przybli偶y par **niezbdnych** temat贸w, jednym z nich s udostpnione **hooki**.

### useQuery

Jest to podstawowy **hook** su偶cy do robienia **zapyta** do naszego API. Jeli nie wiesz czym s zapytania, zajrzyj do [poprzedniego postu](https://www.frontlive.pl/graphql-api/#zapytania).

Na pocztki definiujemy zapytanie u偶ywajc `gql` i template string贸w, nastpnie podajemy je do `useQuery`. W odpowiedzi dostajemy trzy podstawowe rzeczy: `data`, `loading` i `error`. Zwracanych wartoci jest oczywicie wicej, ale na tchwil potrzebujesz zna tylko te wymienione. Du偶o tutaj nie trzeba tumaczy, `data` zwraca nam przychodzce **dane**, `loading` to boolean, kt贸ry okrela czy 贸w dane s ju偶 **gotowe**, a `error` m贸wi nam, czy podczas zapytania wystpi jaki **bd**.

```js
import { gql, useQuery } from '@apollo/client';

const GET_CHARACTERS = gql`
  {
    characters(page: 2) {
      results {
        name
        id
        image
      }
    }
  }
`;

const Home = () => {
  const { data, loading, error } = useQuery(GET_CHARACTERS);

  if (loading) return null;
  if (error) return `Error! ${error}`;
  return <h1>{data.results.name}</h1>;
};
```

Do naszego zapytania mo偶emy poda obiekt, kt贸ry przyjmuje, midzy innymi, **zmienne**, ale do tego przejdziemy w dalszej czci.

### useLazyQuery

Ten hook jest bardzo podobny do poprzedniego, z tym, 偶e tutaj zacigamy dane _na 偶danie_, a nie od razu, tak jak robi to `useQuery`. Za pomoc `useLazyQuery` mo偶emy np. zacign potrzebne dane **po klikniciu** w jaki przycisk.

```js
const Home = () => {
  const [getCharacters, { data, loading, error }] = useLazyQuery(GET_CHARACTERS);

  if (loading) return null;
  if (error) return `Error! ${error}`;
  return <button onClick={getCharacters}>Kliknij mnie</button>;
};
```

### useMutation

ZaskoczWas, `useMutation` su偶y do obsugi mutacji w Apollo. Tak na marginesie, cae API tej biblioteki jest na prawd **wietne** i praca z Apollo jest **przyjemnoci**, szczeg贸lnie, 偶e m贸wimy tutaj o najnowszej wersji `3.0`. Ale dobra bez zbdnego gadania, przechodzimy do **mutacji** i nie, nie s to mutacje, kt贸re mo偶esz zna z czystego jsa(tych, kt贸rych **nie powiniene** robi).

Na pocztku stw贸rzmy nasz mutacj, bdzie ona **dodawa now posta**:

```js
const ADD_CHARACTER = gql`
  mutation AddCharacter($name: String!) {
    addCharacter(name: $name) {
      id
      name
    }
  }
`;
```

Wykorzystajmy j w hooku:

```jsx
const Home = () => {
  const [value, setValue] = useState();
  const [addCharacter, { data }] = useMutation(ADD_CHARACTER);

  const handleSubmit = () => {
    addCharacter({
      variables: {
        name: e.target.name,
      },
    });
  };

  const handleChange = (e) => {
    setValue(e.target.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" onChange={handleChange} />
      <button type="submit">Dodaj now posta</button>
    </form>
  );
};
```

Teraz **po klikniciu w przycisk** dodamy now posta.

### useSubscription

Tutaj mamy mae zawirowanie, wydawao by si, 偶e ten hook su偶y do **subskrybowania**, czyli **nasuchiwania** na dane i gdy si zmienizastpi je w naszej aplikacji tymi nowymi. W praktyce tak jest, ale **z du偶ym wyjtkiem**. A mianowicie, ten hook ma specyficzne zastosowanie gdy chcemy _pobra_ tylko jaki **may kawaek** naszych danych, lub gdy nasze dane potrzebuj by zmieniane **bardzo intensywnie**, na przykad w aplikacji typu **chat**. Do takiego _zwykego_ nasuchiwania su偶y inna waciwo, o kt贸rej opowiem wam troszk p贸藕niej.

Rozwizanie z `useSubscription` wymaga **dodatkowej konfiguracji**, celowo, nie bd tutaj marnowa Twojego czasu, bo zastosowanie subskrypcji nie jest takie powszechne jak innych hook贸w, chciaem Ci jedynie przekaza, 偶e co takiego w og贸le istnieje.

Jeli chcesz si dowiedzie wicej o subskrypcjach, zajrzyj do [oficjalnej dokumentacji](https://www.apollographql.com/docs/react/data/subscriptions/).

```js
const COMMENTS_SUBSCRIPTION = gql`
  subscription OnCommentAdded($postID: ID!) {
    commentAdded(postID: $postID) {
      id
      content
    }
  }
`;

const LatestComment = () => {
  const [id, setId] = useState('12345');
  const { data, loading } = useSubscription(COMMENTS_SUBSCRIPTION, {
    variables: { id },
  });

  if (loading) return null;
  return <h1>New comment: {data.commentAdded.content}</h1>;
};
```

## Budowa aplikacji - zapytania

Postanowiem podzieli ten artyku na **mniejsze czci**, jedne bd obejmoway **praktyk**, gdzie bdziemy rozbudowywa maymi kroczkami aplikacj, a inne to tematy **teoretyczne**, bdziemy miesza dane zagadnienia, nie wszystkich jednak u偶yjemy, zostawiam Ci **furtkna rozbudow apki**, dodanie ciekawych **ficzer贸w**. Nie bd si tutaj skupi na stylowaniu caoci, jeli bdziesz chcia podejrze style, zajrzyj do [kodu na GitHubie](https://github.com/Frontlive/GraphQL-Apollo-Training).

W tej czci wykonamy pierwsze zapytanie, pobierzemy i wywietlimy wszystkie postaci. **Zaczynajmy**!

W pierwszej kolejnoci utw贸rzmy komponent `Card.js`, do kt贸rego bdziemy przekazywa potrzebne propsy:

```jsx
import React from 'react';
import styles from './Card.module.scss';
import { Link } from 'react-router-dom';

const Card = ({ name, image, status, location, origin, id }) => (
  <article className={styles.wrapper}>
    <div className={styles.imageWrapper}>
      <img className={styles.image} src={image} alt="Character" />
    </div>
    <div className={styles.textWrapper}>
      <div className={styles.textSection}>
        <Link to={`/${id}`} className={styles.link}>
          <h2 className={styles.heading}>{name}</h2>
        </Link>
        <p className={styles.status}>
          <span className={styles.statusIcon} />
          {status}
        </p>
      </div>

      <div className={styles.textSection}>
        <h3 className={styles.textGray}>Last known location:</h3>
        <Link href="/" className={styles.link}>
          {location}
        </Link>
      </div>
      <div className={styles.textSection}>
        <h3 className={styles.textGray}>First seen in:</h3>
        <Link href="/" className={styles.link}>
          {origin}
        </Link>
      </div>
    </div>
  </article>
);

export default Card;
```

Nic szczeg贸lnego, nie mamy tutaj **偶adnego stanu**, ani **nie pobieramy danych**, jest to komponent czysto prezentacyjny.

Stw贸rzmy wic nasz _g贸wny_ komponent `Home.js`, kt贸ry bdzie wywietla list wczeniej przygotowanych kart.

```jsx
import React from 'react';
import Wrapper from '../Wrapper/Wrapper';
import Card from '../Card/Card';
import { gql, useQuery } from '@apollo/client';
import styles from './Home.module.scss';

const GET_CHARACTERS = gql`
  {
    characters {
      results {
        name
        id
        image
        status
        location {
          name
        }
        origin {
          name
        }
      }
    }
  }
`;

const Home = () => {
  const { data, loading, error } = useQuery(GET_CHARACTERS);

  if (error) return <h1>Error</h1>;

  return (
    <div className={styles.appWrapper}>
      <section className={styles.app}>
        <h1>Rick and Morty</h1>
        <Wrapper>
          {loading ? (
            <p>loading...</p>
          ) : (
            data.characters.results.map(({ name, image, status, location, origin, id }) => (
              <Card
                key={id}
                name={name}
                image={image}
                location={location.name}
                origin={origin.name}
                status={status}
                id={id}
              />
            ))
          )}
        </Wrapper>
      </section>
    </div>
  );
};

export default Home;
```

Tutaj dziej siju偶 znacznie wicej, na pocztku definiujemy zapytanie `GET_CHARACTERS` i podajemy je do hooka `useQuery`. Nastpnie sprawdzamy czy nie ma **bdu** i czy nasze dane s ju偶 **zaadowane**.P贸藕niej ju偶 tylko **mapujemy wynik** naszego zapytania i **zwracamy karty** z odpowiednimi propsami. Cao powinna wyglda mniej wicej tak:

<Image src="/images/graphql-apollo/apollo-postacie.png" alt="Lista postaci" />

## Budowa aplikacji - profil postaci

Rozbudujmy karty tak, aby po klikniciu w nazw danej postaci ukazywa nam si jej **profil z danymi** i **odcinkami** w kt贸rych wystpia.

Stw贸rzmy komponent `EpisodeCard.js`:

```jsx
import React from 'react';
import styles from './EpisodeCard.module.scss';

const EpisodeCard = ({ name }) => (
  <article className={styles.wrapper}>
    <h3 className={styles.heading}>{name}</h3>
  </article>
);

export default EpisodeCard;
```

Okej super, najatwiejsza rzecz za nami, teraz chcemy napisa odpowiednie **zapytanie**, kt贸re zwr贸ci nam **potrzebne dane**:

```js
const GET_CHARACTER = gql`
  query getCharacter($id: ID) {
    character(id: $id) {
      name
      id
      image
      status
      location {
        name
      }
      origin {
        name
      }
    }
  }
`;
```

Tworzymy **zmienn** `GET_CHARACTER`, kt贸ra posiada w sobie zapytanie `getCharacter`. W nim podajemy, jako **argument**, `id` o typie `ID`, kt贸re p贸藕niej przekazujemy do pola `character`. Na tej podstawie GraphQL okreli **dane jakiej postaci** ma nam przygotowa.

W tej aplikacji bdziemy korzysta z [React Routera](https://reactrouter.com/web/guides/quick-start), kt贸ry udostpnia hooka `useParams`, z niego _wycigniemy_ potrzebne nam `id` dla zapytania.

```jsx
const { id } = useParams();
```

Zmienn przekazujemy w obiekcie, kt贸ry jest drugim parametrem `useQuery`:

```jsx
const { data, loading } = useQuery(GET_CHARACTER, {
  variables: { id },
});
```

Nastpnym krokiem jest przygotowanie danych i przekazanie ich do komponentu `Card`.

```jsx
import React from 'react';
import Card from '../Card/Card';
import { useParams } from 'react-router-dom';
import styles from './Character.module.scss';
import { useQuery, gql } from '@apollo/client';
import EpisodeCard from '../EpisodeCard/EpisodeCard';

const GET_CHARACTER = gql`
  query getCharacter($id: ID) {
    character(id: $id) {
      name
      id
      image
      status
      location {
        name
      }
      origin {
        name
      }
    }
  }
`;

const Character = () => {
  const { id } = useParams();
  const { data, loading } = useQuery(GET_CHARACTER, {
    variables: { id },
  });

  const character = data?.character;

  return (
    <div className={styles.wrapper}>
      <section className={styles.app}>
        <h1>Character</h1>
        {loading ? (
          <p>loading</p>
        ) : (
          <>
            <div className={styles.cardWrapper}>
              {
                <Card
                  key={character.id}
                  name={character.name}
                  image={character.image}
                  location={character.location.name}
                  origin={character.origin.name}
                  status={character.status}
                  id={id}
                />
              }
            </div>
          </>
        )}
      </section>
    </div>
  );
};

export default Character;
```

Karty mamy gotowe, pozostao nam pobra dane o **odcinkach**, w kt贸rych dana posta graa. Zastosujmy tutaj hooka `useLazyQuery`, kt贸ry po klikniciu w przycisk pobierze potrzebne dane.

Tworzymy wic podobne zapytanie do poprzedniego:

```jsx
const GET_EPISODES = gql`
  query getEpisodes($id: ID) {
    character(id: $id) {
      episode {
        id
        name
      }
    }
  }
`;
```

Wykorzystujemy hooka `useLazyQuery` podajc mu, tak samo jak poprzednio, obiekt ze zmiennymi:

```jsx
const [getEpisodes, { data: EpisodesData, loading: EpisodesLoading }] = useLazyQuery(GET_EPISODES, {
  variables: { id },
});
```

W tym przypadku, w jednym komponencie, mamy dwa zapytania. Tutaj pojawia si **problem**, dostajemy dwa razy `data` i `loading`, 偶eby temu zaradzi nazywamy inaczej przychodzce _dane_ i informacj o _stanie_ **adowania**.

Wystarczy ju偶 tylko doda przycisk z funkcj `getEpisodes` i **zmapowa** przychodzce dane.

```jsx
<div className={styles.episodesWrapper}>
  <h2>Episodes</h2>
  <button className={styles.button} onClick={getEpisodes}>
    Load episodes
  </button>
  {EpisodesLoading ? (
    <p>loading</p>
  ) : (
    <>
      {EpisodesData &&
        EpisodesData.character.episode.map(({ name, id }) => (
          <EpisodeCard key={character.id} name={name} id={id} />
        ))}
    </>
  )}
</div>
```

Cay komponent `Character.js`:

```jsx
import React from 'react';
import Card from '../Card/Card';
import { useParams } from 'react-router-dom';
import styles from './Character.module.scss';
import { useQuery, useLazyQuery, gql } from '@apollo/client';
import EpisodeCard from '../EpisodeCard/EpisodeCard';

const GET_CHARACTER = gql`
  query getCharacter($id: ID) {
    character(id: $id) {
      name
      id
      image
      status
      location {
        name
      }
      origin {
        name
      }

      episode {
        id
        name
      }
    }
  }
`;

const GET_EPISODES = gql`
  query getEpisodes($id: ID) {
    character(id: $id) {
      episode {
        id
        name
      }
    }
  }
`;

const Character = () => {
  const { id } = useParams();
  const { data, loading } = useQuery(GET_CHARACTER, {
    variables: { id },
  });
  const [getEpisodes, { data: EpisodesData, loading: EpisodesLoading }] = useLazyQuery(
    GET_EPISODES,
    {
      variables: { id },
    },
  );

  const character = data?.character;

  return (
    <div className={styles.wrapper}>
      <section className={styles.app}>
        <h1>Character</h1>
        {loading ? (
          <p>loading</p>
        ) : (
          <>
            <div className={styles.cardWrapper}>
              {
                <Card
                  key={character.id}
                  name={character.name}
                  image={character.image}
                  location={character.location.name}
                  origin={character.origin.name}
                  status={character.status}
                  id={id}
                />
              }
            </div>
          </>
        )}
        <div className={styles.episodesWrapper}>
          <h2>Episodes</h2>
          <button className={styles.button} onClick={getEpisodes}>
            Load episodes
          </button>
          {EpisodesLoading ? (
            <p>loading</p>
          ) : (
            <>
              {EpisodesData &&
                EpisodesData.character.episode.map(({ name, id }) => (
                  <EpisodeCard key={character.id} name={name} id={id} />
                ))}
            </>
          )}
        </div>
      </section>
    </div>
  );
};

export default Character;
```

Na sam koniec dodajmy plik `App.js` a w nim ruter dla naszej aplikacji.

```jsx
import React from 'react';
import { BrowserRouter as Router, Switch, Route } from 'react-router-dom';
import Home from '../components/Home/Home';
import Character from '../components/Character/Character';

const App = () => {
  return (
    <Router>
      <Switch>
        <Route exact path="/">
          <Home />
        </Route>
        <Route path="/:id">
          <Character />
        </Route>
      </Switch>
    </Router>
  );
};

export default App;
```

Strona powinna wyglda mniej wicej tak:

<Image src="/images/graphql-apollo/karta-postaci-apollo.png" alt="Karta postaci" />

## Budowa aplikacji - paginacja

Wr贸my do naszej strony g贸wnej, na obecn chwil wywietlamy **tylko pierwszstron**z naszymi postaciami. 呕eby to zmieni potrzebujemy jakie **paginacji**, co to jest paginacja? Na pewno spotkae si ju偶 z ni wiele razy, czy to przyciskami typu `load more` czy te偶 klasycznym `next` i `previous`.

Chcemy zaimplementowa co podobnego w naszej aplikacji, ja z Wami stworz przycisk `next`, a jeli tylko bdziecie chcieli mo偶ecie te偶 stworzy `previous`, bdzie to dziaao na tej samej zasadzie.

Wejd藕my do pliku `Home.js` i zaktualizujmy nasze `useQuery`:

```jsx
const { data, loading, fetchMore } = useQuery(GET_CHARACTERS, {
  variables: { page },
});
```

Pojawia si nam tutaj funkcja `fetchMore`, kt贸ra wanie **idealnie** si sprawdzi do tego zastosowania.
Pozwala nam ona **zaktualizowa zapytanie** i **poczy** poprzednie dane z tymi nowymi. Za chwil zobaczymy jak to dziaa w praktyce. Ale zanim to zrobimy stw贸rzmy najprostszy `state`, kt贸ry bdzie przechowywa informacje o **bie偶cej** stronie.

```jsx
const [page, setPage] = useState(1);
```

Dodajmy do tego funkcj kt贸ra bdzie go **inkrementowa**:

```jsx
const handleIncrement = () => setPage((prevState) => prevState + 1);
```

Okej stw贸rzmy teraz funkcj, kt贸ra faktycznie zrobi to czego oczekujemy.

```jsx
const loadMoreCharacters = () => {
  fetchMore({
    variables: {
      page: page + 1,
    },
    updateQuery: (prev, { fetchMoreResult }) => {
      if (!fetchMoreResult) return prev;
      const newCharacters = Object.assign({}, prev, {
        characters: {
          ...prev.characters,
          ...fetchMoreResult.characters,
        },
      });
      return newCharacters;
    },
  });
  handleIncrement();
};
```

Jak widzisz, na pocztku wywoujemy `fetchMore`, a nastpnie `handleIncrement`. Ta pierwsza funkcja przyjmuje obiekt w kt贸rym mo偶emy poda **zmienne** i metod `updateQuery`, w niej dziej si**caa magia**. Z `updateQuery` wycigamy `prev`, czyli warto z poprzedniego zapytania i `fetchMoreResult` czyli informacj odnonie tego nowego. Domylnie `fetchMore` bdzie korzystao z zapytania `GET_CHARACTERS`, kt贸re wczeniej stworzylimy i podalimy do `useQuery`, mo偶emy to jednak **zmieni** dodajc argument `query`. Dopiero na sam koniec inkrementujemy nasz `state`.

Ostatnim krokiem bdzie stworzenie przycisku i dodanie do niego stworzonej przez nas funkcji:

```jsx
<button className={styles.button} onClick={loadMoreCharacters}>
  Next page
</button>
```

Cay kod:

```jsx
import React, { useState } from 'react';
import Wrapper from '../Wrapper/Wrapper';
import Card from '../Card/Card';
import { gql, useQuery } from '@apollo/client';
import styles from './Home.module.scss';

const GET_CHARACTERS = gql`
  query getCharacters($page: Int) {
    characters(page: $page) {
      results {
        name
        id
        image
        status
        location {
          name
        }
        origin {
          name
        }
      }
    }
  }
`;

const Home = () => {
  const [page, setPage] = useState(1);
  const { data, loading, fetchMore } = useQuery(GET_CHARACTERS, {
    variables: { page: page },
  });

  const handleIncrement = () => setPage((prevState) => prevState + 1);

  const loadMoreCharacters = () => {
    fetchMore({
      variables: {
        page: page + 1,
      },
      updateQuery: (prev, { fetchMoreResult }) => {
        if (!fetchMoreResult) return prev;
        const newCharacters = Object.assign({}, prev, {
          characters: {
            ...prev.characters,
            ...fetchMoreResult.characters,
          },
        });
        return newCharacters;
      },
    });
    handleIncrement();
  };

  return (
    <div className={styles.appWrapper}>
      <section className={styles.app}>
        <h1>Rick and Morty</h1>
        <button className={styles.button} onClick={loadMoreCharacters}>
          Next page
        </button>
        <Wrapper>
          {loading ? (
            <p>loading...</p>
          ) : (
            data.characters.results.map(({ name, image, status, location, origin, id }) => (
              <Card
                key={id}
                name={name}
                image={image}
                location={location.name}
                origin={origin.name}
                status={status}
                id={id}
              />
            ))
          )}
        </Wrapper>
      </section>
    </div>
  );
};

export default Home;
```

## Obsuga bd贸w

Jeli chodzi o obsug bd贸w, mielimy ju偶 z tym do czynienia przy hookach i wygldao to tak:

```jsx
const { data, loading, error } = useQuery(GET_CHARACTERS);
```

Wycigalimy `error` z `useQuery` i na tej zasadzie moglimy sprawdza, czy wystpi jaki bd.

Dziki Apollo, mo偶emy przenie obsug bd贸w na jeszcze wy偶szy level i skorzysta z funkcji `onError`, kt贸ra ledzi bdy zwizane z **sieci** i **serwerem**.

```jsx
import { onError } from "@apollo/client/link/error";

const link = onError(({ graphQLErrors, networkError }) => {
  if (graphQLErrors)
    graphQLErrors.map(({ message, locations, path }) =>
     //...
    );

  if (networkError){
    //...
  };
});
```

Mo偶na to fajnie poczy z **linkami**, ale na ten moment chciaem Ci tylko o tym wspomnie, temat **link贸w** na pewno rozwiniemy w drugiej czci.

## Podsumowanie

To wszystko na dzi, podstawowa **aplikacja gotowa**, nie jest ona napisana idealnie, tak偶e jeli chcesz j dalej rozbudowywa i np. wstawi jako projekt do portfolio, polecam Ci **zrefaktoryzowa** porzdnie ten kod. Sam aplikacj bdziemy rozbudowywa za tydzie, dodamy do niej **zarzdzanie stanem aplikacji**, **cache** i wiele wicej.

Kod gotowej aplikacji jest dostpny [na GitHubie](https://github.com/Frontlive/GraphQL-Apollo-Training).

Mam nadziej, 偶e czego wartociowego sinauczye/a i 偶e **wykorzystasz** jako zdobyt dzi wiedz 

Do usyszenia!

### 殴r贸da

- [GraphQL Docs](https://www.apollographql.com/docs/)
- [The Rick and Morty API](https://rickandmortyapi.com/)
