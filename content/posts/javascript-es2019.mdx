---
title: 'JavaScript - ES6 to ju偶 prze偶ytek, nastaa era ES2019!'
category: 'JavaScript'
publishedAt: '05-05-2020'
isPublished: true
popular: false
image: '/images/javascript-es2019/javascript-es2019.png'
excerpt: 'JavaScript cay czas si zmienia, kilka lat temu powstaa specyfikacja ES6, kt贸ra po dzi dzie, jest uwa偶ana, przez niekt贸rych, za nowo. Niestety programistyczny wiat i technologi rozwijaj si bardzo szybko i co roku wychodz nowe ficzery.'
---

**Cze** 

JavaScript cay czas si zmienia, kilka lat temu powstaa specyfikacja **ES6**, kt贸ra po dzi dzie, jest uwa偶ana, przez niekt贸rych, za nowo. Niestety programistyczny wiat i technologi **rozwijaj si bardzo szybko** i co roku wychodz nowe ficzery.

Dzi poznasz kilka **najnowszych** ficzer贸w **ES2019**!

Czego si dzisiaj dowiesz?

- [Array.flat()](#arrayflat)
- [Array.flatMap()](#arrayflatmap)
- [Array.sort()](#arraysort)
- [Optional Catch Binding](#optionalcatchbinding)
- [Object.fromEntries()](#objectfromentries)
- [String.trimStart & String.trimEnd](#stringtrimstart--stringtrimend)
- [BigInt](#bigint)
- [Dynamiczne importy](#dynamiczne-importy)

Zaczynajmy!

> Nazwy nag贸wk贸w nie s w 100% poprawne, brakuje im chocia偶by **prototype**, zostay one uproszczone :)

## Array.flat()

Rozpoczynamy z grubej rury i bierzemy siza **tablice**.

Metoda `flat()` spaszcza zagnie偶d偶one w sobie tablice. Mo偶emy _regulowa_ poziom spaszczenia podajc
do niej parametr `depth`.

```js
let numbers = [1, 2, 3, [4, 5], 6, 7, [8, [9, 10]]];

numbers.flat(); // [1, 2, 3, 4, 5, 6, 7, 8, [9, 10]] - pierwszy poziom spaszczenia

numbers.flat(2); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] - drugi poziom spaszczenia
```

Je偶eli nie jestemy pewni jaki powinnimy poda _poziom spaszczenia_, mo偶emy skorzysta z `Infinity`.

```js
let numbers = [1, [2, [3, [4, [5, [6, [7]]]]]]];

number.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7]
```

## Array.flatMap()

Brzmi jak poczenie `map()` i `flat()`? Dokadnie tym jest! Pozwala nam **mapowa** po tablicy, jednoczenie **spaszczajc** zagnie偶d偶one wartoci.

```js
const numbers = [1, 2, 3, 4, 5, 6, 7];

const multiplyByTwo = () => numbers.flatMap((number) => [number, '  ']);
// [1,  , 2,  , 3,  , 4,  , 5,  , 6,  , 7,  ]
```

## Array.sort()

Mo偶liwe, 偶e paru z was syszao ju偶 o `sort()`, a mo偶e go nawet u偶ywao. Moga by to jednak **niestabilna** wersja **V8**, dzi zajmiemy si t stabiln.

Jak sama nazwa m贸wi, `sort()` zwraca nam posortowane wartoci tablicy.
Algorytm sortowania, by default, sortuje nam elementy **rosnco**, zanim jednak to zrobi, konwertuje je na stringi i por贸wnuje z wartoci [unicode UTF-16](https://pl.wikipedia.org/wiki/UTF-16).

```js
const players = [
  { name: 'Micha', level: 12 },
  { name: 'Kuba', level: 7 },
  { name: 'Bartek', level: 1 },
  { name: 'Adam', level: 30 },
];

const sortingAlgorithm = (first, second) => first.name - second.name;

const sortedPlayers = players.sort(sortingAlgorithm);
```

Nasz _algorytm_ sortujcy posortowa graczy, w **odwrotnej kolejnoci**, po imionach.

## Optional Catch Binding

Sama nazwa, mo偶e wydawa siskomplikowana, ale tak jak poprzednio, opisuje dokadnie to, co zostao wprowadzone. Pamitacie parametr `error` w `catch`? No to mo偶ecie o nim zapomnie(joke), w ES10 jest on opcjonalny i **nie musimy go podawa**.

```js
// stare :c

try {
  //...
} catch (e) {
  //...
}

// nowe :)

try {
  //...
} catch {
  //...
}
```

## Object.fromEntries()

Przeksztaca list kluczy i wartoci na **obiekt**. Ta _lista_ musi nale偶e do grupy [iterowalnych](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol), np. **Map** i **Array**.

```js
const player = [
  ['name', 'Wojtek'],
  ['age', 28],
];

Object.fromEntries(player); // { name: 'Wojtek', age: 28 }
```

## String.trimStart & String.trimEnd

Metody `trimStart` i `trimEnd` usuwaj odpowiednio odstpy z pocztku i koca **stringu**.

```js
const greeting = '   Hello friend!   ';

greeting.trimStart(); // "Hello friend!   "

greeting.trimEnd(); // // "   Hello friend!"
```

## BigInt

**BigInt** jest nowym prymitywnym typem, kt贸ry wspiera **DU呕E** liczby cakowite. Mo偶emy teraz
przedstawia takie liczby jak `2^53`, tak wiem, pewnie korzystacie z tego w codziennej pracy.

**BigInt** docza do naszej liczby cakowitej literk `n`. Mo偶emy go wykorzysta zar贸wno na liczbach, jak i na stringach.

```js
const superHugeNumber = BigInt(9007199254740991); // 9007199254740991n

const superHugeString = BigInt('9007199254740991'); // 9007199254740991n
```

BigInt mo偶e Ci przypomina typ `Number`, jednak nim nie jest. Nie mo偶emy czy _zwykych_ liczb z BigIntem, nie mo偶emy r贸wnie偶 u偶y na nim takich metod jak `Math`, por贸wnywa mo偶emy go tylko do **samego siebie**.

Do czego to mo偶e Ci si przyda?

Nie mam pojcia, mo偶e akurat bdziesz aplikowa do **NASA** 

## Dynamiczne importy

To jedna z moich ulubionych **nowoci**! Tak jak importowalimy moduy na pocztku danego pliku, tak teraz mo偶emy to zrobi **gdziekolwiek** chcemy, np. w **funkcji asynchronicznej**.

`import(...)` aduje modu i zwracam nam **obietnic**(promise), kt贸ry resolvuje si i daje nam dostp do obiektu przechowujcego **wszystkie exporty**.

```js
// userInfo.js

const printPlayerName = () => "Kuba";
const printPlayerAge = () => 20;

export { printPlayerName, printPlayerAge };


// app.js

const = async () => {
  const {printPlayerName, printPlayerAge} = await import("./userInfo.js");
  printPlayerName();
  printPlayerAge();
}
```

A co z defaultowymi exportami?

```js
// userScore.js

const printScore = () => 122;

export default printScore;

// app.js

const = async () => {
  const score = await import("./userScore.js");
  score.default();
}
```

## Podsumowanie

To wszystko na dzi, **jak wam si podobaj** nowoci w JS?

Dajcie zna w komentarzach!

### 殴r贸da

- [MDN](https://developer.mozilla.org/en-US/)
- [JavaScript.info](https://javascript.info/)
