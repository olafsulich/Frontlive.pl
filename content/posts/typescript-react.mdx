---
title: 'TypeScript - React, Redux i Styled Components'
category: 'TypeScript'
publishedAt: '22-05-2020'
isPublished: true
popular: true
image: '/images/typescript-react/typescript-react.png'
excerpt: 'Moje ulubione poczenie - React + TypeScript! Sprawd藕 jak typowa aplikacj, kt贸ra korzysta z Reakta, Reduxa i Styled Components - kompletny poradnik!'
---

Zgosiem tego bloga do serwisu zbierajcego blogi/vlogi o front-endzie - [Polski Front-End](https://www.polskifrontend.pl/).
Polecam, na pewno traficie tam na **ciekawy content**, dziki Bartek za dodanie!

Dzi przyjrzymy si troch bli偶ej mojemu ulubionemu poczeniu, czyli **React + TypeScript** . Zahaczymy te偶 o **Reduxa** i **Styled Components**, na pewno nie po偶aujesz, zaczynajmy!

## Co powiniene wiedzie?

- Powiniene swobodnie porusza si po **Reakcie**
- Zna podstawy **TypeScriptu**

Jeli TS jest dla Ciebie **nowoci**, to zachcam Ci najpierw do przeczytania dw贸ch poprzednich wpis贸w o TypeScripcie:

- [TypeScript - podstawowe typy, funkcje, tablice i interfejsy](https://frontlive.pl/blog/typescript-podstawy)
- [TypeScript - Generics, klasy i zaawansowane typy](https://frontlive.pl/blog/typescript-sredniozaawansowany/).

## Agenda

- [Instalacja](/typescript-react/#instalacja)
- [Komponenty](/typescript-react/#komponenty)
  - [Klasowe](/typescript-react/#klasowe)
  - [Funkcyjne](/typescript-react/#funkcyjne)
- [Hooki](/typescript-react/#hooki)
  - [useState](/typescript-react/#usestate)
  - [useEffect](/typescript-react/#useeffect)
  - [useRef](/typescript-react/#useref)
  - [useReducer](/typescript-react/#usereducer)
  - [Custom hooks](/typescript-react/#custom-hooks)
- [Formularze i zdarzenia](/typescript-react/#formularze-i-zdarzenia)
  - [union types](/typescript-react/#union-types)
  - [SyntheticEvent](/typescript-react/#union-types)
- [Context](/typescript-react/#context)
- [Portale](/typescript-react/#portale)
- [HOC](/typescript-react/#hoc)
- [Redux](/typescript-react/#redux)
  - [Instalacja](/typescript-react/#intalacja-definicji-typow)
  - [useSelector](/typescript-react/#useselector)
  - [useDispatch](/typescript-react/#usedispatch)
  - [Thunk](/typescript-react/#thunk)
- [Styled Components](/typescript-react/#styled-components)
  - [Theme](/typescript-react/#theme)
  - [Propsy](/typescript-react/#propsy)
- [Podsumowanie](/typescript-react/#podsumowanie)

## Instalacja

Zacznijmy od najwa偶niejszego, **instalacji**. 呕eby nie traci czasu na ustawianie caego projektu od zera, skorzystajmy z [Create React App](https://create-react-app.dev/docs/adding-typescript/) wraz z TypeScriptiowym templatem.

```bash
npx create-react-app my-app --template typescript
```

## Komponenty

### Klasowe

Developerzy odchodz powoli od komponent贸w klasowych w Reacie, ale warto zawsze mie szersze spojrzenie na wiat Reacta. To samo tyczy si typowania, wic jak bdzie wyglda nasz **komponent klasowy** w poczeniu z **TypeScriptem**?

W poczeniu z TypeScriptem, `React.Component` jest typem generycznym i przyjmuj tak form:

```tsx
class App extends React.Component<Propsy, State> {...}
```

Sp贸jrzmy na przykadzie:

```tsx
type MyProps = {
  name: string;
  id: number;
};

type MyState = {
  age: number;
};

class App extends React.Component<MyProps, MyState> {
  state: MyState = {
    age: 20,
  };

  render() {
    const { name, id } = this.props;
    const { age } = this.state;
    return (
      <>
        <span>User name: {name}</span>
        <span>User id: {id}</span>
        <span>User age: {age}</span>
      </>
    );
  }
}

export default App;
```

Zamiast `type` mo偶esz r贸wnie偶 u偶ywa `interfejs贸w`, wspominaem o ich r贸偶nicach w [poprzednim wpisie](https://frontlive.pl/blog/typescript-sredniozaawansowany).

### Funkcyjne

Teraz co, co Reactowcy lubi najbardziej, czyli **komponenty funkcyjne**.

Mog by one otypowane jak **normalna funkcja**:

```tsx
type User = {
  name: string;
  age: number;
  isMarried: boolean;
};

const UserProfile = ({ name, age, isMarried }: User) => {...}
```

Na pewno niekt贸rzy z was mogli si spotka z czym takim jak `React.FC` lub `React.FunctionalComponent`.

`React.FC` w du偶ym uproszczeniu to po prostu **skr贸t** od `React.FunctionalComponent`.

```tsx
const UserProfile: React.FC<{ name: string; age: number }> = (name, age) => {...}
```

Co daje nam zastosowanie `React.FC`?

- Zapewnia typy dla _statycznych_ wartoci takich jak `defaultProps` i `propTypes`.
- Zapewnia definicj typ贸w dla `children`.

Z `React.FC` i `defaultProps` wi偶 si[pewne problemy](https://github.com/typescript-cheatsheets/react-typescript-cheatsheet/issues/87), warto mie to na uwadze.

Wykorzystanie z `React.FC` i `type`:

```tsx
const SomeProvider: React.FC = ({ children }) => <div>{children}</div>;
```

## Hooki

### useState

TypeScript nie jest gupi i w wielu przypadkach **sam si domyli,** jaki powinien by typ.

```tsx
const [isVisible, setVisibility] = useState(false);
```

Czsto jednak si zdarza, 偶e nasz `state` mo偶e by np. `null` lub `object`.
W takim przypadku musimy zadeklarowa typy, robimy to za pomoc nawias贸w - `< >`.
Taka konstrukcja mo偶e Ci si kojarzy z [typami generycznymi](https://frontlive.pl/blog/typescript-sredniozaawansowany/#typy-generycznegenerics).

```tsx
type User = {
  name: string;
  age: number;
};

const [user, setUser] = useState<User | null>(null);
```

### useEffect

W tym przypadku nie musimy si martwi typami, zadbajmy tylko o to, 偶eby zwraca `funkcj` lub `undefined`.

```tsx
type User = {
  name: string;
  id: number;
};

const UsersList = () => {
  const [users, setUsers] = useState<User[] | null>(null);

  useEffect(() => {
    const fetchUsers = async () => {
      const apiKey = `https://usersapi/all`;
      const getUsers = await fetch(apiKey);
      const usersData = await getUsers.json();
      setUsers(usersData);
    };
    fetchUsers();
  }, []);
};
```

### useRef

Tutaj podobna sytuacja jak w `useState`. Podajemy typ elementu i nulla.
Mamy tutaj jednak **dwie opcje**:

- Tylko do odczytu: `const ref = useRef<HTMLInputElement>(null!)`.
- Mutowalny, mo偶emy go zmienia: `const ref = useRef<HTMLInputElement | null>(null)`.

```tsx
const HappyInput = () => {
  const ref = React.useRef<HTMLInputElement | null>(null);

  const handleFocus = () => {
    // sprawdzamy czy current istnieje
    if (ref.current) {
      ref.current.focus();
    }
  };
  return (
    <div>
      <label>Focus ME!</label>
      <input ref={ref} placeholder="Happy input" />
      <button onClick={handleFocus}>Click to focus :)</button>
    </div>
  );
};
```

### useReducer

Sprawd藕my jak przerobi [przykad licznika](https://pl.reactjs.org/docs/hooks-reference.html#usereducer) z dokumentacji Reacta na TypeScripta.

Po kolei, definiujemy typ `State`, kt贸ry wykorzystujemy zar贸wno w **reducerze**, jak i w **pocztkowym stanie**. Przy reducerach fajnie sprawdzaj si [enumy](/typescript-podstawy/#enum).

`Action` to tzw. [Discriminated Unions](https://frontlive.pl/blog/typescript-sredniozaawansowany/#discriminated-unions).

```tsx
interface State {
  count: number;
}

enum Types {
  INCREMENT = 'INCREMENT',
  DECREMENT = 'DECREMENT',
}

type Action = { type: Types.INCREMENT } | { type: Types.DECREMENT };

const reducer = (state: State, action: Action) => {
  const { INCREMENT, DECREMENT } = Types;
  switch (action.type) {
    case INCREMENT:
      return { count: state.count + 1 };
    case DECREMENT:
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
};

const initialState: State = { count: 0 };

const Counter = () => {
  const [state, dispatch] = useReducer(reducer, initialState);
  const { INCREMENT, DECREMENT } = Types;
  return (
    <>
      Counter: {state.count}
      <button onClick={() => dispatch({ type: DECREMENT })}>-</button>
      <button onClick={() => dispatch({ type: INCREMENT })}>+</button>
    </>
  );
};
```

### Custom hooks

Wasne hooki s **super**! Jeli jeszcze nie stworzye swojego wasnego hooka, to zachcam, je偶eli jednak masz ju偶 to za sob, to sprawd藕 jak mo偶esz poczy wasne hooki i TypeScripta.

```tsx
// useToggle.tsx

import { useState } from 'react';

const useVisibility = () => {
  const [isVisible, setVisibility] = useState(false);

  const toggleVisibility = () => setVisibility((prevState) => !prevState);

  return [isVisible, toggleVisability];
};

export default useVisibility;

// App.tsx

const App = () => {
  const [isVisible, toggleVisibility] = useToggle();
  return (
    <>
      <button onClick={toggleVisibility}>Toggle me!</button>
      {isVisible ? (
        <span aria-label="wave hand" role="img">
          
        </span>
      ) : null}
    </>
  );
};
```

Wszystko wydaj si dziaa prawidowo, niestety mamy tutaj **bd** w `onClick`.
Z hooka zwracamy [union type](https://frontlive.pl/blog/typescript-sredniozaawansowany/#union-types-i-type-guard), co w naszym przypadku jest **niechcianym zachowaniem**.
Mo偶emy to zmieni na dwa sposoby:

- Zastosowa [const assertion](https://frontlive.pl/blog/typescript-podstawy/#const-assertions).
- Zwr贸ci warto jako [tuple array](https://frontlive.pl/blog/typescript-podstawy/#tuple-array).

Najlepszym sposobem bdzie opcja numer dwa, z **const assertion** wi偶 si[pewne problemy](https://github.com/babel/babel/issues/9800).

```tsx
// useToggle.tsx

import { useState } from 'react';

const useVisibility = () => {
  const [isVisible, setVisibility] = useState(false);

  const toggleVisibility = () => setVisibility((prevState) => !prevState);

  return [isVisible, toggleVisibility] as [boolean, () => void];
};

export default useVisibility;
```

## Formularze i zdarzenia

React zapewnia sw贸j system zdarze. Zobaczmy na podstawowy event `MouseEvent`.

```tsx
const App = () => {
  const handleClick = (event: React.MouseEvent) => {
    console.log(event.target);
  };

  return <button onClick={handleClick}>click</button>;
};
```

**MouseEvent** to tylko jeden z wielu event贸w, z tych popularniejszych mo偶na na pewno wspomnie o [ChangeEvent](https://developer.mozilla.org/en-US/docs/Web/API/ChangeEvent).

Mo偶emy r贸wnie偶 nadawa restrykcje typ贸w dla konkretnego eventu, powiedzmy, 偶e `handleClick` powinno by tylko dla przycisk贸w.

```tsx
const App = () => {
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    console.log(event.target);
  };

  return <button onClick={handleClick}>click</button>;
};
```

### Union types

Typy generyczne wspieraj [union types](https://frontlive.pl/blog/typescript-sredniozaawansowany/#union-types-i-type-guard), nic nie stoi na przeszkodzie, 偶ebymy taki zdefiniowali:

```tsx
const handleClick = (
  e: React.MouseEvent<HTMLButtonElement, MouseEvent> | React.FormEvent<HTMLFormElement>,
) => {
  console.log(e.target);
};
```

### SyntheticEvent

Syntetyczne zdarzenia to w du偶ym uproszczeniu wszystkie, wic jeli nie znajdujesz zdarzenia (np. onInput), mo偶esz u偶y **SyntheticEvent**.

```tsx
const handleSubmit = (e: React.SyntheticEvent) => {
  e.preventDefault();
  const target = e.target as typeof e.target & {
    email: { value: string };
    password: { value: string };
  };
};

<form ref={formRef} onSubmit={handleSubmit}>
  <div>
    <label>Email:</label>
    <input type="email" name="email" />
  </div>
  <div>
    <label>Password:</label>
    <input type="password" name="password" />
  </div>
</form>;
```

## Context

Wykorzystajmy nasz poprzedni przykad z **reducerem** do stworzenia contextu.
W tym wypadku pomijamy defaultow wartodla contextu, jest to spos贸b z u偶yciem takich ala hooks贸w zaprezentowanych przez [Kent C. Doddsa](https://kentcdodds.com/blog/how-to-use-react-context-effectively), dziki takiej metodzie **nie musimy** za ka偶dym razem sprawdza, czy `context !== undefined`.
Drugim znanym mi sposobem jest u偶ycie funkcji pomocniczej **createCtx**, o kt贸rej wicej mo偶esz przeczyta [tutaj](https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context).

```tsx
interface State {
  count: number;
}

enum Types {
  INCREMENT = 'INCREMENT',
  DECREMENT = 'DECREMENT',
}

type Action = { type: Types.INCREMENT } | { type: Types.DECREMENT };

type Dispatch = (action: Action) => void;

type CountProviderProps = { children: React.ReactNode };

const CountStateContext = React.createContext<State | undefined>(undefined);

const CountDispatchContext = React.createContext<Dispatch | undefined>(undefined);

const reducer = (state: State, action: Action) => {
  const { INCREMENT, DECREMENT } = Types;
  switch (action.type) {
    case INCREMENT:
      return { count: state.count + 1 };
    case DECREMENT:
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
};

const CountProvider = ({ children }: CountProviderProps) => {
  const [state, dispatch] = React.useReducer(countReducer, { count: 0 });
  return (
    <CountStateContext.Provider value={state}>
      <CountDispatchContext.Provider value={dispatch}>{children}</CountDispatchContext.Provider>
    </CountStateContext.Provider>
  );
};

const useCountState = () => {
  const context = React.useContext(CountStateContext);
  if (context === undefined) {
    throw new Error('useCountState must be used within a CountProvider');
  }
  return context;
};

const useCountDispatch = () => {
  const context = React.useContext(CountDispatchContext);
  if (context === undefined) {
    throw new Error('useCountDispatch must be used within a CountProvider');
  }
  return context;
};

export { CountProvider, useCountState, useCountDispatch };
```

## Portale

Przer贸bmy przykad z Reactowych docs贸w na TypeScripta. Wykorzystujemy tutaj [asercje typ贸w](https://frontlive.pl/blog/typescript-podstawy/#asercja-typow), reszta nie powinna by dla Ciebie nowoci.

```tsx
const Modal: React.FC = ({ children }) => {
  const modalRoot = document.getElementById('modal-root') as HTMLElement;
  const el: HTMLElement = document.createElement('div');

  useEffect(() => {
    modalRoot.appendChild(el);

    return () => modalRoot.removeChild(el);
  }, [el, modalRoot]);

  return ReactDOM.createPortal(children, el);
};
```

## HOC

Osobicie **nie jestem fanem** komponent贸w wy偶szego rzdu, chocia偶by dlatego, 偶e przy wikszych rozmiarach s one mao czytelne.
W dobie **IMHO lepszy rozwiza** takich jak render props czy te偶 wasnych hook贸w, HOC to rozwizanie, z kt贸rego najrzadziej korzystam.
Polecam Ci [to por贸wnanie](https://medium.com/simply/comparison-hocs-vs-render-props-vs-hooks-55f9ffcd5dc6), 偶eby sam okreli, co jest dla Ciebie najlepsz opcj.

Przejd藕my do meritum:

```tsx
function logProps<T>(WrappedComponent: React.ComponentType<T>) {
  return class extends React.Component {
    componentWillReceiveProps(nextProps: React.ComponentProps<typeof WrappedComponent>) {
      console.log('Current props: ', this.props);
      console.log('Next props: ', nextProps);
    }
    render() {
      return <WrappedComponent {...(this.props as T)} />;
    }
  };
}
```

Teraz pewnie pomylisz, **ale to jest nieczytelne**!! Ostrzegaem . Okej, ale co tu si stao? Nie bd omawia caej logiki komponentu, bo jest to przykad z dokumentacji, kt贸ry mo偶esz znale藕 [tutaj](https://pl.reactjs.org/docs/higher-order-components.html#dont-mutate-the-original-component-use-composition).
A co jeli chodzi o typy? Mamy tutaj [funkcj generyczn](https://frontlive.pl/blog/typescript-sredniozaawansowany/#funkcje), kt贸rej parametrem jest `WrappedComponent`, jest on r贸wnie偶 [typu generycznego](/typescript-sredniozaawansowany/#typy-generycznegenerics). Okej, to jest jasne a co z t dziwn konstrukcj? `...(this.props as T)`? Jest to spowodowane znanym ju偶 od wersji 3.2 problemem. Wicej mo偶esz dowiedzie si [w tym issue](https://github.com/Microsoft/TypeScript/issues/28938#issuecomment-450636046).

## Redux

W tej czci zajmiemy si Reduxem wraz z bibliotek [React Redux](https://react-redux.js.org/).

### Instalacja definicji typ贸w

Zacznijmy do zainstalowania definicji typ贸w:

```bash
npm install -D @types/react-redux
```

## Akcje

Zamiast `action constants` znalazem zastosowanie dla [enum贸w](https://frontlive.pl/blog/typescript-podstawy/#enum). Definiujemy tutaj enuma **UserTypes**, kt贸ry bdzie nam jeszcze potrzebny za chwil, przy reducerach. Jest jeszcze interface **UserActionTypes** i alias **Name**. Cao spinamy w nasz akcj:

```tsx
enum UserTypes {
  GET_NAME = 'GET_NAME',
}

interface UserActionTypes {
  type: UserTypes.GET_NAME;
  payload: string;
}

type Name = string;

export function getUserName(name: Name): UserActionTypes {
  return {
    type: SEND_MESSAGE,
    payload: name,
  };
}
```

## Reducery

Importujemy tutaj wczeniej przygotowane typy, nastpnie definiujemy interface **UserState**, kt贸ry p贸藕niej podajemy jako typ dla stanu pocztkowego. Ni偶ej mamy ju偶 tylko **reducer** i typ zwracanej wartoci oraz stanu.

```tsx
import { UserTypes, UserActionTypes } from "./types";

interface UserState {
  userName: string;
}

const initialState: UserState = {
  userName: "",
};

const { GET_NAME } = UserTypes;

const userReducer = ( state = initialState, action: UserActionTypes): UserState => {
  switch (action.type) {
    case : GET_NAME
      return {
        ...state
        userName: action.payload,
      };
    default:
      return state;
  }
}
```

### useSelector

Okej, przechodzimy do **React Redux**.

Najlepszym sposobem, wedug mnie, na otypowanie **useSelecotra** jest spos贸b z **useTypedSelector**.

```ts
import { useSelector, TypedUseSelectorHook } from 'react-redux';

interface RootState {
  isVisible: boolean;
}

export const useTypedSelector: TypedUseSelectorHook<RootState> = useSelector;
```

Importujemy **useSelector** i **TypedUseSelectorHook**, tworzymy zmienn, a waciwie **nowego, otypowane hooka**, kt贸ry przyjmuje typ generyczny `TypedUseSelectorHook`. Podajemy do niego typ **stanu pocztkowego** i gotowe!

Wykorzystanie:

```tsx
const isVisible = useTypedSelector((state) => state.isVisible);
```

### useDispatch

Warto zapamita, 偶e **defaultowym typem** dla dispatch jest `Dispatch`, **nie musimy** tutaj typowa niczego, no chyba, 偶e chcemy customowego dispatcha.

```tsx
// Store
export type AppDispatch = typeof store.dispatch;

// Zastosowanie w komponencie
const dispatch: AppDispatch = useDispatch();
```

## Thunk

**Redux Thunk** to jeden z najpopularniejszych middlewar贸w do Reduxa.
W Thunku mamy dostp do typu `ThunkAction`, jak wyglda on z definicji?

```ts
export type ThunkAction<R, S, E, A extends Action> = (
  dispatch: ThunkDispatch<S, E, A>,
  getState: () => S,
  extraArgument: E,
) => R;
```

Cao wydaje si **mocno przytaczajca** przez wszechobecne [typy generyczne](https:/frontlive.pl/blog/typescript-sredniozaawansowany/#typy-generycznegenerics).

Upromy sobie powy偶szy przykad:

```ts
type ThunkAction<generics> = (dispatch, getState, extraArgument) => ReturnType;
```

Co oznaczaj **R, S, E i A**?

- **R**: typ zwracany
- **S**: typ pocztkowego stanu i zwracanego z getState()
- **E**: dodatkowe argumenty
- **A**: typ akcji

Na pocztku warto zdefiniowa sobie aliasa typu, sama konstrukcja jest mao czytelna, wic zapiszmy j tylko raz.

```tsx
export type AppThunk = ThunkAction<void, RootState, null, Action<string>>;
```

- **R**: void
- **S**: RootState
- **E**: null
- **A**: Action

Wykorzystanie w akcji:

```tsx
export const fetchUser = (id: string): AppThunk => async (dispatch) => {
  try {
    // sukces
  } catch (err) {
    // niepowodzenie
  }
};
```

## Styled Components

Zacznijmy od zainstalowania definicji typ贸w:

```bash
npm install @types/styled-components
```

### Theme

Na pocztek, stw贸rzmy sobie plik `styled.d.ts` z deklaracj typ贸w. Deklarujemy teraz modu `styled-components` a w nim interface `DefaultTheme`.

```tsx
import 'styled-components';

declare module 'styled-components' {
  export interface DefaultTheme {
    primaryColor: string;
    secondaryColor: string;
  }
}
```

> DefaultTheme na pocztku jest pusty, dlatego musimy go rozszerzy.

Utw贸rzmy teraz nasz theme:

```ts
import { DefaultTheme } from 'styled-components';

const myTheme: DefaultTheme = {
  primaryColor: '#FF5733',
  secondaryColor: '#8A1800',
};

export { myTheme };
```

## Propsy

Najczciej jednak w SC korzystamy z props贸w, sp贸jrzmy na przykadzie:

```ts
const StyledHeading = styled.h2<{ customColor: string }>`
  color: ${(props) => props.customColor};
`;
```

Podajemy tutaj typ propsa w [object type literal](https://frontlive.pl/blog/typescript-sredniozaawansowany/#type-vs-interface).

## Podsumowanie

Dziki za wytrwanie do koca! Poni偶ej znajdziesz wszystkie 藕r贸da, z kt贸rych korzystaem tworzc ten wpis.
Szczeg贸lnie polecam Ci tego [cheatsheeta](https://react-typescript-cheatsheet.netlify.app/), jeli chcesz dowiedzie si jeszcze wicej.

Pamitaj, jeli nie jeste pewien jakiego typu, zawsze mo偶esz **najecha** na dan rzecz i si przekona, s jeszcze **definicj typ贸w**, w kt贸rych znajdziesz prawdopodobnie odpowied藕 na pytanie: **Ale jakiego to jest typu?**

Polecam Ci przewiczy cao na wasnym projekcie, w ten spos贸b **najlepiej utrwalisz** zdobyt wiedz.

Do usyszenia!

### 殴r贸da

- [React TypeScript CheatSheet](https://react-typescript-cheatsheet.netlify.app/)
- [TypeScript and React - FettBlog](https://fettblog.eu/typescript-react/)
- [How to use React Context effectively - Kent C. Dodds](https://kentcdodds.com/blog/how-to-use-react-context-effectively)
- [React & Redux in TypeScript](https://github.com/piotrwitek/react-redux-typescript-guide#general-tips)
- [Redux docs](https://redux.js.org/recipes/usage-with-typescript)
- [Understanding typings of redux-thunk action](https://bloggie.io/@_ChristineOo/understanding-typings-of-redux-thunk-action)
- [TypeScript React Cheat Sheet - SaltyCrane](https://www.saltycrane.com/cheat-sheets/typescript/react/latest/)
- [Styled Components docs](https://styled-components.com/docs/api#typescript)
