---
title: 'CSS Houdini - przyszo CSSa czy niepotrzebna nowo?'
category: 'CSS'
publishedAt: '03-07-2020'
isPublished: true
popular: true
excerpt: 'CSS Houdini to zbi贸r API, udostpnionych przez przegldark, dziki kt贸rym, mamy bezporedni dostp do drzewka CSSOM.'
---

**CSS Houdini** to zbi贸r API, udostpnionych przez przegldark, dziki kt贸rym, mamy **bezporedni** dostp do drzewka [CSSOM](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model)(CSS Object Model). Pozwala nam to **rozszerza** CSSa o nowe funkcjonalnoci, _wpina_ si do _silnika renderujcego_ i m贸wi przegldarce, w **jaki spos贸b** ma wykorzysta CSSa podczas renderowania. A to wszystko z pomoc **JavaScriptu**!

> Wsparcie przegldarek dla Houdini r贸偶ni sidla ka偶dego API, jeli chcesz zobaczy peen wykres wsparcia, zachcam Cido odwiedzenia https://ishoudinireadyyet.com/.

## Dlaczego warto?

Po pierwsze, nowoci wprowadzane do CSSa czsto potrzebuj [pollyfilli](https://pl.wikipedia.org/wiki/Polyfill), mog by one na bazie JavaScriptu, jednak te nios ze sob problemy z wydajnoci. Dzieje sitak dlatego, 偶e musz one poczeka a偶 [DOM](https://developer.mozilla.org/pl/docs/DOM_i_JavaScript) i [CSSOM](https://developer.mozilla.org/en-US/docs/Web/API/CSS_Object_Model) si utworz. Gdy drzewa sistworz i nasz dokument zostanie zaadowany, koczy si**pierwszy cykl renderowania**, dopiero po nim nasz pollyfill mo偶e zadziaa. W **CSS Houdini** nie czekamy na ten pierwszy cykl renderowania.

Nastpn zalet jest, powizan ju偶 z poprzedni, jest fakt, i偶 **nie musimy czeka** na nowoci, a偶 zostan wprowadzone do przegldarek.

## Spis treci

- [TypedOM API](#typedom-api)
  - [computedStyleMap](#computedstylemap)
  - [attributeStyleMap](#attributestylemap)
  - [CSSStyleValue](#cssstylevalue)
- [Custom Properties And Values API](#custom-properties-and-values-api)
- [Paint API](#paint-api)
- [Animation API](#animation-api)
- [Layout API](#layout-api)
- [Wsparcie przegldarek](#wsparcie-przegladarek)
- [Przyszo CSS czy niepotrzebna nowo?](#przyszlosc-css-czy-niepotrzebna-nowosc)
- [Podsumowanie](#podsumowanie)
  - [殴r贸da](#zrodla)

## TypedOM API

Jak mo偶emy zmienia CSSowe wartoci w JavaScripcie?

Nic prostszego, pobieramy element, piszemy `.style` i wybran warto:

```js
button.style.fontSize = 32 + 'px';
```

Nie jest to przyjemny spos贸b, mo偶e rodzi wiele **problem贸w i bug贸w**.

### computedStyleMap

W **TypedOM** manipulacja CSSem, jest bardziej logiczna, prostsza i szybsza. Zamiast string贸w dostajemy obiekt `CSSStyleValue` z kluczami i wartociami:

```
{
  value: 20,
  unit: "px"
}
```

```js
const button = document.querySelector('.button');

button.computedStyleMap().get('font-size');
```

Wykorzystujemy tutaj metod `computedStyleMap()`, zwraca nam ona wszystkie style danego elementu z **stylesheeta** (computed styles). Dziki niej mamy dostp do metody `get()`, kt贸ra zwraca dan wasno. Opr贸cz niej mamy dostp r贸wnie偶 do metod: `set()`,`delete()`,`has()` i `append()`.

### attributeStyleMap

Opr贸cz `computedStyleMap()` mamy r贸wnie偶 dostp do wartoci `attributeStyleMap`. Mo偶emy, dziki niej, pobiera, zamiast computed styles, wartoci inlinowe.

```js
let heightValue = element.attributeStyleMap.get('height');
heightValue.value++;
target.attributeStyleMap.set('height', heightValue);
```

### CSSStyleValue

TypedOM udostpnia nam r贸wnie偶 klas w kt贸rej wszystkie CSSowe **wartoci s opisane**. Dziki temu mamy dostp do jej _subklas_: `CSSKeywordValue`, `CSSNumericValue`,`CSSTransformValue`, `CSSResourceValue`.

Dziki `CSSKeywordValue` do sl贸w kluczowych, np. `none`:

```js
element.attributeStyleMap.set("display", new CSSKeywordValue("none")));
```

Obiekty `CSSNumericValue` mo偶emy podzieli na `CSSUnitValues` i `CSSMathValues`. Ta pierwsza reprezentuje **numeryczne** wartoci wraz z jednostkami, np. `CSSUnitValue(12, 'px')`, ta druga za bardziej **zaawansowane** operacje, np. `CSSMathSum(CSS.em(5), CSS.px(5))`, odpowiada to znanemu ju偶 ze _zwykego_ CSSa `calc(5em + 5px)`.

Dziki `CSSTransformValue` mo偶emy wpywa na wartoci `transform`, a `CSSResourceValue` na np. `background-image`(za pomoc `CSSImageValues`).

## Custom Properties And Values API

Custom Properties And Values pozwala nam **rozszerza** zmienne CSSowe dodajc do nich pewnie ciekawe ficzery.
呕eby je stworzy u偶ywamy specjalnej metody `registerProperty()`, metoda ta przyjmuje pewne argumenty:

- `name` - nazwa
- `syntax` - m贸wi przegldarce jak j parsowa, mamy do dyspozycji np. `<color>`, `<integer>`, `<number>`, `<percentage>`
- `inherits` - informacja o dziedziczeniu przez rodzica, mo偶liwe opcje: `true` lub `false`
- `initialValue` - pocztkowa warto

```js
// JS
CSS.registerProperty({
  name: '--box__gradient--position',
  syntax: '<percentage>',
  initialValue: '60%',
  inherits: false,
});
```

```css
// CSS
.box {
  width: 20rem;
  height: 20rem;
  background: linear-gradient(
    45deg,
    rgba(255, 255, 255, 1) 0%,
    var(--box__color) var(--box__gradient--position)
  );
  transition: --box__color 0.5s ease, --box__gradient--position 1s 0.5s ease;
}

.box:hover {
  --box__color: #baebae;
  --box__gradient--position: 0%;
}
```

Tym sposobem **osignlimy nieosigalne** w CSS - **zanimowalimy gradient**.

## Paint API

Zanim zaczniemy, Paint API jest **Workletem**. A co to ten Worklet? Worklety to moduy czy te偶 skrypty dziaajce w osobnym wtku JavaScriptu. Maj imitowa natywn funkcjonalno przegldarki. Worklet wywoujemy specjaln funkcj `addModule`, kt贸ra jest obietnic.

```js
await demoWorklet.addModule("path/to/script.js");

Promise.all([
  demoWorklet1.addModule("script1.js"),
  demoWorklet2.addModule("script2.js"),
]).then((results) => {...});
```

Okej to tyle odnonie **Worklet贸w**, przejd藕my do **Paint API!**

Dziki **Paint API** mo偶emy rysowa, za pomoc `context`(tak, to ten context z canvasa ), bezporednio do waciwoci elementu takich jak `background-image`. Je偶eli znacie `canvasa` bdziecie czuli si jak w domu.

Tworzymy Worklet!

```js
registerPaint(
  'paintWorketExample',
  class {
    static get inputProperties() {
      return ['--myVariable'];
    }
    static get inputArguments() {
      return ['<color>'];
    }
    static get contextOptions() {
      return { alpha: true };
    }

    paint(ctx, size, properties, args) {
      /* ... */
    }
  },
);
```

- `inputProperties` - tablica `custom properties`, kt贸rych Worklet ma _ledzi_
- `<color>` - tablica argument贸w, jakie mog by podane podczas wywoania
- `contextOptions` - pozwala nam ustawi `aplp`, czyli takie `opacity` dla kolor贸w, jeli warto bdzie false, wszystkie kolory bd miay 100% `opacity`
- `paint` - tutaj dziej si caa magia, funkcja mo偶e przyj kilka parametr贸w, `ctx` jest praktycznie tym samym jak `ctx` w canvasie, `size` jest obiektem skadajcym si z rozmiar贸w elementu `width` i `height`,`properties` s definiowane przez `inputProperties`, a args przez `inputArguments`.

Rejestracja Workleta w g贸wym pliku `.js`:

```js
CSS.paintWorklet.addModule('cie偶ka_do_workleta.js');
```

**U偶ycie w CSS:**

```css
.exampleElement {
  background-image: paint(paintWorketExample, blue);
}
```

Wywoujemy tutaj wczeniej napisan funkcj `paint()`, argument `paintWorketExample` to **nazwa** Workletu, a `blue` to podane **argumenty**.

![Przykad wykorzystania Paint API](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/f4bfba2d-a245-4b76-a303-b0e78b0c293b/2-image-paint-api.gif)

> Peny kod tego przykadu 锔 mo偶ecie znale藕 [na Githubie GoogleChromeLabs](https://github.com/GoogleChromeLabs/houdini-samples/blob/master/paint-worklet/ripple/index.html)

## Animation API

Ten **Worklet** pozwala nam **nasuchiwa** na przer贸偶ne eventy takie jak `scroll`,`hover` czy `click`. Dodatkowo, wpywa bardzo dobrze na wydajno(w por贸wnaniu chocia偶by do `requestAnimationFrame`) poniewa偶 dziaa na osobnym wtku.

```js
registerAnimator(
  'animationWorkletExample',
  class {
    constructor(options) {
      /* ... */
    }
    animate(currentTime, effect) {
      /* ... */
    }
  },
);
```

- `constructor` - ustawiamy tutaj _setup_ naszego Workleta, odpalany przy stworzeniu nowej instancji
- `animate` - tutaj trafia caa logika, `currentTime` to aktualna warto czasu dla animacji, `effect` jest tablic efekt贸w, kt贸rych u偶ywa animacja

Wywoanie Workleta w gowyn pliku `.js`:

```js
async function init() {
  await CSS.animationWorklet.addModule('cie偶ka_do_workleta.js');

  const effect = new KeyframeEffect(
    document.querySelector('#rotation'),
    [
      {
        transform: 'rotateZ(0deg) ',
      },
      {
        transform: 'rotateZ(-280deg)',
      },
    ],
    {
      duration: 3000,
      iterations: 5,
    },
  );

  new WorkletAnimation('animationWorkletExample', effect, document.timeline, {}).play();
}

init();
```

Wyjanijmy sobie powy偶szy przykad, tak jak zawsze, na pocztku **pobieramy** nasz Worklet, nastpnie **inicjujemy klas** `WorkletAnimation`. A w niej pojawia si nasz efekt - `KeyframeEffect`. Pierwszy **podajemy element**, kt贸ry ma by animowany. Nastpnie podajemy tablic obiekt贸w z `keyframesami` i dodatkowe opcje takie jak: **czas trwania animacji** i **liczba iteracji**. P贸藕niej ju偶 tylko o czasu `currentTime` i dodatkowe opcje dla **konstruktora**.

![Przykad wykorzystania Animation API](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/66382772-0c0c-4b34-9326-4451db5d9c15/3-image-animation-api.gif)

> Peny kod tego przykadu 锔 mo偶ecie znale藕 [na Githubie houdini-examples](https://github.com/GoogleChromeLabs/houdini-samples/blob/master/paint-worklet/ripple/index.html)

## Layout API

Ostatni ju偶 w Worklet贸w, rozszerza nam mo偶liwoci jakie daje nam przegldarka w ramach tworzenia **layoutu**. Dziki temu mo偶emy stworzy wasn warto dla `display`, na przykad `masonry`.

```js
registerLayout(
  'exampleLayout',
  class {
    static get inputProperties() {
      return ['--exampleVariable'];
    }

    static get childrenInputProperties() {
      return ['--exampleChildVariable'];
    }

    static get layoutOptions() {
      return {
        childDisplay: 'normal',
        sizing: 'block-like',
      };
    }

    intrinsicSizes(children, edges, styleMap) {
      /* ... */
    }

    layout(children, edges, constraints, styleMap, breakToken) {
      /* ... */
    }
  },
);
```

- `inputProperties` - tak jak w przypadku **Paint API**, tylko w tym przypadku Worklet _ledzi_ `custom properties`, kt贸re przynale偶 do **rodzica** elementu
- `childrenInputProperties` - podobnie do `inputProperties`, tym razem _ledzimy_ `custom properties` dla **dzieci** elementu
- `layoutOptions` - znajdziemy tutaj `childDisplay`, kt贸ry definiuje **w jaki spos贸b** maj zosta wywietlone **dzieci** elementu, jako `block`(**blokowo**), czy te偶 `normal`(**inlinowo**). Za to `sizing` mo偶e mie pre-definiowane warto `block-like` lub `manual`. M贸wi to przegldarce czy ma **przekalkulowa** rozmiar elementu, czy te偶 nie.
- `intrinsicSizes` - definiuje w jaki spos贸b kontener lub jego dzieci maj sizachowywa w kontekcie **layoutu**.
- `layout` - g贸wna funkcja do **tworzenia** naszego layoutu, mo偶emy wykorzysta tutaj **dzieci elementu**, ustawi **krawdzie** i **ograniczenia**.

Odpalenie Workleta w g贸wnym pliku `.js`:

```js
async function init() {
  await CSS.animationWorklet.addModule('cie偶ka_do_workleta.js');
}
init();
```

Wykorzystanie w CSS:

```css
.exampleElement {
  display: layout(exampleLayout);
}
```

- `exampleLayout` - nazwa Workletu
  ![Przykad wykorzystania Layout API](https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6ede5f0c-d568-49fe-a83b-1a9561c2fded/4-image-layout-api.gif)

> Peny kod tego przykadu 锔 mo偶ecie znale藕 [na Githubie houdini-examples](https://github.com/codeAdrian/houdini-examples/tree/master/layout-api-example)

## Wsparcie przegldarek

Wsparcie przegldarek dla **CSS Houdini** jest w tym momencie raczej rednie. Ale jestem pewien, 偶e w najbli偶ej przyszoci sytuacja **znacznie si poprawia**.

Warto jednak da **Houdini** szans i wykorzystywa t technologi w nurcie [Progressive Enhancement](https://en.wikipedia.org/wiki/Progressive_enhancement).

Je偶eli chcecie na bie偶co ledzi wsparcie dla **CSS Houdini**, to polecam Wam rzuci okiem na [ishoudinireadyyet](https://ishoudinireadyyet.com/) 

![Wspracie przegldarek dla CSS Houdini](../images/wsparcie-houdini.png)

## Przyszo CSS czy niepotrzebna nowo?

Dla mnie jest to zdecydowanie **przyszo CSSa**. Mamy dostp do kilku wietnych API, mo偶emy dodawa nowe funkcjonalnoci dla naszych styli, jednym sowem **Houdini to przyszo**!

Poza tym, przez fakt, 偶e mo偶emy **wpina** si do procesu renderowania, nasze strony i aplikacje staj si **szybsze** i **wydajniejsze**.

## Podsumowanie

Jak si Wam podoba **CSS Houdini**? Dajcie zna 

Nie jest to na pewno atwe rozwizanie, najwiksze problemy mo偶e sprawia [Layout API](/#layout-api), jednak **warto si pobawi**, chocia偶by [w tym playgroudzie](https://houdini.glitch.me/).

Zostawiam, jak zawsze, przydatne **linki i 藕r贸da**, tym samym zachcam do gbszego poznawania **Houdini**!

Do usyszenia!

### 殴r贸da

- [MDN - CSS Houdini](https://developer.mozilla.org/en-US/docs/Web/Houdini)
- [A Practical Overview Of CSS Houdini](https://www.smashingmagazine.com/2020/03/practical-overview-css-houdini/)
- [Houdini Examples](https://github.com/codeAdrian/houdini-examples)
- [W3C - CSS Houdini Drafts Examples ](https://github.com/w3c/css-houdini-drafts)
- [W3C - CSS Houdini Drafts Spec](https://drafts.css-houdini.org/)
- [Google Chrome Labs - Houdini Demo](https://googlechromelabs.github.io/houdini-samples/)
- [Ishoudinireadyyet](https://ishoudinireadyyet.com/)
