---
title: 'TypeScript - podstawowe typy'
category: 'TypeScript'
publishedAt: '09-10-2020'
popular: false
excerpt: 'Visualize my journey through the scenic lands of Norway with rich, stunning pictures and daily travel logs.'
---

- lol
- lol

1. asda
2. asdada

> BlockQuote

[Funkcje](#funkcje)

![](https://www.frontlive.pl/static/6ccf44663600ead8bd4cfb84f8614f22/4d3f1/clamp-wsparcie.png)

<Player url="https://www.youtube.com/watch?v=cwV-wiTUG3k" />
<Player
  url="https://www.frontlive.pl/5779f671e16e962a6c4791c5430389cc/fluid-1.mp4"
  label="Frontlive video"
/>

## Wprowadzenie

W poprzednim wpisie poznae podstawy <Sparkles>TypeScriptu</Sparkles>, mam nadziej, 偶e przewiczye je w praktyce!
Dzi co dla fan贸w OOP, ale nie tylko! Poznamy r贸wnie偶 **Generics** i zaawansowane typy.

## Klasy

Jeli nie poznae jeszcze klas w JavaScripcie, zachcem Ci do sprawdzenia [tego materiau](http://kursjs.pl/kurs/es6/class.php). Nie bdziemy bowiem tutaj si zagbia w to czym s klasy, jak dziaaj, tylko po to, 偶eby nie traci Twojego czasu.

![Alt](https://www.frontlive.pl/static/de5b6c8c6f74a403a8a5a08e1cbae377/4fcb7/DevTools-vision.jpg)

### Public

`public` w TypeScripcie dziaaj tak jak \*normalne waciwoci, nie musisz ich oznacza.

```ts{1-5}
class Person {
  public name: string;
  public constructor(personName: string) {
    this.name = personName;
  }

  public getPersonAge(personAge: number) {
    console.log(`${this.name} is ${personAge} years old`);
  }
}
```

> \*Public znajduje swoje zastosowanie w parametrach konstruktora, o kt贸rych za chwilk.

### Private

Ka偶d waciwo mo偶emy zmieni na prywatn, poprzedzajc j sowem `private`.
Taka waciwo nie bdzie dostpna poza klas, w kt贸rej si znajduje.

```ts
class Person {
  private name: string;

  constructor(personName: string) {
    this.name = personName;
  }

  public getPersonAge(personAge: number) {
    console.log(`${this.name} is ${personAge} years old`);
  }
}

const employer = new Person('Jakub');
employer.name; // error
```

> Ciekawostka: Prywatne waciwoci nie s chronione podczas runtime'u

### Protected

Podobne do `private`, r贸偶ni si tym, 偶e `protected` mo偶emy u偶y podczas **dziedziczenia**.

```ts
class Person {
  protected name: string;

  constructor(personName: string) {
    this.name = personName;
  }

  public getPersonAge(personAge: number) {
    console.log(`${this.name} is ${personAge} years old`);
  }
}

class Employee extends Person {
  private company: string;

  constructor(name: string, company: string) {
    super(name);
    this.company = company;
  }

  public printEmployeeInfo() {
    return `Hi, I'm ${name} and I work for ${this.company}`;
  }
}

const jakub = new Employee('Jakub', 'Firma_Krzak');
jakub.printEmployeeInfo(); // Hi, I'm Jakub and I work for Firma_Krzak
jakub.name; // error
```

Zauwa偶, 偶e nie mo偶emy u偶y `name` poza klas, a jedynie w klasie dziedziczcej, lub w niej samej.

#### Protected Constructor

Wykorzystajmy nabyt wiedz i u偶yjmy `protected` przy konstruktorze. Co daje nam taki zabieg? Dziki temu bdziemy mogli **tylko** dziedziczy dan klas, a nie j instancjonowa.

```ts
class Person {
  protected constructor(protected personName: string) {}
}

class Employee extends Person {
  private company: string;
  constructor(name: string, company: string) {
    super(name);
    this.company = company;
  }

  public printEmployeeInfo() {
    return `Hi, I'm ${name} and I work for ${this.company}`;
  }
}

const jakub = new Employee('Jakub', 'Firma_Krzak'); // Wszystko ok
const bartek = new Person('Bartek'); // error
```

### Readonly

Znane Ci ju偶 `readonly` mo偶emy u偶y r贸wnie偶 w klasach:

```ts
class Person {
  protected readonly name: string;
  constructor(personName: string) {
    this.name = personName;
  }
  changeName() {
    this.name = 'Marek'; // error
  }
}
```

### Parametry konstruktora

Mamy mo偶liwo, by u偶y powy偶szych parametr贸w w naszym konstruktorze! Tutaj `public` mo偶e nam si przyda. Co daje nam, w tym przypadku, TypeScript?

- Deklaruje **instancje** waciwoci **o tej samej nazwie**
- Przypisuje dany **parametr** do tej **instancji**

Poni偶sze klasy dziaaj na takiej samej zasadzie.

```ts
// Wersja pierwsza
class Person {
  name: string;
  protected age: number;
  private readonly isMarried: boolean;
  constructor(name: string, age: number, isMarried: boolean) {
    this.name = name;
    this.age = age;
    this.isMarried = isMarried;
  }
}

// Parametry konsturktora

class Person {
  constructor(public name: string, protected age: number, private readonly isMarried: boolean) {}
}
```

### Interfejsy w klasach

Mam nadziej, 偶e kojarzysz podstawowe zao偶enia idce za **Interfejsami**. Jeli nie, zachcam Ci do sprawdzenia [poprzedniego wpisu](https://www.frontlive.pl/typescript-podstawy/).

Interfejsy wykorzystujemy w klasach, u偶ywajc sowa `implements`.
Mo偶emy ich poda kilka, mog r贸wnie偶 by one rozszerzane.

```ts
interface PersonAge {
  getPersonAge(personAge: number): void;
}

class Person implements PersonAge {
  protected name: string;
  constructor(personName: string) {
    this.name = personName;
  }
  public getPersonAge(personAge: number) {
    console.log(`${this.name} is ${personAge} years old`);
  }
}
```

### Klasy abstrakcyjne

Klas abstrakcyjnych **nie mo偶emy** instancjonowa. **Tylko klasy dziedziczne** mog to robi, no chyba, 偶e s r贸wnie偶 abstrakcyjne. Abstrakcyjne klasy mog r贸wnie偶 posiada abstrakcyjne **metody**, nie mog by one implementowane, posiadaj tylko tzw. _sygnatur typ贸w_. Do oznaczania abstrakcyjnych klas i ich metod u偶ywamy sowa `abstract`.

```ts
abstract class Person {
  constructor(readonly name: string) {}
  abstract getPersonAge(personAge: number): void;
}

const jakub = new Person('Jakub'); // error
```

Przypominaj one Intefejsy, ale nimi nie s. Abstrakcyjne klasy mog zawiera r贸wnie偶 metody z jak implementacj (metody bez `abstract`), interfejsy tego nie robi.

> Ciekawostka: _Abstrakcyjne_ klasy wystpuj tylko w procesie kompilacji, podczas runtime'u zachowuj si jak normalne klasy.

## Typy generyczne(Generics)

Pozwalaj nam one nadawa **dynamicznie typy**. Wyznaczaj, w pewnym sensie, kolejny poziom _abstrakcji_. Maj zastosowanie w funkcjach, interfejsach i klasach.

### Funkcje

Sp贸jrzmy na przykad (to jeszcze nie jest typ generyczny):

```ts
function identity(arg: number): number {
  return arg;
}
```

Mamy tutaj funkcj, kt贸ra przyjmuje parametr typu `number` i po prostu go zwraca. Jest par problem贸w z t funkcj. Po pierwsze, ci偶ko by nam byo j w jakimstopniu **rozbudowa**, a poza tym mamy tutaj na sztywno wklepany typ `number`, dla argumentu i zwracanej wartoci. Pierwsza myl, kt贸ra mogaby Ci przyj do gowy, to u偶ycie `any`. **Nie jest** to jednak dobry spos贸b, tracimy wtedy ca kontrol nad typami.

Przeksztamy teraz nasz funkcj na funkcj generyczn.

```ts
function someFunc<T>(arg: T): T {
  return arg;
}

someFunc<string>('Awesome!'); // Awesome
```

Po nazwie funkcji podajemy `<T>`, to samo jeli chodzi o typ parametru i zwracany typ, tylko 偶e bez nawias贸w. Jeli mamy jeden argument, czsto spotykan praktyk jest u偶ycie wanie literki **T**, drugi argument za to mo偶e by jako **U**.
Przeksztamy teraz funkcje tak, aby zwracaa tuple medali olimpijskich.

```ts
function getOlympicMedals<T, U>(arg1: T, arg2: U): [T, U] {
  return [arg1, arg2];
}

getOlympicMedals<string, string>('1st ', '2nd '); // ["1st ","2nd "]
```

### Klasy

Typ贸w generycznych, jak ju偶 wczeniej wspominaem, mo偶emy u偶y r贸wnie偶 z klasami:

```ts
class Animal<T> {
  constructor(public name: T) {}

  getAnimalName(name: T) {
    console.log(name);
  }
}
const giraffe = new Animal<string>('Skittles');
giraffe.getAnimalName('Skittles');
```

### Interfejsy

Przyszed czas na _generyczne interfejsy_, tutaj podobna sytuacja.

```ts
interface Person<V, W> {
  userName: V;
  hobbies: W[];
}

function getUserInfo<T, U>(userName: T, hobbies: U[]): Person<T, U> {
  const user: Person<T, U> = {
    userName,
    hobbies,
  };
  return user;
}
getUserInfo<string, string>('Przemek', ['programming', 'boxing', 'windsurfing']);
```

### Generic Constraints

Jest to pewne nadawanie restrykcji dla generycznych typ贸w. W tym celu u偶ywamy sowa `extends`.
Mamy tutaj interfejs `User`, kt贸rego warto **age** jest typu `number`. W funkcji rozszerzamy typ U typem `User[]`.

```ts
interface User {
  age: number;
}

function combineUserInfo<T extends object, U extends User[]>(a: T, b: U) {
  return Object.assign(a, b);
}
combineUserInfo({ name: 'Bob' }, [{ age: 23 }]);
```
