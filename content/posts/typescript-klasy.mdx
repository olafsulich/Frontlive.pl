---
title: 'TypeScript - Generics, klasy i zaawansowane typy'
category: 'TypeScript'
publishedAt: '15-05-2020'
popular: false
excerpt: 'Zagbiamy si w TypeScripta. W tym wpisie poznasz typy genereczyne, typy zaawansowane, a i dla fan贸w OOP co si r贸wnie偶 znajdzie!'
---

## Wprowadzenie

W poprzednim wpisie poznae podstawy TypeScriptu, mam nadziej, 偶e przewiczye je w praktyce!
Dzi co dla fan贸w OOP, ale nie tylko! Poznamy r贸wnie偶 **Generics** i zaawansowane typy.

## Klasy

Jeli nie poznae jeszcze klas w JavaScripcie, zachcem Ci do sprawdzenia [tego materiau](http://kursjs.pl/kurs/es6/class.php). Nie bdziemy bowiem tutaj si zagbia w to czym s klasy, jak dziaaj, tylko po to, 偶eby nie traci Twojego czasu.

### Public

`public` w TypeScripcie dziaaj tak jak \*normalne waciwoci, nie musisz ich oznacza.

```ts
class Person {
  public name: string;

  public constructor(personName: string) {
    this.name = personName;
  }

  public getPersonAge(personAge: number) {
    console.log(`${this.name} is ${personAge} years old`);
  }
}
```

> \*Public znajduje swoje zastosowanie w parametrach konstruktora, o kt贸rych za chwilk.

### Private

Ka偶d waciwo mo偶emy zmieni na prywatn, poprzedzajc j sowem `private`.
Taka waciwo nie bdzie dostpna poza klas, w kt贸rej si znajduje.

```ts
class Person {
  private name: string;

  constructor(personName: string) {
    this.name = personName;
  }

  public getPersonAge(personAge: number) {
    console.log(`${this.name} is ${personAge} years old`);
  }
}

const employer = new Person('Jakub');
employer.name; // error
```

> Ciekawostka: Prywatne waciwoci nie s chronione podczas runtime'u

### Protected

Podobne do `private`, r贸偶ni si tym, 偶e `protected` mo偶emy u偶y podczas **dziedziczenia**.

```ts
class Person {
  protected name: string;

  constructor(personName: string) {
    this.name = personName;
  }

  public getPersonAge(personAge: number) {
    console.log(`${this.name} is ${personAge} years old`);
  }
}

class Employee extends Person {
  private company: string;

  constructor(name: string, company: string) {
    super(name);
    this.company = company;
  }

  public printEmployeeInfo() {
    return `Hi, I'm ${name} and I work for ${this.company}`;
  }
}

const jakub = new Employee('Jakub', 'Firma_Krzak');
jakub.printEmployeeInfo(); // Hi, I'm Jakub and I work for Firma_Krzak
jakub.name; // error
```

Zauwa偶, 偶e nie mo偶emy u偶y `name` poza klas, a jedynie w klasie dziedziczcej, lub w niej samej.

#### Protected Constructor

Wykorzystajmy nabyt wiedz i u偶yjmy `protected` przy konstruktorze. Co daje nam taki zabieg? Dziki temu bdziemy mogli **tylko** dziedziczy dan klas, a nie j instancjonowa.

```ts
class Person {
  protected constructor(protected personName: string) {}
}

class Employee extends Person {
  private company: string;
  constructor(name: string, company: string) {
    super(name);
    this.company = company;
  }

  public printEmployeeInfo() {
    return `Hi, I'm ${name} and I work for ${this.company}`;
  }
}

const jakub = new Employee('Jakub', 'Firma_Krzak'); // Wszystko ok
const bartek = new Person('Bartek'); // error
```

### Readonly

Znane Ci ju偶 `readonly` mo偶emy u偶y r贸wnie偶 w klasach:

```ts
class Person {
  protected readonly name: string;
  constructor(personName: string) {
    this.name = personName;
  }
  changeName() {
    this.name = 'Marek'; // error
  }
}
```

### Parametry konstruktora

Mamy mo偶liwo, by u偶y powy偶szych parametr贸w w naszym konstruktorze! Tutaj `public` mo偶e nam si przyda. Co daje nam, w tym przypadku, TypeScript?

- Deklaruje **instancje** waciwoci **o tej samej nazwie**
- Przypisuje dany **parametr** do tej **instancji**

Poni偶sze klasy dziaaj na takiej samej zasadzie.

```ts
// Wersja pierwsza
class Person {
  name: string;
  protected age: number;
  private readonly isMarried: boolean;
  constructor(name: string, age: number, isMarried: boolean) {
    this.name = name;
    this.age = age;
    this.isMarried = isMarried;
  }
}

// Parametry konsturktora

class Person {
  constructor(public name: string, protected age: number, private readonly isMarried: boolean) {}
}
```

### Interfejsy w klasach

Mam nadziej, 偶e kojarzysz podstawowe zao偶enia idce za **Interfejsami**. Jeli nie, zachcam Ci do sprawdzenia [poprzedniego wpisu](https://www.frontlive.pl/typescript-podstawy/).

Interfejsy wykorzystujemy w klasach, u偶ywajc sowa `implements`.
Mo偶emy ich poda kilka, mog r贸wnie偶 by one rozszerzane.

```ts
interface PersonAge {
  getPersonAge(personAge: number): void;
}

class Person implements PersonAge {
  protected name: string;
  constructor(personName: string) {
    this.name = personName;
  }
  public getPersonAge(personAge: number) {
    console.log(`${this.name} is ${personAge} years old`);
  }
}
```

### Klasy abstrakcyjne

Klas abstrakcyjnych **nie mo偶emy** instancjonowa. **Tylko klasy dziedziczne** mog to robi, no chyba, 偶e s r贸wnie偶 abstrakcyjne. Abstrakcyjne klasy mog r贸wnie偶 posiada abstrakcyjne **metody**, nie mog by one implementowane, posiadaj tylko tzw. _sygnatur typ贸w_. Do oznaczania abstrakcyjnych klas i ich metod u偶ywamy sowa `abstract`.

```ts
abstract class Person {
  constructor(readonly name: string) {}
  abstract getPersonAge(personAge: number): void;
}

const jakub = new Person('Jakub'); // error
```

Przypominaj one Intefejsy, ale nimi nie s. Abstrakcyjne klasy mog zawiera r贸wnie偶 metody z jak implementacj (metody bez `abstract`), interfejsy tego nie robi.

> Ciekawostka: _Abstrakcyjne_ klasy wystpuj tylko w procesie kompilacji, podczas runtime'u zachowuj si jak normalne klasy.

## Typy generyczne(Generics)

Pozwalaj nam one nadawa **dynamicznie typy**. Wyznaczaj, w pewnym sensie, kolejny poziom _abstrakcji_. Maj zastosowanie w funkcjach, interfejsach i klasach.

### Funkcje

Sp贸jrzmy na przykad (to jeszcze nie jest typ generyczny):

```ts
function identity(arg: number): number {
  return arg;
}
```

Mamy tutaj funkcj, kt贸ra przyjmuje parametr typu `number` i po prostu go zwraca. Jest par problem贸w z t funkcj. Po pierwsze, ci偶ko by nam byo j w jakimstopniu **rozbudowa**, a poza tym mamy tutaj na sztywno wklepany typ `number`, dla argumentu i zwracanej wartoci. Pierwsza myl, kt贸ra mogaby Ci przyj do gowy, to u偶ycie `any`. **Nie jest** to jednak dobry spos贸b, tracimy wtedy ca kontrol nad typami.

Przeksztamy teraz nasz funkcj na funkcj generyczn.

```ts
function someFunc<T>(arg: T): T {
  return arg;
}

someFunc<string>('Awesome!'); // Awesome
```

Po nazwie funkcji podajemy `<T>`, to samo jeli chodzi o typ parametru i zwracany typ, tylko 偶e bez nawias贸w. Jeli mamy jeden argument, czsto spotykan praktyk jest u偶ycie wanie literki **T**, drugi argument za to mo偶e by jako **U**.
Przeksztamy teraz funkcje tak, aby zwracaa tuple medali olimpijskich.

```ts
function getOlympicMedals<T, U>(arg1: T, arg2: U): [T, U] {
  return [arg1, arg2];
}

getOlympicMedals<string, string>('1st ', '2nd '); // ["1st ","2nd "]
```

### Klasy

Typ贸w generycznych, jak ju偶 wczeniej wspominaem, mo偶emy u偶y r贸wnie偶 z klasami:

```ts
class Animal<T> {
  constructor(public name: T) {}

  getAnimalName(name: T) {
    console.log(name);
  }
}
const giraffe = new Animal<string>('Skittles');
giraffe.getAnimalName('Skittles');
```

### Interfejsy

Przyszed czas na _generyczne interfejsy_, tutaj podobna sytuacja.

```ts
interface Person<V, W> {
  userName: V;
  hobbies: W[];
}

function getUserInfo<T, U>(userName: T, hobbies: U[]): Person<T, U> {
  const user: Person<T, U> = {
    userName,
    hobbies,
  };
  return user;
}
getUserInfo<string, string>('Przemek', ['programming', 'boxing', 'windsurfing']);
```

### Generic Constraints

Jest to pewne nadawanie restrykcji dla generycznych typ贸w. W tym celu u偶ywamy sowa `extends`.
Mamy tutaj interfejs `User`, kt贸rego warto **age** jest typu `number`. W funkcji rozszerzamy typ U typem `User[]`.

```ts
interface User {
  age: number;
}

function combineUserInfo<T extends object, U extends User[]>(a: T, b: U) {
  return Object.assign(a, b);
}
combineUserInfo({ name: 'Bob' }, [{ age: 23 }]);
```

#### U偶ycie typu parametru

Mo偶esz zadeklarowa typ, kt贸ry jest wymuszony przez inny typ parametru. Dla przykadu we藕my warto obiektu, podajc jej nazw. Skorzystamy tutaj z `keyof`.

```ts
function getUserLocation<T extends object>(obj: T, key: keyof T) {
  return obj[key];
}

let user = { userName: 'Maciej', age: 22 };

getUserLocation(user, 'userName'); // wszystko ok
getUserLocation(user, 'location'); // error: Argument o typie "location" nie jest przypisywalny do  'userName' lub "age".
```

## Zaawansowane typy

### Unknown

W poprzednim wpisie przekazaem Ci, 偶e `any`, mo偶e by przydatne przy zaciganiu jaki zewntrznych danych (API), jest to najpopularniejsza metoda, ale nie najlepsza. TypeScript od pewnego czasu daje nam lepszy spos贸b.

Przedstawiam Ci typ `unknown`, to wanie on mo偶e by skuteczny przy danych z API. Jest on bardzo podobny do `any`, bo tak jak `any` mo偶e przyj ka偶dy typ. Samo `unknown` nie jest jednak przypisywalne do innej wartoci ni偶 `any` lub `unknown`, bez aktywnej asercji typ贸w. Dlaczego `unknown` jest lepszym wyborem od `any`? Daje nam on podobn _swobod_, ale pilnuje nas, przed niewiadomym przypisaniem do poprawnie otypowej zmiennej.

```ts
const userName: any = 'Kamil';
const userAge: unknown = 23;

const newName: string = userName; // wszystko okej
const newAge: number = userAge; // typ unknown nie jest przypisywalny do typu number
```

### Aliasy typ贸w

Pozwala na zdefiniowanie **aliasu** danego typu. Czsto w przykadach wykorzystywalimy typ `string` dla userName. Jeli zdefiniujemy sobie taki alias, bdziemy mogli go u偶ywa w wielu miejscach.

```ts
type UserName = string;

function getUserName(userName: UserName): UserName {
  return userName;
}

const newUserName: UserName = 'Tomek';
```

### Intersection Types

Poczenie dw贸ch typ贸w w jeden:

```ts
type Animal = {
  name: string;
  breed: string;
};

type Human = {
  name: string;
  origin: string;
};

type Wolverin = Animal & Human;
```

Wykorzystywany czsto z interfejsami:

```ts
interface Animal {
  name: string;
  breed: string;
}

interface Human {
  name: string;
  origin: string;
}

function transformToWolf(character: Animal & Human){...};
```

Wykorzystanie z operatorem OR:

```ts
type ArrayOrObject = [] | {};
type ArrayOrNull = [] | null;

type UniversalType = ArrayOrObject & ArrayOrNull; // []
```

### Union Types i Type guard

Pozwala opisa typ jeden z dw贸ch (lub wielu). Mo偶emy go fajnie u偶y z tzw. **Type guardem**.
Co to jest type guard? Type guard pozwala nam sprawdzi np. Czy dana zale偶no znajduje si w obiekcie. `in` to zale偶no JavaScriptowa, nie TS'owa.
Type guardem mo偶e by r贸wnie偶 [typeof](https://www.typescriptlang.org/docs/handbook/advanced-types.html#typeof-type-guards) czy te偶 [instanceof](https://www.typescriptlang.org/docs/handbook/advanced-types.html#instanceof-type-guards), metod na type guardy jest wiele.

```ts
interface Animal {
  name: string;
  breed: string;
}

interface Human {
  name: string;
  origin: string;
}

type Wolverin = Animal | Human;

const printBreed = (character: Wolverin): void | null => {
  if ('breed' in character) {
    console.log(`Breed: ${character.breed}`);
  }
  return null;
};

const character = {
  name: 'Wolverine',
  breed: '',
};

printBreed(character);
```

### String/Numeric literals types

String literals to taka kombinacja `union types`,`type guards` i alias贸w. Powiedzmy, 偶e zamiast po prostu typu string, potrzebujemy sprawdza konkretne wartoci. To samo tyczy si Numeric literals type.

```ts
type WolverineEnemies = 'Daken' | 'Sabretooth' | 'Lady Deathstrike';

class WolverineFight {
  fightWithEnemie(health: number, enemy: WolverineEnemies) {
    if (enemy === 'Daken') {
      // ..
    } else if (enemy === 'Sabretooth') {
      //...
    } else if (enemy === 'Lady Deathstrike') {
      //...
    } else {
      // bd!
    }
  }
}

let firstFight = new WolverineFight();
firstFight.fightWithEnemie(50, 'Sabretooth');
```

### Discriminated Unions

Mo偶esz czy samodzielne typy, union types, type guardsy, aliasy typ贸w i stworzy zaawansowany patern zwany **Discriminated Union**.

Przykad wykorzystanie z interfejsami do jasno przedstawia dokumentacja:

```ts
interface Square {
  kind: 'square';
  size: number;
}
interface Rectangle {
  kind: 'rectangle';
  width: number;
  height: number;
}
interface Circle {
  kind: 'circle';
  radius: number;
}

type Shape = Square | Rectangle | Circle;

function area(s: Shape) {
  switch (s.kind) {
    case 'square':
      return s.size * s.size;
    case 'rectangle':
      return s.height * s.width;
    case 'circle':
      return Math.PI * s.radius ** 2;
  }
}
```

Wicej zaawansowanych typ贸w mo偶esz znale藕 w [dokumentacji](https://www.typescriptlang.org/docs/handbook/advanced-types.html). Nie wspomniaem tutaj, chocia偶by o [mapped types](https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types), [polimorficznym this](https://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types) i kilku innych.

## Utility Types

S to globalne typy pomocnicze. Przydajsi, jeli mamy kilka typ贸w, kt贸re s np. `readonly` lub `optional`. Maj podobn skadni do [typ贸w generycznych](www.frontlive.pl/typescript-redniozaawansowy/#generyki).

### Partial

_Transformuje_ wszystkie typy do typ贸w oznaczonych jako opcjonalne.

```ts
interface Todo {
  title: string;
  description: string;
}

function updateTodo(todo: Todo, fieldsToUpdate: Partial<Todo>) {...}
```

### Readonly

_Przeksztaca_ wszystkie typy do typ贸w `readonly`

```ts
interface Todo {
  title: string;
}

const todo: Readonly<Todo> = {
  title: 'Napisa nowy wpis na Frontlive.pl',
};

todo.title = 'TypeScript jest super!'; // bd!
```

Mamy dostp do a偶 16 utility types, znajdziesz je wszystkie [tutaj](https://www.typescriptlang.org/docs/handbook/utility-types.html).

## Object & object

W TypeScriptcie mamy dwa sposoby na typowanie obiekt贸w. `Object` jest typem dla instancji klasy Object, natomiast `object` jest typem dla wszystkich, nieprymitywnych wartoci. R贸偶nica w nazewnictwie do subtelna, ale s to dwie zupenie inne rzeczy. Zobaczmy, jak to dziaa w praktyce.

```ts
const getUserName = (userName: Object) => {...}
getUserName('Kamil'); // Wszystko okej

const getUserFullName = (fullName: object) => {...}
getUserFullName('Kamil Kowalski'); // error, prymitywna warto
```

Za贸偶my, 偶e chcielibymy mie obiekt z metod`toString()`, jeli nadajmy typ obiektowi - `Object` to dostaniemy bd o niekompatybilnoci typ贸w, jeli typ naszego obiektu bdzie `objekt`, wszystko powinno by okej.

```ts

const user: Object = {
  toString() {...} // bd!
};

const anotherUser: object = {
  toString(){...}
}
```

## Type vs Interface

Poznalimy ju偶 **aliasy typ贸w** i **interfesjy**, pewnie wielu z was zastanawia si, jakie r贸偶nice s pomidzy nimi.

Tak, jak ju偶 Ci pokazywaem w poprzednim wpisie, ale nie podajc jeszcze tej nazwy, **object type literals** mo偶emy wpisywa inlinowo, czego nie da sizrobi z **interfesjami**.

```ts
// Object type literals
const getUserName = (user: {userName: string}) => {...}

// Interfejsy
interface User {
  age: number;
}

const getUserAge = (user: User) => {...}
```

Typ贸w alias贸w nie mo偶emy duplikowa, jeli zduplikujemy interfejs, to _zczy_ on si w jeden, praktyka znana jako **Declaration merging**.

```ts
// bd!
type User = {
  userName: string;
};

// bd!
type User = {
  age: number;
};

interface Dog {
  name: string;
}

interface Dog {
  age: number;
}
```

![](../images/InterfacevsType.jpeg)

R贸偶nic jest jeszcze kilka, czy to skr贸cony zapis, wygoda, [mapowane typy](https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types) czy te偶 [polimorficzny this](https://www.typescriptlang.org/docs/handbook/advanced-types.html#polymorphic-this-types). Jeli chcesz dowiedzie si wicej, polecam Ci [to issue](https://github.com/peerigon/eslint-config-peerigon/issues/64) na githubie.

## Podsumowanie

To tyle na dzi. Chciaem dorzuci jeszcze tutaj kilka temat贸w, ale i tak wpis wyszed troch dugi, **wicej za tydzie!**.

Przedstawiem Ci tutaj tylko **wskie spojrzenie** na cay temat, jeli bdziesz zainteresowany, zawsze mo偶esz spojrze do dokumentacji i **odkrywa nowe rzeczy**, nie da si bowiem w jednym artykule rozwin ka偶dego tematu w 100%. Jeli zainteresowa Ci TypeScript i nie chcesz czyta dokumentacji, ale chciaby zagbi si jeszcze bardziej w ten wiat, to zachcam do przeczytania jakie **dobrej ksi偶ki** o TypeScripcie, na przykad tej: [TypeScript na powa偶nie - Micha Miszczyszyn](https://typescriptnapowaznie.pl/).

Jeli dotrwae do koca, to przyje konkretn dawk wiedzy i pewnie Tw贸j m贸zg, tak samo jak m贸j, gdy tego wszystkiego si uczyem (wci偶 ucz), **eksplodowa** く.

Pamitaj, 偶eby **przewiczy** zdobyt dzi wiedz, mo偶esz popr贸bowa i **rozbudowa** powy偶sze przykady lub pobawi si w [TypeScriptowym playgroudzie!](https://www.typescriptlang.org/play/index.html)

Do usyszenia za tydzie!

### 殴r贸da

- [Typescriptlang](https://www.typescriptlang.org/index.html).
- [2ality](https://2ality.com/index.html).
- [Johannes Ewald - TypeScript: types vs. interfaces ](https://github.com/peerigon/eslint-config-peerigon/issues/64)
- [Types vs. interfaces in TypeScript  - Karol Majewski](https://twitter.com/karoljmajewski/status/1082413696075382785)
