---
title: 'React Children & TypeScript - wszystko co powinieneÅ› wiedzieÄ‡'
category: 'React'
publishedAt: '24-08-2021'
isPublished: true
popular: false
image: '/images/react-query-wprowadzenie/react-query.png'
excerpt: 'Koncepcja dzieci w Reakcie pojawia siÄ™Â nam juÅ¼ w bardzo wczesnych etapach nauki. Ich sposÃ³b dziaÅ‚ania po chwili okazuje siÄ™Â bardzo prosty, ale w praktyce childreny oferujÄ… znacznie wiÄ™cej, sÄ… trochÄ™ tricki i potrafiÄ…Â zaskoczyÄ‡ ğŸ¤” Jak wiÄ™c sobie z nimi radziÄ‡ i na uwaÅ¼aÄ‡ podczas ich wykorzystania?'
---

Koncepcja dzieci w Reakcie pojawia siÄ™Â nam juÅ¼ w bardzo wczesnych etapach nauki. Ich sposÃ³b dziaÅ‚ania po chwili okazuje siÄ™Â bardzo prosty, ale w praktyce `children` oferujÄ… znacznie wiÄ™cej, sÄ… trochÄ™ _tricki_ i potrafiÄ…Â zaskoczyÄ‡ ğŸ¤” Jak wiÄ™c sobie z nimi radziÄ‡ i na uwaÅ¼aÄ‡ podczas ich wykorzystania? Jedziemy z tematem!

## Podstawy

JeÅ›li do tej pory nie sÅ‚yszaÅ‚eÅ› o dzieciach w React, to polecam na starcie odzwiedziÄ‡ [oficjalnÄ… dokumentacjÄ™](https://pl.reactjs.org/docs/composition-vs-inheritance.html). A my jedziemy z powtÃ³rkÄ…! Dzieci sÄ… spejcalnymi propsami, ktÃ³re pomagajÄ… nam w komponowaniu komponentÃ³w. SpÃ³jrz na przykÅ‚ad:

```tsx
type ListProps = {
  children: '?';
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    <li>Banana ğŸŒ</li>
    <li>Strawberry ğŸ“</li>
  </List>
);
```

Tworzymy dwa komponenty, pierwszy `<List>`, ktÃ³ry bÄ™dzie przyjmowaÅ‚ dzieci, oraz komponent `<App>`, ktÃ³ry bÄ™dzie wywolywaÅ‚ ten pierwszy. Podczas wywoÅ‚ania komponentu `<List>` do jego **Å›rodka** przekazujemy np. elementy HTML, ot caÅ‚a filozofia...Tylko, Å¼e nie do koÅ„ca!

## Typy

I tutaj zaczyna siÄ™ prawdziwa zabawa. W teorii `chilren` mogÄ… byÄ‡ wszystkim, jednak czÄ™sto chcemy, aby byÅ‚y czymÅ›Â bardziej konkretnym, spÃ³jrzmy na dostÄ™pne opcje:

### ReactNode

Typ `React.ReactNode` to najpopularniejsza z opcji. Korzysta z niej np. nie polecany przeze mnie typ `React.FC`. WracajÄ…c, `React.ReactNode` jest bardzo giÄ™tkim typem i przepuszcza przez nasze dzieci dosÅ‚ownie wszystko: portal, tekst, liczy, boolean, elementy, komponenty...

```tsx
type ListProps = {
  children: React.ReactNode;
};

const List = ({ children }: ListProps) => <div>{children}</div>;

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    Banana ğŸŒ ['Strawberry ğŸ“'] false
  </List>
);
```

### ReactElement

DziÄ™ki `React.ReactElement` nasze _childreny_ bÄ™dÄ… mogÅ‚by byÄ‡ tylko komponentem/elementem HTML:

```tsx
type ListProps = {
  children: Array<React.ReactElement>;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const ListItem = () => <span>Apple ğŸ</span>;

const App = () => (
  <List>
    <ListItem />
    <p>Banana ğŸŒ</p>
    <h2>Strawberry ğŸ“</h2>
  </List>
);
```

### ReactText

Typ `React.ReactText` akceptuje tylko ciÄ…g znakÃ³w/liczb. Zdecydowanie lepsza opcja jeÅ›li chcemy wprowadziÄ‡ takie ogarniczenia:

```tsx
type ListProps = {
  children: React.ReactText;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => <List>Apple ğŸ Banana ğŸŒ Strawberry ğŸ“</List>;
```

## ReactChild

Ten typ jest poÅ‚Ä…czeniem (a taka naprawdÄ™ uniÄ…) typÃ³w `ReactElement` i `ReactText`:

```tsx
type ListProps = {
  children: React.ReactChild;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    Apple ğŸ <li>Banana ğŸŒ</li> Strawberry ğŸ“
  </List>
);
```

## ZawÄ™Å¼enie typu

ZaÅ‚Ã³Å¼my, Å¼e w naszym kodzie chcemy zadeklarowaÄ‡ tak jak wyÅ¼ej komponent `<List>`, ktÃ³ry bÄ™dzie nieoznaczonÄ…Â listÄ…. Z racji tego, Å¼e dzieÄ‡mi `<ul>` mogÄ… byÄ‡ **tylko** `<li>`, chcieli byÅ›my naÅ‚oÅ¼yÄ‡ ograniczenie dla `children` na ten konkretny tag, czy to moÅ¼liwe?

Na pierwszy strzaÅ‚ niech poleci `React.ReactElement`, jest on typem generycznym do ktÃ³rego moÅ¼emy podaÄ‡ konkretny element, czy to wystarczy?

```tsx
type ListProps = {
  children: React.ReactElement<'li'>;
};

const List = ({ children }: ListProps) => <ul>{children}</ul>;

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    Banana ğŸŒ Strawberry ğŸ“
  </List>
);
```

OkazujÄ™Â siÄ™, Å¼e nie âŒ SprÃ³bujmy jeszcze inaczej:

```tsx
const ListItem = ({ name }: { name: string }) => <li>{name}</li>;

type ListProps = {
  children: React.ReactElement<'li'>; // âŒ
  children: JSX.InstrictElements['li']; // âŒ
  children: typeof ListItem; // âŒ
  ... //  âŒ
};
```

Te i inne opcje po prostu nie zadziaÅ‚ajÄ… tak jakbyÅ›my tego oczekiwali... Dzieje siÄ™ to z tego wzglÄ™du, Å¼e komponenty/elementy zamieniane sÄ… w locie na typ `JSX.Element`, a szkoda.

<Newsletter />

## Nie jakoÅ›Ä‡, a iloÅ›Ä‡

Co pozostaje nam, biednym Reaktowcom, jeÅ›li nie moÅ¼emy wskazaÄ‡ dokÅ‚adnego typu? Wskazanie **dokÅ‚adnej iloÅ›ci!** No moÅ¼e nie w 100% dokÅ‚adniej, ale zawsze coÅ›. W naszym typie moÅ¼emy wskazaÄ‡ czy `children` bÄ™dÄ… np.Â pojedynczym elementem, tablicÄ… elementÃ³w lub tuplem (tablica o okreÅ›lonej dÅ‚ugoÅ›ci i okreÅ›lonych typach):

```tsx
import { ReactElement } from 'react';

type ListProps = {
  children: ReactElement;
  children: Array<ReactElement>;
  children: [ReactElement, ReactElement, ReactElement];
  children: [ReactElement, ReactText, ReactFragment];
};
```

## Metody iteracyjne

React oprÃ³cz samego mechanizmu komponentÃ³w rodzicÃ³w i dzieci udostÄ™pnia nam rÃ³wnieÅ¼ szereg metod dla API `React.Children`. Nie bÄ™dÄ™ Ci tutaj przytaczaÅ‚ wszystkich, sÄ… one bardzo dobrze opisane w [dokumentacji](https://pl.reactjs.org/docs/react-api.html#reactchildren). ChciaÅ‚bym jednak wrÃ³ciÄ‡ do naszego problemu, wiemy juÅ¼, Å¼e nie moÅ¼emy w peÅ‚ni bezpiecznie otypowaÄ‡ dzieci, jak wiÄ™c obejÅ›Ä‡ ten problem?

1. Deklarujemy typ dla `children`, ustawiamy go jako tabliÄ™Â `React.ReactElement`
2. Korzystamy z metody `toArray` obiektu `Children`, ktÃ³ra zwraca dzieci jako pÅ‚askÄ… strukturÄ™
3. Sprawdzamy, czy aby na pewno nasz `child` jest elementem Reaktowym. Dlaczego tak, skoro w propsach mamy juÅ¼ pewnoÅ›Ä‡? W wyniku metody `toArray` kaÅ¼de z naszych dzieci bÄ™dzie miaÅ‚o typ `ReactChild | ReactFragment | ReactPortal`, my chcemy mieÄ‡ pewnoÅ›Ä‡, Å¼e jest to `ReactElement`. MoglibyÅ›my do tego celu stworzyÄ‡ dedykowanego _type guarda_, ale React nas wyrÄ™cza i udostÄ™pnia funkcjÄ™ `isValidElement`
4. Spradzamy, czy typ dziecka jest rÃ³wny typowi jaki posiada `<li>`
5. JeÅ›li tak, klonujemy i zwracamy `child`
6. JeÅ›li nie, opakowujemy `child` w tag `<li>`
7. JeÅ›li nic z tego nie jest prawdÄ…, po prostu zwracamy `child` (dla pewnoÅ›ci)
8. CaÅ‚oÅ›Ä‡Â opakowujemy w zmiennÄ…Â i przekazujemy do `<ul>`

```tsx
import { Children, ReactElement, isValidElement, cloneElement } from 'react';

type ListProps = {
  // #1
  children: Array<ReactElement>;
};

const List = ({ children }: ListProps) => {
  // #2
  const newChildren = Children.toArray(children).map((child) => {
    // #3
    if (isValidElement(child)) {
      // #4
      if (child.type === 'li') {
        // #5
        return cloneElement(child, { key: child.key });
      }
      // #6
      return <li key={child.key}>{child}</li>;
    }
    // #7
    return child;
  });
  // #8
  return <ul>{newChildren}</ul>;
};

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    <a href="banana.html">Banana ğŸŒ</a>
    <p>Strawberry ğŸ“</p>
  </List>
);
```

### Problemy z React.Fragment

Wszystko byÅ‚oby piÄ™knie, gdyby nie `React.Fragment`. DomyÅ›lnie metoda `React.Children.toArray()` spÅ‚aszcza nam strukturÄ™ `children`, ale... No wÅ‚aÅ›nie, pozostawia fragmenty. Problem pojawia siÄ™ gdy do naszej listy podamy dzieci w takiej formie:

```tsx
<List>
  <li>Apple ğŸ</li>
  <>
    <a href="banana.html">Banana ğŸŒ</a>
    <p>Strawberry ğŸ“</p>
  </>
</List>
```

Zamiast trzech `<li>` zostanÄ… wyrenderowane dwa. Jak temu zaradziÄ‡? PowstaÅ‚a [biblioteka](https://github.com/grrowl/react-keyed-flatten-children) specjalnie pod ten problem, ktÃ³ra udostÄ™pnia funkcje `flattenChildren`. Zobaczmy na caÅ‚y, poprawiony przykÅ‚ad:

```tsx
import { Children, ReactElement, isValidElement, cloneElement } from 'react';
import flattenChildren from 'react-keyed-flatten-children';

type ListProps = {
  children: Array<ReactElement>;
};

const List = ({ children }: ListProps) => {
  const newChildren = flattenChildren.map((child) => {
    if (isValidElement(child)) {
      if (child.type === 'li') {
        return cloneElement(child, { key: child.key });
      }

      return <li key={child.key}>{child}</li>;
    }

    return child;
  });

  return <ul>{newChildren}</ul>;
};

const App = () => (
  <List>
    <li>Apple ğŸ</li>
    <>
      <a href="banana.html">Banana ğŸŒ</a>
      <p>Strawberry ğŸ“</p>
    </>
    <span>Blueberry ğŸ«</span>
  </List>
);
```

## Podsumowanie

To by byÅ‚o na tyle jeÅ›li chodzi o `children` w React & TypeScript. Polecam Ci szczegÃ³lnie zapoznaÄ‡ siÄ™ z innymi metodami dla `React.Children`, chociaÅ¼ nie stosuje siÄ™ ich na codzieÅ„, to jak widaÄ‡, potrafiÄ…Â siÄ™ przydaÄ‡ :)

JeÅ›li ten artykuÅ‚ okazaÅ‚ siÄ™ dla Ciebie przydatny, podziel siÄ™Â nim z innymi!

Do sÅ‚yszenia!

### Czytaj wiÄ™cej

- [React Children API](https://pl.reactjs.org/docs/react-api.html#reactchildren)
- [React TypeScript CheatSheet](https://github.com/typescript-cheatsheets/react)
